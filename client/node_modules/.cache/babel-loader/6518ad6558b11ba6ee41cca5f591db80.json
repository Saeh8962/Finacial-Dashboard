{"ast":null,"code":"var _classCallCheck = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar OUT = Symbol(\"OUT\");\n/** @ignore */\n\nvar mergesortStream = require(\"./util/merge-sort-stream\");\n/** @ignore */\n\n\nvar EventEmitter = require(\"events\").EventEmitter;\n/** @ignore */\n\n\nvar scramjet = require(\"./\");\n\nvar DataStream = scramjet.DataStream,\n    PromiseTransformStream = scramjet.PromiseTransformStream;\n/**\n * An object consisting of multiple streams than can be refined or muxed.\n *\n * The idea behind a MultiStream is being able to mux and demux streams when needed.\n *\n * Usage:\n * ```javascript\n * new MultiStream([...streams])\n *  .mux();\n *\n * new MultiStream(function*(){ yield* streams; })\n *  .map(stream => stream.filter(myFilter))\n *  .mux();\n * ```\n *\n * @memberof module:scramjet.\n */\n\nvar MultiStream = /*#__PURE__*/function (_EventEmitter) {\n  \"use strict\";\n\n  _inherits(MultiStream, _EventEmitter);\n\n  var _super = _createSuper(MultiStream);\n\n  /**\n   * Crates an instance of MultiStream with the specified stream list\n   *\n   * @param  {stream.Readable[]|AsyncGenerator<Readable>|Generator<Readable>} streams the list of readable streams (other objects will be filtered out!)\n   * @param  {object} [options={}] Optional options for the super object. ;)\n   *\n   * @test test/methods/multi-stream-constructor.js\n   */\n  function MultiStream(streams) {\n    var _this;\n\n    _classCallCheck(this, MultiStream);\n\n    _this = _super.call(this, (arguments.length <= 1 ? 0 : arguments.length - 1) ? arguments.length <= 1 ? undefined : arguments[1] : streams);\n    /**\n     * Array of all streams\n     * @type {Array}\n     */\n\n    _this.streams = [];\n    /**\n     * Source of the MultiStream.\n     *\n     * This is nulled when the stream ends and is used to control the\n     *\n     * @type {DataStream}\n     */\n\n    _this.source = null;\n\n    if (Array.isArray(streams)) {\n      streams.forEach(function (str) {\n        return _this.add(str);\n      });\n    } else if (streams) {\n      _this.source = scramjet.DataStream.from(streams).do(function (stream) {\n        return _this.add(stream);\n      }).run().then(function () {\n        return _this._checkEmpty(true);\n      });\n    }\n\n    return _this;\n  }\n  /**\n   * Constructs MultiStream from any number of streams-likes\n   *\n   * @param {Array<Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|string|Readable>} streams the array of input streamlike elements\n   * @param {function(new:DataStream)} [StreamClass=DataStream]\n   * @returns {MultiStream}\n   */\n\n\n  _createClass(MultiStream, [{\n    key: \"length\",\n    get:\n    /**\n     * Returns the current stream length\n     * @return {number}\n     */\n    function get() {\n      return this.streams.length;\n    }\n    /**\n     * @callback MultiMapCallback\n     * @memberof module:scramjet~\n     * @async\n     * @param {DataStream} stream\n     * @returns {DataStream}\n     */\n\n    /**\n     * Returns new MultiStream with the streams returned by the transform.\n     *\n     * Runs a callback for every stream, returns a new MultiStream of mapped\n     * streams and creates a new MultiStream consisting of streams returned\n     * by the Function.\n     *\n     * @chainable\n     * @param  {MultiMapCallback} aFunc Add callback (normally you need only this)\n     * @param  {MultiMapCallback} rFunc Remove callback, called when the stream is removed\n     * @return {Promise<MultiStream>}  the mapped instance\n     *\n     * @test test/methods/multi-stream-map.js\n     */\n\n  }, {\n    key: \"map\",\n    value: function map(aFunc, rFunc) {\n      var _this2 = this;\n\n      return Promise.all(this.streams.map(function (s) {\n        return Promise.resolve(s).then(aFunc);\n      })).then(function (streams) {\n        var out = new _this2.constructor(streams);\n\n        _this2.on(\"add\", function (stream) {\n          return Promise.resolve(stream).then(aFunc).then(out.add.bind(out));\n        });\n\n        if (rFunc) _this2.on(\"remove\", function (stream) {\n          return Promise.resolve(stream).then(rFunc).then(out.remove.bind(out));\n        });\n        return out;\n      });\n    }\n    /**\n     * Calls Array.prototype.find on the streams\n     *\n     * @param  {any[]} ...args arguments for\n     * @return {DataStream}  found DataStream\n     */\n\n  }, {\n    key: \"find\",\n    value: function find() {\n      var _this$streams;\n\n      return (_this$streams = this.streams).find.apply(_this$streams, arguments);\n    }\n  }, {\n    key: \"each\",\n    value: function each(aFunc, rFunc) {\n      var _this3 = this;\n\n      return Promise.all(this.streams.map(function (s) {\n        return Promise.resolve(s).then(aFunc);\n      })).then(function () {\n        _this3.on(\"add\", function (stream) {\n          return Promise.resolve(stream).then(aFunc);\n        });\n\n        if (rFunc) _this3.on(\"remove\", function (stream) {\n          return Promise.resolve(stream).then(rFunc);\n        });\n        return _this3;\n      });\n    }\n    /**\n     * Filters the stream list and returns a new MultiStream with only the\n     * streams for which the Function returned true\n     *\n     * @chainable\n     * @param  {Function} func Filter ran in Promise::then (so you can\n     *                                  return a promise or a boolean)\n     * @return {MultiStream}  the filtered instance\n     *\n     * @test test/methods/multi-stream-filter.js\n     */\n\n  }, {\n    key: \"filter\",\n    value: function filter(func) {\n      var _this4 = this;\n\n      return Promise.all(this.streams.map(function (s) {\n        return Promise.resolve(s).then(func).then(function (o) {\n          return o ? s : null;\n        });\n      })).then(function (streams) {\n        var out = new _this4.constructor(streams.filter(function (s) {\n          return s;\n        }));\n\n        _this4.on(\"add\", function (stream) {\n          return Promise.resolve(stream).then(func).then(out.add.bind(out));\n        });\n\n        _this4.on(\"remove\", out.remove.bind(out));\n\n        return out;\n      });\n    }\n    /**\n     * Muxes the streams into a single one\n     *\n     * @todo For now using comparator will not affect the mergesort.\n     * @todo Sorting requires all the streams to be constantly flowing, any\n     *       single one drain results in draining the muxed too even if there\n     *       were possible data on other streams.\n     *\n     * @param  {Function} [comparator] Should return -1 0 or 1 depending on the\n     *                                  desired order. If passed the chunks will\n     *                                  be added in a sorted order.\n     * @param {function(new:DataStream)} [ClassType=DataStream] the class to be outputted\n     * @return {DataStream}  The resulting DataStream\n     *\n     * @test test/methods/multi-stream-mux.js\n     */\n\n  }, {\n    key: \"mux\",\n    value: function mux() {\n      var _this5 = this;\n\n      var comparator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var ClassType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scramjet.DataStream;\n      this[OUT] = new ClassType();\n\n      if (!comparator) {\n        var unpipeStream = function unpipeStream(stream) {\n          if (stream) stream.unpipe(_this5[OUT]);\n\n          _this5[OUT].setMaxListeners(_this5.streams.length);\n        };\n\n        var pipeStream = function pipeStream(stream) {\n          _this5[OUT].setMaxListeners(_this5.streams.length);\n\n          stream.pipe(_this5[OUT], {\n            end: false\n          });\n        };\n\n        this.on(\"add\", pipeStream);\n        this.on(\"remove\", unpipeStream);\n        this.streams.forEach(pipeStream);\n        this.on(\"empty\", function () {\n          return _this5[OUT].end();\n        });\n        return this[OUT];\n      }\n\n      return mergesortStream(this, comparator, 0, ClassType);\n    }\n    /**\n     * Adds a stream to the MultiStream\n     *\n     * If the stream was muxed, filtered or mapped, this stream will undergo the\n     * same transforms and conditions as if it was added in constructor.\n     *\n     * @meta.noReadme\n     * @param {Readable} stream [description]\n     *\n     * @test test/methods/multi-stream-add.js\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(stream) {\n      var _this6 = this;\n\n      if (stream) {\n        this.streams.push(stream);\n        this.setMaxListeners(this.streams.length + EventEmitter.defaultMaxListeners);\n        this.emit(\"add\", stream, this.streams.length - 1);\n        stream.on(\"end\", function () {\n          return _this6.remove(stream);\n        });\n      }\n\n      return this;\n    }\n    /**\n     * Removes a stream from the MultiStream\n     *\n     * If the stream was muxed, filtered or mapped, it will be removed from same\n     * streams.\n     *\n     * @meta.noReadme\n     * @param {Readable} stream [description]\n     *\n     * @test test/methods/multi-stream-remove.js\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(stream) {\n      var strIndex = this.streams.indexOf(stream);\n\n      if (strIndex >= 0) {\n        this.setMaxListeners(this.streams.length + EventEmitter.defaultMaxListeners);\n        this.streams.splice(strIndex, 1);\n        this.emit(\"remove\", stream, strIndex);\n      }\n\n      this._checkEmpty();\n\n      return this;\n    }\n  }, {\n    key: \"_checkEmpty\",\n    value: function _checkEmpty(ended) {\n      if (ended) this.source = null;\n      if (!this.source && !this.streams.length) this.emit(\"empty\");\n    }\n  }], [{\n    key: \"from\",\n    value: function from(streams) {\n      var StreamClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DataStream;\n      if (!(StreamClass.prototype instanceof PromiseTransformStream)) throw new Error(\"From can instantiate stream-like classes only\"); // We should handle non-arrays here as well\n\n      return new this(streams.map(function (x) {\n        return StreamClass.from(x);\n      }));\n    }\n  }]);\n\n  return MultiStream;\n}(EventEmitter);\n\nmodule.exports = MultiStream;","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/client/node_modules/scramjet-core/lib/multi-stream.js"],"names":["OUT","Symbol","mergesortStream","require","EventEmitter","scramjet","DataStream","PromiseTransformStream","MultiStream","streams","source","Array","isArray","forEach","str","add","from","do","stream","run","then","_checkEmpty","length","aFunc","rFunc","Promise","all","map","s","resolve","out","constructor","on","bind","remove","find","func","o","filter","comparator","undefined","ClassType","unpipeStream","unpipe","setMaxListeners","pipeStream","pipe","end","push","defaultMaxListeners","emit","strIndex","indexOf","splice","ended","StreamClass","prototype","Error","x","module","exports"],"mappings":"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","sourcesContent":["const OUT = Symbol(\"OUT\");\n\n/** @ignore */\nconst mergesortStream = require(\"./util/merge-sort-stream\");\n/** @ignore */\nconst EventEmitter = require(\"events\").EventEmitter;\n/** @ignore */\nconst scramjet = require(\"./\");\nconst { DataStream, PromiseTransformStream } = scramjet;\n\n/**\n * An object consisting of multiple streams than can be refined or muxed.\n *\n * The idea behind a MultiStream is being able to mux and demux streams when needed.\n *\n * Usage:\n * ```javascript\n * new MultiStream([...streams])\n *  .mux();\n *\n * new MultiStream(function*(){ yield* streams; })\n *  .map(stream => stream.filter(myFilter))\n *  .mux();\n * ```\n *\n * @memberof module:scramjet.\n */\nclass MultiStream extends EventEmitter {\n\n    /**\n     * Crates an instance of MultiStream with the specified stream list\n     *\n     * @param  {stream.Readable[]|AsyncGenerator<Readable>|Generator<Readable>} streams the list of readable streams (other objects will be filtered out!)\n     * @param  {object} [options={}] Optional options for the super object. ;)\n     *\n     * @test test/methods/multi-stream-constructor.js\n     */\n    constructor(streams, ...args) {\n\n        super(args.length ? args[0] : streams);\n\n        /**\n         * Array of all streams\n         * @type {Array}\n         */\n        this.streams = [];\n\n        /**\n         * Source of the MultiStream.\n         *\n         * This is nulled when the stream ends and is used to control the\n         *\n         * @type {DataStream}\n         */\n        this.source = null;\n\n        if (Array.isArray(streams)) {\n            streams.forEach((str) => this.add(str));\n        } else if (streams) {\n            this.source = scramjet.DataStream\n                .from(streams)\n                .do(stream => this.add(stream))\n                .run()\n                .then(() => this._checkEmpty(true))\n            ;\n        }\n    }\n\n    /**\n     * Constructs MultiStream from any number of streams-likes\n     *\n     * @param {Array<Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|string|Readable>} streams the array of input streamlike elements\n     * @param {function(new:DataStream)} [StreamClass=DataStream]\n     * @returns {MultiStream}\n     */\n    static from(streams, StreamClass = DataStream) {\n        if (!(StreamClass.prototype instanceof PromiseTransformStream))\n            throw new Error(\"From can instantiate stream-like classes only\");\n\n        // We should handle non-arrays here as well\n        return new this(streams.map(x => StreamClass.from(x)));\n    }\n\n    /**\n     * Returns the current stream length\n     * @return {number}\n     */\n    get length() {\n        return this.streams.length;\n    }\n\n\n    /**\n     * @callback MultiMapCallback\n     * @memberof module:scramjet~\n     * @async\n     * @param {DataStream} stream\n     * @returns {DataStream}\n     */\n\n    /**\n     * Returns new MultiStream with the streams returned by the transform.\n     *\n     * Runs a callback for every stream, returns a new MultiStream of mapped\n     * streams and creates a new MultiStream consisting of streams returned\n     * by the Function.\n     *\n     * @chainable\n     * @param  {MultiMapCallback} aFunc Add callback (normally you need only this)\n     * @param  {MultiMapCallback} rFunc Remove callback, called when the stream is removed\n     * @return {Promise<MultiStream>}  the mapped instance\n     *\n     * @test test/methods/multi-stream-map.js\n     */\n    map(aFunc, rFunc) {\n        return Promise.all(\n            this.streams.map(\n                (s) => {\n                    return Promise.resolve(s)\n                        .then(aFunc)\n                    ;\n                }\n            )\n        ).then(\n            (streams) => {\n                const out = new (this.constructor)(\n                    streams\n                );\n\n                this.on(\n                    \"add\",\n                    (stream) => Promise.resolve(stream)\n                        .then(aFunc)\n                        .then(out.add.bind(out))\n                );\n\n                if (rFunc)\n                    this.on(\n                        \"remove\",\n                        (stream) => Promise.resolve(stream)\n                            .then(rFunc)\n                            .then(out.remove.bind(out))\n                    );\n\n                return out;\n            }\n        );\n    }\n\n    /**\n     * Calls Array.prototype.find on the streams\n     *\n     * @param  {any[]} ...args arguments for\n     * @return {DataStream}  found DataStream\n     */\n    find(...args) {\n        return this.streams.find(...args);\n    }\n\n    each(aFunc, rFunc) {\n        return Promise.all(\n            this.streams.map(\n                (s) => {\n                    return Promise.resolve(s)\n                        .then(aFunc)\n                    ;\n                }\n            )\n        ).then(\n            () => {\n                this.on(\n                    \"add\",\n                    (stream) => Promise.resolve(stream).then(aFunc)\n                );\n\n                if (rFunc)\n                    this.on(\n                        \"remove\",\n                        (stream) => Promise.resolve(stream).then(rFunc)\n                    );\n\n                return this;\n            }\n        );\n    }\n\n    /**\n     * Filters the stream list and returns a new MultiStream with only the\n     * streams for which the Function returned true\n     *\n     * @chainable\n     * @param  {Function} func Filter ran in Promise::then (so you can\n     *                                  return a promise or a boolean)\n     * @return {MultiStream}  the filtered instance\n     *\n     * @test test/methods/multi-stream-filter.js\n     */\n    filter(func) {\n        return Promise.all(\n            this.streams.map(\n                (s) => Promise.resolve(s)\n                    .then(func)\n                    .then((o) => o ? s : null)\n            )\n        ).then(\n            (streams) => {\n                const out = new (this.constructor)(\n                    streams.filter((s) => s)\n                );\n                this.on(\n                    \"add\",\n                    (stream) => Promise.resolve(stream)\n                        .then(func)\n                        .then(out.add.bind(out))\n                );\n                this.on(\n                    \"remove\", out.remove.bind(out)\n                );\n                return out;\n            }\n        );\n    }\n\n    /**\n     * Muxes the streams into a single one\n     *\n     * @todo For now using comparator will not affect the mergesort.\n     * @todo Sorting requires all the streams to be constantly flowing, any\n     *       single one drain results in draining the muxed too even if there\n     *       were possible data on other streams.\n     *\n     * @param  {Function} [comparator] Should return -1 0 or 1 depending on the\n     *                                  desired order. If passed the chunks will\n     *                                  be added in a sorted order.\n     * @param {function(new:DataStream)} [ClassType=DataStream] the class to be outputted\n     * @return {DataStream}  The resulting DataStream\n     *\n     * @test test/methods/multi-stream-mux.js\n     */\n    mux(comparator = undefined, ClassType = scramjet.DataStream) {\n\n        this[OUT] = new ClassType();\n\n        if (!comparator) {\n\n            const unpipeStream = (stream) => {\n                if (stream) stream.unpipe(this[OUT]);\n                this[OUT].setMaxListeners(this.streams.length);\n            };\n\n            const pipeStream = (stream) => {\n                this[OUT].setMaxListeners(this.streams.length);\n                stream.pipe(this[OUT], {end: false});\n            };\n\n            this.on(\"add\", pipeStream);\n            this.on(\"remove\", unpipeStream);\n\n            this.streams.forEach(pipeStream);\n\n            this.on(\"empty\", () => this[OUT].end());\n\n            return this[OUT];\n        }\n\n        return mergesortStream(this, comparator, 0, ClassType);\n    }\n\n    /**\n     * Adds a stream to the MultiStream\n     *\n     * If the stream was muxed, filtered or mapped, this stream will undergo the\n     * same transforms and conditions as if it was added in constructor.\n     *\n     * @meta.noReadme\n     * @param {Readable} stream [description]\n     *\n     * @test test/methods/multi-stream-add.js\n     */\n    add(stream) {\n\n        if (stream) {\n            this.streams.push(stream);\n            this.setMaxListeners(this.streams.length + EventEmitter.defaultMaxListeners);\n            this.emit(\"add\", stream, this.streams.length - 1);\n            stream.on(\"end\", () => this.remove(stream));\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes a stream from the MultiStream\n     *\n     * If the stream was muxed, filtered or mapped, it will be removed from same\n     * streams.\n     *\n     * @meta.noReadme\n     * @param {Readable} stream [description]\n     *\n     * @test test/methods/multi-stream-remove.js\n     */\n    remove(stream) {\n\n        const strIndex = this.streams.indexOf(stream);\n        if (strIndex >= 0) {\n            this.setMaxListeners(this.streams.length + EventEmitter.defaultMaxListeners);\n            this.streams.splice(strIndex, 1);\n            this.emit(\"remove\", stream, strIndex);\n        }\n\n        this._checkEmpty();\n\n        return this;\n    }\n\n    _checkEmpty(ended) {\n        if (ended) this.source = null;\n        if (!this.source && !this.streams.length) this.emit(\"empty\");\n    }\n\n}\n\nmodule.exports = MultiStream;\n"]},"metadata":{},"sourceType":"script"}