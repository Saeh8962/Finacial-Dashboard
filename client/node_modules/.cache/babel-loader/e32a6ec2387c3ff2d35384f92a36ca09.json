{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar ignore = function ignore() {\n  return 0;\n};\n\nvar _require = require(\"./stream-errors\"),\n    StreamError = _require.StreamError;\n/**\n * Generate transform methods on the stream class.\n *\n * @internal\n * @memberof PromiseTransformStream\n * @param  {DataStreamOptions} newOptions Sanitized options passed to scramjet stream\n * @return {Boolean} returns true if creation of new stream is not necessary (promise can be pushed to queue)\n */\n\n\nmodule.exports = function (_ref) {\n  var filter = _ref.filter;\n  return function mkTransform(newOptions) {\n    var _this = this;\n\n    this.setOptions({\n      transforms: [],\n      beforeTransform: newOptions.beforeTransform,\n      afterTransform: newOptions.afterTransform,\n      promiseFlush: newOptions.promiseFlush\n    });\n    this.cork();\n\n    if (newOptions.referrer instanceof this.constructor && !newOptions.referrer._tapped && !newOptions.referrer._options.promiseFlush) {\n      return true;\n    }\n\n    process.nextTick(this.uncork.bind(this));\n    this.pushTransform(newOptions);\n\n    if (this._scramjet_options.transforms.length) {\n      var processing = [];\n      var last = Promise.resolve();\n\n      this._transform = function (chunk, encoding, callback) {\n        if (!_this._scramjet_options.transforms.length) {\n          return last.then(function () {\n            return callback(null, chunk);\n          });\n        }\n\n        var prev = last;\n        var ref = last = Promise.all([_this._scramjet_options.transforms.reduce(function (prev, transform) {\n          return prev.then(transform);\n        }, Promise.resolve(chunk)).catch(function (err) {\n          return err === filter ? filter : Promise.reject(err);\n        }), prev]).catch( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(e) {\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    if (!(e instanceof Error)) {\n                      _context.next = 4;\n                      break;\n                    }\n\n                    return _context.abrupt(\"return\", Promise.all([_this.raise(new StreamError(e, _this, \"EXTERNAL\", chunk), chunk), prev]));\n\n                  case 4:\n                    throw new Error(\"New stream error raised without cause!\");\n\n                  case 5:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee);\n          }));\n\n          return function (_x) {\n            return _ref2.apply(this, arguments);\n          };\n        }()).then(function (args) {\n          if (args && args[0] !== filter && typeof args[0] !== \"undefined\") {\n            try {\n              _this.push(args[0]);\n            } catch (e) {\n              return _this.raise(new StreamError(e, _this, \"INTERNAL\", chunk), chunk);\n            }\n          }\n        });\n        processing.push(ref); // append item to queue\n\n        if (processing.length >= _this._options.maxParallel) {\n          processing[processing.length - _this._options.maxParallel].then(function () {\n            return callback();\n          }).catch(ignore);\n        } else {\n          callback();\n        }\n\n        ref.then(function () {\n          var next = processing.shift();\n          return ref !== next && _this.raise(new StreamError(new Error(\"Promise resolved out of sequence in \".concat(_this.name, \"!\")), _this, \"TRANSFORM_OUT_OF_SEQ\", chunk), chunk);\n        });\n      };\n\n      this._flush = function (callback) {\n        if (_this._scramjet_options.runFlush) {\n          last.then(_this._scramjet_options.runFlush).then(function (data) {\n            if (Array.isArray(data)) data.forEach(function (item) {\n              return _this.push(item);\n            });else if (data) _this.push(data);\n          }, function (e) {\n            return _this.raise(e);\n          }).then(function () {\n            return callback();\n          });\n        } else {\n          last.then(function () {\n            return callback();\n          });\n        }\n      };\n    }\n  };\n};","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/client/node_modules/scramjet-core/lib/util/mk-transform.js"],"names":["ignore","require","StreamError","module","exports","filter","mkTransform","newOptions","setOptions","transforms","beforeTransform","afterTransform","promiseFlush","cork","referrer","constructor","_tapped","_options","process","nextTick","uncork","bind","pushTransform","_scramjet_options","length","processing","last","Promise","resolve","_transform","chunk","encoding","callback","then","prev","ref","all","reduce","transform","catch","err","reject","e","Error","raise","args","push","maxParallel","next","shift","name","_flush","runFlush","data","Array","isArray","forEach","item"],"mappings":"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","sourcesContent":["const ignore = () => 0;\nconst { StreamError } = require(\"./stream-errors\");\n\n\n/**\n * Generate transform methods on the stream class.\n *\n * @internal\n * @memberof PromiseTransformStream\n * @param  {DataStreamOptions} newOptions Sanitized options passed to scramjet stream\n * @return {Boolean} returns true if creation of new stream is not necessary (promise can be pushed to queue)\n */\nmodule.exports = ({filter}) => function mkTransform(newOptions) {\n    this.setOptions(\n        {\n            transforms: [],\n            beforeTransform: newOptions.beforeTransform,\n            afterTransform: newOptions.afterTransform,\n            promiseFlush: newOptions.promiseFlush\n        }\n    );\n\n    this.cork();\n    if (newOptions.referrer instanceof this.constructor && !newOptions.referrer._tapped && !newOptions.referrer._options.promiseFlush) {\n        return true;\n    }\n\n    process.nextTick(this.uncork.bind(this));\n\n    this.pushTransform(newOptions);\n\n    if (this._scramjet_options.transforms.length) {\n\n        const processing = [];\n        let last = Promise.resolve();\n\n        this._transform = (chunk, encoding, callback) => {\n            if (!this._scramjet_options.transforms.length) {\n                return last.then(\n                    () => callback(null, chunk)\n                );\n            }\n\n            const prev = last;\n            const ref = last = Promise\n                .all([\n                    this._scramjet_options.transforms.reduce(\n                        (prev, transform) => prev.then(transform),\n                        Promise.resolve(chunk)\n                    ).catch(\n                        (err) => err === filter ? filter : Promise.reject(err)\n                    ),\n                    prev\n                ])\n                .catch(\n                    async (e) => {\n                        if (e instanceof Error) {\n                            return Promise.all([\n                                this.raise(new StreamError(e, this, \"EXTERNAL\", chunk), chunk),\n                                prev\n                            ]);\n                        } else {\n                            throw new Error(\"New stream error raised without cause!\");\n                        }\n                    }\n                )\n                .then(\n                    (args) => {\n                        if (args && args[0] !== filter && typeof args[0] !== \"undefined\") {\n                            try {\n                                this.push(args[0]);\n                            } catch(e) {\n                                return this.raise(new StreamError(e, this, \"INTERNAL\", chunk), chunk);\n                            }\n                        }\n                    }\n                );\n\n            processing.push(ref);   // append item to queue\n            if (processing.length >= this._options.maxParallel) {\n                processing[processing.length - this._options.maxParallel]\n                    .then(() => callback())\n                    .catch(ignore);\n            } else {\n                callback();\n            }\n\n            ref.then(\n                () => {\n                    const next = processing.shift();\n                    return ref !== next && this.raise(new StreamError(new Error(`Promise resolved out of sequence in ${this.name}!`), this, \"TRANSFORM_OUT_OF_SEQ\", chunk), chunk);\n                }\n            );\n\n        };\n\n        this._flush = (callback) => {\n            if (this._scramjet_options.runFlush) {\n                last\n                    .then(this._scramjet_options.runFlush)\n                    .then(\n                        (data) => {\n                            if (Array.isArray(data))\n                                data.forEach(item => this.push(item));\n                            else if (data)\n                                this.push(data);\n                        },\n                        e => this.raise(e)\n                    )\n                    .then(() => callback());\n            } else {\n                last.then(() => callback());\n            }\n        };\n    }\n};\n"]},"metadata":{},"sourceType":"script"}