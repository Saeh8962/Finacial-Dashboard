{"ast":null,"code":"var _classCallCheck = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar scramjet = require(\".\");\n/**\n * A facilitation stream created for easy splitting or parsing buffers.\n *\n * Useful for working on built-in Node.js streams from files, parsing binary formats etc.\n *\n * A simple use case would be:\n *\n * ```javascript\n *  fs.createReadStream('pixels.rgba')\n *      .pipe(new BufferStream)         // pipe a buffer stream into scramjet\n *      .breakup(4)                     // split into 4 byte fragments\n *      .parse(buffer => [\n *          buffer.readInt8(0),            // the output is a stream of R,G,B and Alpha\n *          buffer.readInt8(1),            // values from 0-255 in an array.\n *          buffer.readInt8(2),\n *          buffer.readInt8(3)\n *      ]);\n * ```\n *\n * @memberof module:scramjet.\n * @borrows BufferStream#stringify as BufferStream#toStringStream\n * @borrows BufferStream#shift as BufferStream#pop\n * @borrows BufferStream#parse as BufferStream#toDataStream\n * @extends DataStream\n */\n\n\nvar BufferStream = /*#__PURE__*/function (_scramjet$DataStream) {\n  \"use strict\";\n\n  _inherits(BufferStream, _scramjet$DataStream);\n\n  var _super = _createSuper(BufferStream);\n\n  /**\n   * Creates the BufferStream\n   *\n   * @param {DataStreamOptions} [opts={}] Stream options passed to superclass\n   * @test test/methods/buffer-stream-constructor.js\n   */\n  function BufferStream() {\n    var _this;\n\n    _classCallCheck(this, BufferStream);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.buffer = [];\n    return _this;\n  }\n  /**\n   * Shift Function\n   *\n   * @callback ShiftBufferCallback\n   * @memberof module:scramjet~\n   * @param {Buffer|any} shifted shifted bytes\n   */\n\n  /**\n   * Shift given number of bytes from the original stream\n   *\n   * Works the same way as {@see DataStream.shift}, but in this case extracts\n   * the given number of bytes.\n   *\n   * @chainable\n   * @param {number} chars The number of bytes to shift\n   * @param {ShiftBufferCallback} func Function that receives a string of shifted bytes\n   *\n   * @test test/methods/string-stream-shift.js\n   */\n\n\n  _createClass(BufferStream, [{\n    key: \"shift\",\n    value: function shift(bytes, func) {\n      var _this2 = this;\n\n      var ret = Buffer.alloc(bytes);\n\n      var str = this.tap()._selfInstance();\n\n      var offs = 0;\n\n      var chunkHandler = function chunkHandler(chunk) {\n        var length = Math.min(ret.length - offs, chunk.length);\n        chunk.copy(ret, offs, 0, length);\n        offs += length;\n\n        if (length >= bytes) {\n          unHook().then(function () {\n            str.write(chunk.slice(length));\n\n            _this2.pipe(str);\n          });\n        }\n      };\n\n      var endHandler = function endHandler() {\n        if (ret.length < bytes) {\n          unHook();\n        }\n\n        str.end.apply(str, arguments);\n      };\n\n      var errorHandler = str.emit.bind(str, \"error\");\n\n      var unHook = function unHook() {\n        _this2.removeListener(\"data\", chunkHandler);\n\n        _this2.removeListener(\"end\", endHandler);\n\n        _this2.removeListener(\"error\", errorHandler);\n\n        return func(ret);\n      };\n\n      this.on(\"data\", chunkHandler);\n      this.on(\"end\", endHandler);\n      this.on(\"error\", errorHandler);\n      return str;\n    }\n    /**\n     * Splits the buffer stream into buffer objects\n     *\n     * @chainable\n     * @param  {string|Buffer} splitter the buffer or string that the stream\n     *                                  should be split by.\n     * @return {BufferStream}  the re-split buffer stream.\n     * @test test/methods/buffer-stream-split.js\n     */\n\n  }, {\n    key: \"split\",\n    value: function split(splitter) {\n      if (splitter instanceof Buffer || typeof splitter === \"string\") {\n        var needle = Buffer.from(splitter);\n        return this.tap().pipe(this._selfInstance({\n          transform: function transform(buffer, enc, callback) {\n            if (Buffer.isBuffer(this._haystack) && this._haystack.length > 0) {\n              this._haystack = Buffer.from([this._haystack, buffer]);\n            } else {\n              this._haystack = buffer;\n            }\n\n            var pos;\n\n            while ((pos = this._haystack.indexOf(needle)) > -1) {\n              this.push(Buffer.from(this._haystack.slice(0, pos)));\n              this._haystack = this._haystack.slice(pos + needle.length);\n            }\n\n            callback();\n          },\n          flush: function flush(callback) {\n            if (this._haystack && this._haystack.length) this.push(this._haystack);\n            this._haystack = null;\n            callback();\n          }\n        }));\n      }\n    }\n    /**\n     * Breaks up a stream apart into chunks of the specified length\n     *\n     * @chainable\n     * @param  {number} number the desired chunk length\n     * @return {BufferStream}  the resulting buffer stream.\n     * @test test/methods/buffer-stream-breakup.js\n     */\n\n  }, {\n    key: \"breakup\",\n    value: function breakup(number) {\n      if (number <= 0 || !isFinite(+number)) throw new Error(\"Breakup number is invalid - must be a positive, finite integer.\");\n      return this.tap().pipe(this._selfInstance({\n        transform: function transform(chunk, encoding, callback) {\n          if (Buffer.isBuffer(this.buffer)) {\n            chunk = Buffer.concat([this.buffer, chunk]);\n          }\n\n          var offset;\n\n          for (offset = 0; offset < chunk.length - number; offset += number) {\n            this.push(chunk.slice(offset, offset + number));\n          }\n\n          this.buffer = chunk.slice(offset);\n          callback();\n        },\n        flush: function flush(callback) {\n          this.push(this.buffer);\n          this.buffer = null;\n          callback();\n        }\n      }));\n    }\n    /**\n     * Creates a string stream from the given buffer stream\n     *\n     * Still it returns a DataStream derivative and isn't the typical node.js\n     * stream so you can do all your transforms when you like.\n     *\n     * @param  {string|any} [encoding=\"utf-8\"] The encoding to be used to convert the buffers\n     *                           to streams.\n     * @return {StringStream}  The converted stream.\n     * @test test/methods/buffer-stream-tostringstream.js\n     */\n\n  }, {\n    key: \"stringify\",\n    value: function stringify() {\n      var encoding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"utf-8\";\n      return this.pipe(new scramjet.StringStream(encoding, {\n        objectMode: true\n      }));\n    }\n    /**\n     * @callback BufferParseCallback\n     * @memberof module:scramjet~\n     * @param {Buffer} chunk the transformed chunk\n     * @return {Promise<any>|any}  the promise should be resolved with the parsed object\n     */\n\n    /**\n     * Parses every buffer to object\n     *\n     * The method MUST parse EVERY buffer into a single object, so the buffer\n     * stream here should already be split or broken up.\n     *\n     * @param  {BufferParseCallback} parser The transform function\n     * @return {DataStream}  The parsed objects stream.\n     * @test test/methods/buffer-stream-parse.js\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(parser) {\n      return this.tap().map(parser, scramjet.DataStream);\n    }\n    /**\n     * @meta.noReadme\n     * @ignore\n     */\n\n  }, {\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      this.push(Buffer.from(chunk, encoding));\n      return callback();\n    }\n    /**\n     * Creates a pipeline of streams and returns a scramjet stream.\n     *\n     * @see DataStream.pipeline\n     * @static\n     * @param {Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|string|Readable} readable the initial readable argument that is streamable by scramjet.from\n     * @param {Array<AsyncFunction|Function|Transform>} ...transforms Transform functions (as in {@link DataStream..use}) or Transform streams (any number of these as consecutive arguments)\n     *\n     * @returns {BufferStream} a new StringStream instance of the resulting pipeline\n     */\n\n  }], [{\n    key: \"pipeline\",\n    value: function pipeline() {\n      var _scramjet$DataStream$;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return (_scramjet$DataStream$ = scramjet.DataStream.pipeline).call.apply(_scramjet$DataStream$, [this].concat(args));\n    }\n    /**\n     * Create BufferStream from anything.\n     *\n     * @see module:scramjet.from\n     *\n     * @param {Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|Readable} stream argument to be turned into new stream\n     * @param {DataStreamOptions|Writable} [options={}] options passed to the new stream if created\n     * @return {BufferStream}          new StringStream.\n     */\n\n  }, {\n    key: \"from\",\n    value: function from() {\n      var _scramjet$DataStream$2;\n\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return (_scramjet$DataStream$2 = scramjet.DataStream.from).call.apply(_scramjet$DataStream$2, [this].concat(args));\n    }\n  }]);\n\n  return BufferStream;\n}(scramjet.DataStream);\n\nBufferStream.prototype.pop = BufferStream.prototype.shift;\nBufferStream.prototype.toDataStream = BufferStream.prototype.parse;\nBufferStream.prototype.toStringStream = BufferStream.prototype.stringify;\nmodule.exports = BufferStream;","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/client/node_modules/scramjet-core/lib/buffer-stream.js"],"names":["scramjet","require","BufferStream","args","buffer","bytes","func","ret","Buffer","alloc","str","tap","_selfInstance","offs","chunkHandler","chunk","length","Math","min","copy","unHook","then","write","slice","pipe","endHandler","end","errorHandler","emit","bind","removeListener","on","splitter","needle","from","transform","enc","callback","isBuffer","_haystack","pos","indexOf","push","flush","number","isFinite","Error","encoding","concat","offset","StringStream","objectMode","parser","map","DataStream","pipeline","call","prototype","pop","shift","toDataStream","parse","toStringStream","stringify","module","exports"],"mappings":";;;;;;;;AAAA,IAAMA,QAAQ,GAAGC,OAAO,CAAC,GAAD,CAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACMC,Y;;;;;;;AAEF;AACJ;AACA;AACA;AACA;AACA;AACI,0BAAqB;AAAA;;AAAA;;AAAA,sCAANC,IAAM;AAANA,MAAAA,IAAM;AAAA;;AACjB,oDAASA,IAAT;AACA,UAAKC,MAAL,GAAc,EAAd;AAFiB;AAGpB;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACI,eAAMC,KAAN,EAAaC,IAAb,EAAmB;AAAA;;AACf,UAAMC,GAAG,GAAGC,MAAM,CAACC,KAAP,CAAaJ,KAAb,CAAZ;;AACA,UAAMK,GAAG,GAAG,KAAKC,GAAL,GAAWC,aAAX,EAAZ;;AACA,UAAIC,IAAI,GAAG,CAAX;;AAEA,UAAMC,YAAY,GAAG,SAAfA,YAAe,CAACC,KAAD,EAAW;AAC5B,YAAMC,MAAM,GAAGC,IAAI,CAACC,GAAL,CAASX,GAAG,CAACS,MAAJ,GAAaH,IAAtB,EAA4BE,KAAK,CAACC,MAAlC,CAAf;AACAD,QAAAA,KAAK,CAACI,IAAN,CAAWZ,GAAX,EAAgBM,IAAhB,EAAsB,CAAtB,EAAyBG,MAAzB;AACAH,QAAAA,IAAI,IAAIG,MAAR;;AACA,YAAIA,MAAM,IAAIX,KAAd,EAAqB;AACjBe,UAAAA,MAAM,GACDC,IADL,CAEQ,YAAM;AACFX,YAAAA,GAAG,CAACY,KAAJ,CAAUP,KAAK,CAACQ,KAAN,CAAYP,MAAZ,CAAV;;AACA,YAAA,MAAI,CAACQ,IAAL,CAAUd,GAAV;AACH,WALT;AAOH;AACJ,OAbD;;AAeA,UAAMe,UAAU,GAAG,SAAbA,UAAa,GAAa;AAC5B,YAAIlB,GAAG,CAACS,MAAJ,GAAaX,KAAjB,EAAwB;AACpBe,UAAAA,MAAM;AACT;;AACDV,QAAAA,GAAG,CAACgB,GAAJ,OAAAhB,GAAG,YAAH;AACH,OALD;;AAOA,UAAMiB,YAAY,GAAGjB,GAAG,CAACkB,IAAJ,CAASC,IAAT,CAAcnB,GAAd,EAAmB,OAAnB,CAArB;;AAEA,UAAMU,MAAM,GAAG,SAATA,MAAS,GAAM;AACjB,QAAA,MAAI,CAACU,cAAL,CAAoB,MAApB,EAA4BhB,YAA5B;;AACA,QAAA,MAAI,CAACgB,cAAL,CAAoB,KAApB,EAA2BL,UAA3B;;AACA,QAAA,MAAI,CAACK,cAAL,CAAoB,OAApB,EAA6BH,YAA7B;;AACA,eAAOrB,IAAI,CAACC,GAAD,CAAX;AACH,OALD;;AAQA,WAAKwB,EAAL,CAAQ,MAAR,EAAgBjB,YAAhB;AACA,WAAKiB,EAAL,CAAQ,KAAR,EAAeN,UAAf;AACA,WAAKM,EAAL,CAAQ,OAAR,EAAiBJ,YAAjB;AAEA,aAAOjB,GAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,eAAMsB,QAAN,EAAgB;AACZ,UAAIA,QAAQ,YAAYxB,MAApB,IAA8B,OAAOwB,QAAP,KAAoB,QAAtD,EAAgE;AAC5D,YAAMC,MAAM,GAAGzB,MAAM,CAAC0B,IAAP,CAAYF,QAAZ,CAAf;AACA,eAAO,KAAKrB,GAAL,GAAWa,IAAX,CAAgB,KAAKZ,aAAL,CAAmB;AACtCuB,UAAAA,SADsC,qBAC5B/B,MAD4B,EACpBgC,GADoB,EACfC,QADe,EACL;AAC7B,gBAAI7B,MAAM,CAAC8B,QAAP,CAAgB,KAAKC,SAArB,KAAmC,KAAKA,SAAL,CAAevB,MAAf,GAAwB,CAA/D,EAAkE;AAC9D,mBAAKuB,SAAL,GAAiB/B,MAAM,CAAC0B,IAAP,CAAY,CAAC,KAAKK,SAAN,EAAiBnC,MAAjB,CAAZ,CAAjB;AACH,aAFD,MAEO;AACH,mBAAKmC,SAAL,GAAiBnC,MAAjB;AACH;;AAED,gBAAIoC,GAAJ;;AACA,mBAAM,CAACA,GAAG,GAAG,KAAKD,SAAL,CAAeE,OAAf,CAAuBR,MAAvB,CAAP,IAAyC,CAAC,CAAhD,EAAmD;AAC/C,mBAAKS,IAAL,CAAUlC,MAAM,CAAC0B,IAAP,CAAY,KAAKK,SAAL,CAAehB,KAAf,CAAqB,CAArB,EAAwBiB,GAAxB,CAAZ,CAAV;AACA,mBAAKD,SAAL,GAAiB,KAAKA,SAAL,CAAehB,KAAf,CAAqBiB,GAAG,GAAGP,MAAM,CAACjB,MAAlC,CAAjB;AACH;;AAEDqB,YAAAA,QAAQ;AACX,WAfqC;AAgBtCM,UAAAA,KAhBsC,iBAgBhCN,QAhBgC,EAgBtB;AACZ,gBAAI,KAAKE,SAAL,IAAkB,KAAKA,SAAL,CAAevB,MAArC,EAA6C,KAAK0B,IAAL,CAAU,KAAKH,SAAf;AAE7C,iBAAKA,SAAL,GAAiB,IAAjB;AACAF,YAAAA,QAAQ;AACX;AArBqC,SAAnB,CAAhB,CAAP;AAuBH;AACJ;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,iBAAQO,MAAR,EAAgB;AACZ,UAAIA,MAAM,IAAI,CAAV,IAAe,CAACC,QAAQ,CAAC,CAACD,MAAF,CAA5B,EACI,MAAM,IAAIE,KAAJ,CAAU,iEAAV,CAAN;AAEJ,aAAO,KAAKnC,GAAL,GAAWa,IAAX,CAAgB,KAAKZ,aAAL,CAAmB;AACtCuB,QAAAA,SADsC,qBAC5BpB,KAD4B,EACrBgC,QADqB,EACXV,QADW,EACD;AACjC,cAAI7B,MAAM,CAAC8B,QAAP,CAAgB,KAAKlC,MAArB,CAAJ,EAAkC;AAC9BW,YAAAA,KAAK,GAAGP,MAAM,CAACwC,MAAP,CAAc,CAAC,KAAK5C,MAAN,EAAcW,KAAd,CAAd,CAAR;AACH;;AACD,cAAIkC,MAAJ;;AACA,eAAKA,MAAM,GAAG,CAAd,EAAiBA,MAAM,GAAGlC,KAAK,CAACC,MAAN,GAAe4B,MAAzC,EAAiDK,MAAM,IAAIL,MAA3D,EAAmE;AAC/D,iBAAKF,IAAL,CAAU3B,KAAK,CAACQ,KAAN,CAAY0B,MAAZ,EAAoBA,MAAM,GAAGL,MAA7B,CAAV;AACH;;AACD,eAAKxC,MAAL,GAAcW,KAAK,CAACQ,KAAN,CAAY0B,MAAZ,CAAd;AACAZ,UAAAA,QAAQ;AACX,SAXqC;AAYtCM,QAAAA,KAZsC,iBAYhCN,QAZgC,EAYtB;AACZ,eAAKK,IAAL,CAAU,KAAKtC,MAAf;AACA,eAAKA,MAAL,GAAc,IAAd;AACAiC,UAAAA,QAAQ;AACX;AAhBqC,OAAnB,CAAhB,CAAP;AAmBH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,qBAA8B;AAAA,UAApBU,QAAoB,uEAAT,OAAS;AAC1B,aAAO,KAAKvB,IAAL,CAAU,IAAIxB,QAAQ,CAACkD,YAAb,CAA0BH,QAA1B,EAAoC;AAACI,QAAAA,UAAU,EAAE;AAAb,OAApC,CAAV,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,eAAMC,MAAN,EAAc;AACV,aAAO,KAAKzC,GAAL,GAAW0C,GAAX,CAAeD,MAAf,EAAuBpD,QAAQ,CAACsD,UAAhC,CAAP;AACH;AAED;AACJ;AACA;AACA;;;;WACI,oBAAWvC,KAAX,EAAkBgC,QAAlB,EAA4BV,QAA5B,EAAsC;AAClC,WAAKK,IAAL,CAAUlC,MAAM,CAAC0B,IAAP,CAAYnB,KAAZ,EAAmBgC,QAAnB,CAAV;AACA,aAAOV,QAAQ,EAAf;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,oBAAyB;AAAA;;AAAA,yCAANlC,IAAM;AAANA,QAAAA,IAAM;AAAA;;AACrB,aAAO,yBAAAH,QAAQ,CAACsD,UAAT,CAAoBC,QAApB,EAA6BC,IAA7B,+BAAkC,IAAlC,SAA2CrD,IAA3C,EAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,gBAAqB;AAAA;;AAAA,yCAANA,IAAM;AAANA,QAAAA,IAAM;AAAA;;AACjB,aAAO,0BAAAH,QAAQ,CAACsD,UAAT,CAAoBpB,IAApB,EAAyBsB,IAAzB,gCAA8B,IAA9B,SAAuCrD,IAAvC,EAAP;AACH;;;;EA1NsBH,QAAQ,CAACsD,U;;AA8NpCpD,YAAY,CAACuD,SAAb,CAAuBC,GAAvB,GAA6BxD,YAAY,CAACuD,SAAb,CAAuBE,KAApD;AACAzD,YAAY,CAACuD,SAAb,CAAuBG,YAAvB,GAAsC1D,YAAY,CAACuD,SAAb,CAAuBI,KAA7D;AACA3D,YAAY,CAACuD,SAAb,CAAuBK,cAAvB,GAAwC5D,YAAY,CAACuD,SAAb,CAAuBM,SAA/D;AAEAC,MAAM,CAACC,OAAP,GAAiB/D,YAAjB","sourcesContent":["const scramjet = require(\".\");\n\n/**\n * A facilitation stream created for easy splitting or parsing buffers.\n *\n * Useful for working on built-in Node.js streams from files, parsing binary formats etc.\n *\n * A simple use case would be:\n *\n * ```javascript\n *  fs.createReadStream('pixels.rgba')\n *      .pipe(new BufferStream)         // pipe a buffer stream into scramjet\n *      .breakup(4)                     // split into 4 byte fragments\n *      .parse(buffer => [\n *          buffer.readInt8(0),            // the output is a stream of R,G,B and Alpha\n *          buffer.readInt8(1),            // values from 0-255 in an array.\n *          buffer.readInt8(2),\n *          buffer.readInt8(3)\n *      ]);\n * ```\n *\n * @memberof module:scramjet.\n * @borrows BufferStream#stringify as BufferStream#toStringStream\n * @borrows BufferStream#shift as BufferStream#pop\n * @borrows BufferStream#parse as BufferStream#toDataStream\n * @extends DataStream\n */\nclass BufferStream extends scramjet.DataStream {\n\n    /**\n     * Creates the BufferStream\n     *\n     * @param {DataStreamOptions} [opts={}] Stream options passed to superclass\n     * @test test/methods/buffer-stream-constructor.js\n     */\n    constructor(...args) {\n        super(...args);\n        this.buffer = [];\n    }\n\n    /**\n     * Shift Function\n     *\n     * @callback ShiftBufferCallback\n     * @memberof module:scramjet~\n     * @param {Buffer|any} shifted shifted bytes\n     */\n\n    /**\n     * Shift given number of bytes from the original stream\n     *\n     * Works the same way as {@see DataStream.shift}, but in this case extracts\n     * the given number of bytes.\n     *\n     * @chainable\n     * @param {number} chars The number of bytes to shift\n     * @param {ShiftBufferCallback} func Function that receives a string of shifted bytes\n     *\n     * @test test/methods/string-stream-shift.js\n     */\n    shift(bytes, func) {\n        const ret = Buffer.alloc(bytes);\n        const str = this.tap()._selfInstance();\n        let offs = 0;\n\n        const chunkHandler = (chunk) => {\n            const length = Math.min(ret.length - offs, chunk.length);\n            chunk.copy(ret, offs, 0, length);\n            offs += length;\n            if (length >= bytes) {\n                unHook()\n                    .then(\n                        () => {\n                            str.write(chunk.slice(length));\n                            this.pipe(str);\n                        }\n                    );\n            }\n        };\n\n        const endHandler = (...args) => {\n            if (ret.length < bytes) {\n                unHook();\n            }\n            str.end(...args);\n        };\n\n        const errorHandler = str.emit.bind(str, \"error\");\n\n        const unHook = () => {\n            this.removeListener(\"data\", chunkHandler);\n            this.removeListener(\"end\", endHandler);\n            this.removeListener(\"error\", errorHandler);\n            return func(ret);\n        };\n\n\n        this.on(\"data\", chunkHandler);\n        this.on(\"end\", endHandler);\n        this.on(\"error\", errorHandler);\n\n        return str;\n    }\n\n    /**\n     * Splits the buffer stream into buffer objects\n     *\n     * @chainable\n     * @param  {string|Buffer} splitter the buffer or string that the stream\n     *                                  should be split by.\n     * @return {BufferStream}  the re-split buffer stream.\n     * @test test/methods/buffer-stream-split.js\n     */\n    split(splitter) {\n        if (splitter instanceof Buffer || typeof splitter === \"string\") {\n            const needle = Buffer.from(splitter);\n            return this.tap().pipe(this._selfInstance({\n                transform(buffer, enc, callback) {\n                    if (Buffer.isBuffer(this._haystack) && this._haystack.length > 0) {\n                        this._haystack = Buffer.from([this._haystack, buffer]);\n                    } else {\n                        this._haystack = buffer;\n                    }\n\n                    let pos;\n                    while((pos = this._haystack.indexOf(needle)) > -1) {\n                        this.push(Buffer.from(this._haystack.slice(0, pos)));\n                        this._haystack = this._haystack.slice(pos + needle.length);\n                    }\n\n                    callback();\n                },\n                flush(callback) {\n                    if (this._haystack && this._haystack.length) this.push(this._haystack);\n\n                    this._haystack = null;\n                    callback();\n                }\n            }));\n        }\n    }\n\n    /**\n     * Breaks up a stream apart into chunks of the specified length\n     *\n     * @chainable\n     * @param  {number} number the desired chunk length\n     * @return {BufferStream}  the resulting buffer stream.\n     * @test test/methods/buffer-stream-breakup.js\n     */\n    breakup(number) {\n        if (number <= 0 || !isFinite(+number))\n            throw new Error(\"Breakup number is invalid - must be a positive, finite integer.\");\n\n        return this.tap().pipe(this._selfInstance({\n            transform(chunk, encoding, callback) {\n                if (Buffer.isBuffer(this.buffer)) {\n                    chunk = Buffer.concat([this.buffer, chunk]);\n                }\n                let offset;\n                for (offset = 0; offset < chunk.length - number; offset += number) {\n                    this.push(chunk.slice(offset, offset + number));\n                }\n                this.buffer = chunk.slice(offset);\n                callback();\n            },\n            flush(callback) {\n                this.push(this.buffer);\n                this.buffer = null;\n                callback();\n            }\n        }));\n\n    }\n\n    /**\n     * Creates a string stream from the given buffer stream\n     *\n     * Still it returns a DataStream derivative and isn't the typical node.js\n     * stream so you can do all your transforms when you like.\n     *\n     * @param  {string|any} [encoding=\"utf-8\"] The encoding to be used to convert the buffers\n     *                           to streams.\n     * @return {StringStream}  The converted stream.\n     * @test test/methods/buffer-stream-tostringstream.js\n     */\n    stringify(encoding = \"utf-8\") {\n        return this.pipe(new scramjet.StringStream(encoding, {objectMode: true}));\n    }\n\n    /**\n     * @callback BufferParseCallback\n     * @memberof module:scramjet~\n     * @param {Buffer} chunk the transformed chunk\n     * @return {Promise<any>|any}  the promise should be resolved with the parsed object\n     */\n\n    /**\n     * Parses every buffer to object\n     *\n     * The method MUST parse EVERY buffer into a single object, so the buffer\n     * stream here should already be split or broken up.\n     *\n     * @param  {BufferParseCallback} parser The transform function\n     * @return {DataStream}  The parsed objects stream.\n     * @test test/methods/buffer-stream-parse.js\n     */\n    parse(parser) {\n        return this.tap().map(parser, scramjet.DataStream);\n    }\n\n    /**\n     * @meta.noReadme\n     * @ignore\n     */\n    _transform(chunk, encoding, callback) {\n        this.push(Buffer.from(chunk, encoding));\n        return callback();\n    }\n\n    /**\n     * Creates a pipeline of streams and returns a scramjet stream.\n     *\n     * @see DataStream.pipeline\n     * @static\n     * @param {Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|string|Readable} readable the initial readable argument that is streamable by scramjet.from\n     * @param {Array<AsyncFunction|Function|Transform>} ...transforms Transform functions (as in {@link DataStream..use}) or Transform streams (any number of these as consecutive arguments)\n     *\n     * @returns {BufferStream} a new StringStream instance of the resulting pipeline\n     */\n    static pipeline(...args) {\n        return scramjet.DataStream.pipeline.call(this, ...args);\n    }\n\n    /**\n     * Create BufferStream from anything.\n     *\n     * @see module:scramjet.from\n     *\n     * @param {Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|Readable} stream argument to be turned into new stream\n     * @param {DataStreamOptions|Writable} [options={}] options passed to the new stream if created\n     * @return {BufferStream}          new StringStream.\n     */\n    static from(...args) {\n        return scramjet.DataStream.from.call(this, ...args);\n    }\n\n}\n\nBufferStream.prototype.pop = BufferStream.prototype.shift;\nBufferStream.prototype.toDataStream = BufferStream.prototype.parse;\nBufferStream.prototype.toStringStream = BufferStream.prototype.stringify;\n\nmodule.exports = BufferStream;\n"]},"metadata":{},"sourceType":"script"}