{"ast":null,"code":"var _construct = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/construct\");\n\nvar _regeneratorRuntime = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _assertThisInitialized = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _require = require(\"stream\"),\n    Transform = _require.Transform,\n    Readable = _require.Readable;\n\nvar _require2 = require(\"events\"),\n    EventEmitter = _require2.EventEmitter;\n\nvar DefaultHighWaterMark = require(\"os\").cpus().length * 2;\nvar filter = Symbol(\"FILTER\");\nvar plgctor = Symbol(\"plgctor\");\nvar storector = Symbol(\"storector\");\nvar seq = 0;\nvar shared = {\n  filter: filter,\n  DefaultHighWaterMark: DefaultHighWaterMark,\n  plgctor: plgctor,\n  storector: storector\n};\n\nvar mkTransform = require(\"./mk-transform\")(shared);\n\nvar mkRead = require(\"./mk-read\")(shared);\n\nvar mkWrite = require(\"./mk-write\")(shared);\n\nvar _require3 = require(\"./stream-errors\"),\n    StreamError = _require3.StreamError;\n\nvar rename = function rename(ob, fr, to) {\n  if (ob[fr]) {\n    ob[to] = ob[fr];\n    delete ob[fr];\n  }\n};\n\nvar checkOptions = function checkOptions(options) {\n  rename(options, \"parallelRead\", \"promiseRead\");\n  rename(options, \"parallelWrite\", \"promiseWrite\");\n  rename(options, \"parallelTransform\", \"promiseTransform\");\n  rename(options, \"flushPromise\", \"promiseFlush\");\n  if ([\"promiseRead\", \"promiseWrite\", \"promiseTransform\"].reduce(function (acc, key) {\n    return acc += options[key] ? 1 : 0;\n  }, 0) > 1) throw new Error(\"Scramjet stream can be either Read, Write or Transform\");\n};\n/**\n * This class is an underlying class for all Scramjet streams.\n *\n * It allows creation of simple transform streams that use async functions for transforms, reading or writing.\n *\n * @internal\n * @extends stream.PassThrough\n */\n\n\nvar PromiseTransformStream = /*#__PURE__*/function (_Transform) {\n  \"use strict\";\n\n  _inherits(PromiseTransformStream, _Transform);\n\n  var _super = _createSuper(PromiseTransformStream);\n\n  function PromiseTransformStream(options) {\n    var _this;\n\n    _classCallCheck(this, PromiseTransformStream);\n\n    options = options || {};\n    var newOptions = Object.assign({\n      objectMode: true,\n      promiseRead: null,\n      promiseWrite: null,\n      promiseTransform: null,\n      promiseFlush: null,\n      beforeTransform: null,\n      afterTransform: null\n    }, options);\n    checkOptions(newOptions);\n    _this = _super.call(this, newOptions);\n    _this._tapped = false;\n    _this._error_handlers = [];\n    _this._scramjet_options = {\n      referrer: options.referrer,\n      constructed: new Error().stack\n    };\n    _this.seq = seq++;\n\n    _this.setMaxListeners(DefaultHighWaterMark);\n\n    _this.setOptions(newOptions);\n\n    if (newOptions.promiseRead) {\n      _this.type = \"Read\";\n      mkRead.call(_assertThisInitialized(_this), newOptions);\n\n      _this.tap();\n    } else if (newOptions.promiseWrite) {\n      _this.type = \"Write\";\n      mkWrite.call(_assertThisInitialized(_this), newOptions);\n    } else if (newOptions.transform || !newOptions.promiseTransform) {\n      _this.type = \"Transform-\";\n\n      _this.tap();\n    } else {\n      _this.type = \"Transform\";\n\n      if (newOptions.promiseTransform && mkTransform.call(_assertThisInitialized(_this), newOptions)) {\n        // returns true if transform can be pushed to referring stream\n        return _possibleConstructorReturn(_this, options.referrer.pushTransform(options));\n      }\n    }\n\n    var pluginConstructors = _this.constructor[plgctor].get();\n\n    if (pluginConstructors.length) {\n      var ret;\n      pluginConstructors.find(function (Ctor) {\n        return ret = Ctor.call(_assertThisInitialized(_this), options);\n      });\n\n      if (typeof ret !== \"undefined\") {\n        return _possibleConstructorReturn(_this, ret);\n      }\n    }\n\n    return _this;\n  }\n\n  _createClass(PromiseTransformStream, [{\n    key: \"name\",\n    get: function get() {\n      return \"\".concat(this.constructor.name, \"(\").concat(this._options.name || this.seq, \")\");\n    },\n    set: function set(name) {\n      this.setOptions({\n        name: name\n      });\n    }\n  }, {\n    key: \"constructed\",\n    get: function get() {\n      return this._scramjet_options.constructed;\n    }\n  }, {\n    key: \"_options\",\n    get: function get() {\n      if (this._scramjet_options.referrer && this._scramjet_options.referrer !== this) {\n        return Object.assign({\n          maxParallel: DefaultHighWaterMark\n        }, this._scramjet_options.referrer._options, this._scramjet_options);\n      }\n\n      return Object.assign({\n        maxParallel: DefaultHighWaterMark\n      }, this._scramjet_options);\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions() {\n      var _this2 = this;\n\n      for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {\n        options[_key] = arguments[_key];\n      }\n\n      Object.assign.apply(Object, [this._scramjet_options].concat(options));\n      if (this._scramjet_options.maxParallel) this.setMaxListeners(this._scramjet_options.maxParallel);\n\n      if (this._flushed) {\n        options.forEach(function (_ref) {\n          var promiseFlush = _ref.promiseFlush;\n          return Promise.resolve().then(promiseFlush).catch(function (e) {\n            return _this2.raise(e);\n          });\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setMaxListeners\",\n    value: function setMaxListeners(value) {\n      return _get(_getPrototypeOf(PromiseTransformStream.prototype), \"setMaxListeners\", this).call(this, value + EventEmitter.defaultMaxListeners);\n    }\n  }, {\n    key: \"whenRead\",\n    value: function () {\n      var _whenRead = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(count) {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", Promise.race([new Promise(function (res) {\n                  var read = function read() {\n                    var ret = _this3.read(count);\n\n                    if (ret !== null) {\n                      return res(ret);\n                    } else {\n                      _this3.once(\"readable\", read);\n                    }\n                  };\n\n                  read();\n                }), this.whenError(), this.whenEnd()]));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function whenRead(_x) {\n        return _whenRead.apply(this, arguments);\n      }\n\n      return whenRead;\n    }()\n  }, {\n    key: \"whenDrained\",\n    value: function () {\n      var _whenDrained = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this4 = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this._scramjet_drainPromise || (this._scramjet_drainPromise = new Promise(function (res, rej) {\n                  return _this4.once(\"drain\", function () {\n                    _this4._scramjet_drainPromise = null;\n                    res();\n                  }).whenError().then(rej);\n                })));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function whenDrained() {\n        return _whenDrained.apply(this, arguments);\n      }\n\n      return whenDrained;\n    }()\n  }, {\n    key: \"whenWrote\",\n    value: function () {\n      var _whenWrote = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var ret,\n            _len2,\n            data,\n            _key2,\n            _i,\n            _data,\n            item,\n            _args3 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                for (_len2 = _args3.length, data = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  data[_key2] = _args3[_key2];\n                }\n\n                for (_i = 0, _data = data; _i < _data.length; _i++) {\n                  item = _data[_i];\n                  ret = this.write(item);\n                }\n\n                if (!ret) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 6:\n                return _context3.abrupt(\"return\", this.whenDrained());\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function whenWrote() {\n        return _whenWrote.apply(this, arguments);\n      }\n\n      return whenWrote;\n    }()\n  }, {\n    key: \"whenError\",\n    value: function () {\n      var _whenError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this5 = this;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", this._scramjet_errPromise || (this._scramjet_errPromise = new Promise(function (res) {\n                  _this5.once(\"error\", function (e) {\n                    _this5._scramjet_errPromise = null;\n                    res(e);\n                  });\n                })));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function whenError() {\n        return _whenError.apply(this, arguments);\n      }\n\n      return whenError;\n    }()\n  }, {\n    key: \"whenEnd\",\n    value: function () {\n      var _whenEnd = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var _this6 = this;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this._scramjet_endPromise || (this._scramjet_endPromise = new Promise(function (res, rej) {\n                  _this6.whenError().then(rej);\n\n                  _this6.on(\"end\", function () {\n                    return res();\n                  });\n                })));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function whenEnd() {\n        return _whenEnd.apply(this, arguments);\n      }\n\n      return whenEnd;\n    }()\n  }, {\n    key: \"whenFinished\",\n    value: function () {\n      var _whenFinished = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _this7 = this;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", this._scramjet_finishPromise || (this._scramjet_finishPromise = new Promise(function (res, rej) {\n                  _this7.whenError().then(rej);\n\n                  _this7.on(\"finish\", function () {\n                    return res();\n                  });\n                })));\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function whenFinished() {\n        return _whenFinished.apply(this, arguments);\n      }\n\n      return whenFinished;\n    }()\n  }, {\n    key: \"catch\",\n    value: function _catch(callback) {\n      this._error_handlers.push(callback);\n\n      return this;\n    }\n  }, {\n    key: \"raise\",\n    value: function () {\n      var _raise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(err) {\n        var _this8 = this;\n\n        var _len3,\n            args,\n            _key3,\n            _args7 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                for (_len3 = _args7.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n                  args[_key3 - 1] = _args7[_key3];\n                }\n\n                return _context7.abrupt(\"return\", this._error_handlers.reduce(function (promise, handler) {\n                  return promise.catch(function (lastError) {\n                    return handler.apply(void 0, [lastError instanceof StreamError ? lastError : new StreamError(lastError, _this8, err.code, err.chunk)].concat(args));\n                  });\n                }, Promise.reject(err)).catch(function (err) {\n                  return _this8.emit.apply(_this8, [\"error\", err].concat(args));\n                }));\n\n              case 2:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function raise(_x2) {\n        return _raise.apply(this, arguments);\n      }\n\n      return raise;\n    }()\n  }, {\n    key: \"pipe\",\n    value: function pipe(to, options) {\n      if (to === this) {\n        return this;\n      }\n\n      if (this !== to && to instanceof PromiseTransformStream) {\n        to.setOptions({\n          referrer: this\n        });\n        this.on(\"error\", function (err) {\n          return to.raise(err);\n        });\n        this.tap().catch( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(err) {\n            var _len4,\n                args,\n                _key4,\n                _args8 = arguments;\n\n            return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n              while (1) {\n                switch (_context8.prev = _context8.next) {\n                  case 0:\n                    for (_len4 = _args8.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n                      args[_key4 - 1] = _args8[_key4];\n                    }\n\n                    _context8.next = 3;\n                    return to.raise.apply(to, [err].concat(args));\n\n                  case 3:\n                    return _context8.abrupt(\"return\", filter);\n\n                  case 4:\n                  case \"end\":\n                    return _context8.stop();\n                }\n              }\n            }, _callee8);\n          }));\n\n          return function (_x3) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n      } else if (to instanceof Readable) {\n        this.on(\"error\", function () {\n          for (var _len5 = arguments.length, err = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n            err[_key5] = arguments[_key5];\n          }\n\n          return to.emit.apply(to, [\"error\"].concat(err));\n        });\n      }\n\n      return _get(_getPrototypeOf(PromiseTransformStream.prototype), \"pipe\", this).call(this, to, options || {\n        end: true\n      });\n    }\n  }, {\n    key: \"graph\",\n    value: function graph(func) {\n      var referrer = this;\n      var ret = [];\n\n      while (referrer) {\n        ret.push(referrer);\n        referrer = referrer._options.referrer;\n      }\n\n      func(ret);\n      return this;\n    }\n  }, {\n    key: \"tap\",\n    value: function tap() {\n      this._tapped = true;\n      return this;\n    }\n  }, {\n    key: \"dropTransform\",\n    value: function dropTransform(transform) {\n      if (!this._scramjet_options.transforms) {\n        if (!this._transform.currentTransform) return this;\n        this._transform = this._transform.currentTransform;\n        return this;\n      }\n\n      var i = 0;\n\n      while (i++ < 1000) {\n        var x = this._scramjet_options.transforms.findIndex(function (t) {\n          return t.ref === transform;\n        });\n\n        if (x > -1) {\n          this._scramjet_options.transforms.splice(x, 1);\n        } else {\n          return this;\n        }\n      }\n\n      throw new Error(\"Maximum remove attempt count reached!\");\n    }\n  }, {\n    key: \"pushTransform\",\n    value: function pushTransform(options) {\n      var _this9 = this;\n\n      if (typeof options.promiseTransform === \"function\") {\n        if (!this._scramjet_options.transforms) {\n          this._pushedTransform = options.promiseTransform;\n          return this;\n        }\n\n        var markTransform = function markTransform(bound) {\n          bound.ref = options.promiseTransform;\n          return bound;\n        };\n\n        var before = typeof options.beforeTransform === \"function\";\n        var after = typeof options.afterTransform === \"function\";\n        if (before) this._scramjet_options.transforms.push(markTransform(options.beforeTransform.bind(this)));\n        if (after) this._scramjet_options.transforms.push(markTransform( /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(chunk) {\n            return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n              while (1) {\n                switch (_context9.prev = _context9.next) {\n                  case 0:\n                    _context9.t0 = options.afterTransform;\n                    _context9.t1 = _this9;\n                    _context9.t2 = chunk;\n                    _context9.next = 5;\n                    return options.promiseTransform.call(_this9, chunk);\n\n                  case 5:\n                    _context9.t3 = _context9.sent;\n                    return _context9.abrupt(\"return\", _context9.t0.call.call(_context9.t0, _context9.t1, _context9.t2, _context9.t3));\n\n                  case 7:\n                  case \"end\":\n                    return _context9.stop();\n                }\n              }\n            }, _callee9);\n          }));\n\n          return function (_x4) {\n            return _ref3.apply(this, arguments);\n          };\n        }()));else this._scramjet_options.transforms.push(markTransform(options.promiseTransform.bind(this)));\n      }\n\n      if (typeof options.promiseFlush === \"function\") {\n        if (this._scramjet_options.runFlush) {\n          throw new Error(\"Promised Flush cannot be overwritten!\");\n        } else {\n          this._scramjet_options.runFlush = options.promiseFlush;\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_selfInstance\",\n    value: function _selfInstance() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      return _construct(this.constructor, args);\n    }\n  }, {\n    key: \"_transform\",\n    value: function () {\n      var _transform2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(chunk, encoding, callback) {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (this._delayed_first) {\n                  _context10.next = 4;\n                  break;\n                }\n\n                _context10.next = 3;\n                return new Promise(function (res) {\n                  return res();\n                });\n\n              case 3:\n                this._delayed_first = 1;\n\n              case 4:\n                _context10.prev = 4;\n\n                if (!this._pushedTransform) {\n                  _context10.next = 9;\n                  break;\n                }\n\n                _context10.next = 8;\n                return this._pushedTransform(chunk);\n\n              case 8:\n                chunk = _context10.sent;\n\n              case 9:\n                callback(null, chunk);\n                _context10.next = 15;\n                break;\n\n              case 12:\n                _context10.prev = 12;\n                _context10.t0 = _context10[\"catch\"](4);\n                callback(_context10.t0);\n\n              case 15:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[4, 12]]);\n      }));\n\n      function _transform(_x5, _x6, _x7) {\n        return _transform2.apply(this, arguments);\n      }\n\n      return _transform;\n    }()\n  }, {\n    key: \"_flush\",\n    value: function _flush(callback) {\n      var _this10 = this;\n\n      var last = Promise.resolve();\n\n      if (this._scramjet_options.runFlush) {\n        last.then(this._scramjet_options.runFlush).then(function (data) {\n          if (Array.isArray(data)) data.forEach(function (item) {\n            return _this10.push(item);\n          });else if (data) _this10.push(data);\n          callback();\n        }, function (e) {\n          return _this10.raise(e);\n        });\n      } else {\n        last.then(function () {\n          return callback();\n        });\n      }\n    }\n  }], [{\n    key: plgctor,\n    get: function get() {\n      var _this11 = this;\n\n      var proto = Object.getPrototypeOf(this);\n      return {\n        ctors: this[storector] = Object.prototype.hasOwnProperty.call(this, storector) ? this[storector] : [],\n        get: function get() {\n          return proto[plgctor] ? proto[plgctor].get().concat(_this11[storector]) : _this11[storector];\n        }\n      };\n    }\n  }, {\n    key: \"filter\",\n    get: function get() {\n      return filter;\n    }\n  }]);\n\n  return PromiseTransformStream;\n}(Transform);\n\nmodule.exports = {\n  plgctor: plgctor,\n  PromiseTransformStream: PromiseTransformStream\n};","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/client/node_modules/scramjet-core/lib/util/promise-transform-stream.js"],"names":["require","Transform","Readable","EventEmitter","DefaultHighWaterMark","cpus","length","filter","Symbol","plgctor","storector","seq","shared","mkTransform","mkRead","mkWrite","StreamError","rename","ob","fr","to","checkOptions","options","reduce","acc","key","Error","PromiseTransformStream","newOptions","Object","assign","objectMode","promiseRead","promiseWrite","promiseTransform","promiseFlush","beforeTransform","afterTransform","_tapped","_error_handlers","_scramjet_options","referrer","constructed","stack","setMaxListeners","setOptions","type","call","tap","transform","pushTransform","pluginConstructors","constructor","get","ret","find","Ctor","name","_options","maxParallel","_flushed","forEach","Promise","resolve","then","catch","e","raise","value","defaultMaxListeners","count","race","res","read","once","whenError","whenEnd","_scramjet_drainPromise","rej","data","item","write","whenDrained","_scramjet_errPromise","_scramjet_endPromise","on","_scramjet_finishPromise","callback","push","err","args","promise","handler","lastError","code","chunk","reject","emit","end","func","transforms","_transform","currentTransform","i","x","findIndex","t","ref","splice","_pushedTransform","markTransform","bound","before","after","bind","runFlush","encoding","_delayed_first","last","Array","isArray","proto","getPrototypeOf","ctors","prototype","hasOwnProperty","concat","module","exports"],"mappings":"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","sourcesContent":["const {Transform, Readable} = require(\"stream\");\nconst {EventEmitter} = require(\"events\");\nconst DefaultHighWaterMark = require(\"os\").cpus().length * 2;\n\nconst filter = Symbol(\"FILTER\");\nconst plgctor = Symbol(\"plgctor\");\nconst storector = Symbol(\"storector\");\n\nlet seq = 0;\n\nconst shared = { filter, DefaultHighWaterMark, plgctor, storector };\nconst mkTransform = require(\"./mk-transform\")(shared);\nconst mkRead = require(\"./mk-read\")(shared);\nconst mkWrite = require(\"./mk-write\")(shared);\nconst {StreamError} = require(\"./stream-errors\");\n\nconst rename = (ob, fr, to) => {\n    if (ob[fr]) {\n        ob[to] = ob[fr];\n        delete ob[fr];\n    }\n};\n\nconst checkOptions = (options) => {\n    rename(options, \"parallelRead\", \"promiseRead\");\n    rename(options, \"parallelWrite\", \"promiseWrite\");\n    rename(options, \"parallelTransform\", \"promiseTransform\");\n    rename(options, \"flushPromise\", \"promiseFlush\");\n\n    if ([\"promiseRead\", \"promiseWrite\", \"promiseTransform\"].reduce((acc, key) => acc += (options[key] ? 1 : 0), 0) > 1)\n        throw new Error(\"Scramjet stream can be either Read, Write or Transform\");\n};\n\n/**\n * This class is an underlying class for all Scramjet streams.\n *\n * It allows creation of simple transform streams that use async functions for transforms, reading or writing.\n *\n * @internal\n * @extends stream.PassThrough\n */\nclass PromiseTransformStream extends Transform {\n\n    constructor(options) {\n        options = options || {};\n        const newOptions = Object.assign({\n            objectMode: true,\n            promiseRead: null,\n            promiseWrite: null,\n            promiseTransform: null,\n            promiseFlush: null,\n            beforeTransform: null,\n            afterTransform: null\n        }, options);\n\n        checkOptions(newOptions);\n\n        super(newOptions);\n\n        this._tapped = false;\n\n        this._error_handlers = [];\n        this._scramjet_options = {\n            referrer: options.referrer,\n            constructed: (new Error().stack)\n        };\n\n        this.seq = seq++;\n\n        this.setMaxListeners(DefaultHighWaterMark);\n        this.setOptions(newOptions);\n\n        if (newOptions.promiseRead) {\n            this.type = \"Read\";\n            mkRead.call(this, newOptions);\n            this.tap();\n        } else if (newOptions.promiseWrite) {\n            this.type = \"Write\";\n            mkWrite.call(this, newOptions);\n        } else if (newOptions.transform || !newOptions.promiseTransform) {\n            this.type = \"Transform-\";\n            this.tap();\n        } else {\n            this.type = \"Transform\";\n            if (newOptions.promiseTransform && mkTransform.call(this, newOptions)) { // returns true if transform can be pushed to referring stream\n                return options.referrer.pushTransform(options);\n            }\n        }\n\n        const pluginConstructors = this.constructor[plgctor].get();\n        if (pluginConstructors.length) {\n\n            let ret;\n            pluginConstructors.find(\n                (Ctor) => ret = Ctor.call(this, options)\n            );\n\n            if (typeof ret !== \"undefined\") {\n                return ret;\n            }\n        }\n    }\n\n    get name() {\n        return `${this.constructor.name}(${this._options.name || this.seq})`;\n    }\n\n    set name(name) {\n        this.setOptions({name});\n    }\n\n    get constructed() {\n        return this._scramjet_options.constructed;\n    }\n\n    get _options() {\n        if (this._scramjet_options.referrer && this._scramjet_options.referrer !== this) {\n            return Object.assign({maxParallel: DefaultHighWaterMark}, this._scramjet_options.referrer._options, this._scramjet_options);\n        }\n        return Object.assign({maxParallel: DefaultHighWaterMark}, this._scramjet_options);\n    }\n\n    setOptions(...options) {\n        Object.assign(this._scramjet_options, ...options);\n\n        if (this._scramjet_options.maxParallel)\n            this.setMaxListeners(this._scramjet_options.maxParallel);\n\n        if (this._flushed) {\n            options.forEach(\n                ({promiseFlush}) => Promise\n                    .resolve()\n                    .then(promiseFlush)\n                    .catch(e => this.raise(e))\n            );\n        }\n\n        return this;\n    }\n\n    setMaxListeners(value) {\n        return super.setMaxListeners.call(this, value + EventEmitter.defaultMaxListeners);\n    }\n\n    static get [plgctor]() {\n        const proto = Object.getPrototypeOf(this);\n        return {\n            ctors: this[storector] = Object.prototype.hasOwnProperty.call(this, storector) ? this[storector] : [],\n            get: () => proto[plgctor] ? proto[plgctor].get().concat(this[storector]) : this[storector]\n        };\n    }\n\n    async whenRead(count) {\n        return Promise.race([\n            new Promise((res) => {\n\n                const read = () => {\n                    const ret = this.read(count);\n                    if (ret !== null) {\n                        return res(ret);\n                    } else {\n                        this.once(\"readable\", read);\n                    }\n                };\n                read();\n            }),\n            this.whenError(),\n            this.whenEnd()\n        ]);\n    }\n\n    async whenDrained() {\n        return this._scramjet_drainPromise || (this._scramjet_drainPromise = new Promise(\n            (res, rej) => this\n                .once(\"drain\", () => {\n                    this._scramjet_drainPromise = null;\n                    res();\n                })\n                .whenError().then(rej)\n        ));\n    }\n\n    async whenWrote(...data) {\n        let ret;\n        for (var item of data)\n            ret = this.write(item);\n\n        if (ret) {\n            return;\n        } else {\n            return this.whenDrained();\n        }\n    }\n\n    async whenError() {\n        return this._scramjet_errPromise || (this._scramjet_errPromise = new Promise((res) => {\n            this.once(\"error\", (e) => {\n                this._scramjet_errPromise = null;\n                res(e);\n            });\n        }));\n    }\n\n    async whenEnd() {\n        return this._scramjet_endPromise || (this._scramjet_endPromise = new Promise((res, rej) => {\n            this.whenError().then(rej);\n            this.on(\"end\", () => res());\n        }));\n    }\n\n    async whenFinished() {\n        return this._scramjet_finishPromise || (this._scramjet_finishPromise = new Promise((res, rej) => {\n            this.whenError().then(rej);\n            this.on(\"finish\", () => res());\n        }));\n    }\n\n    catch(callback) {\n        this._error_handlers.push(callback);\n        return this;\n    }\n\n    async raise(err, ...args) {\n        return this._error_handlers\n            .reduce(\n                (promise, handler) => promise.catch(\n                    (lastError) => handler(\n                        lastError instanceof StreamError\n                            ? lastError\n                            : new StreamError(lastError, this, err.code, err.chunk),\n                        ...args\n                    )\n                ),\n                Promise.reject(err)\n            )\n            .catch(\n                (err) => this.emit(\"error\", err, ...args)\n            );\n    }\n\n    pipe(to, options) {\n        if (to === this) {\n            return this;\n        }\n\n        if (this !== to && to instanceof PromiseTransformStream) {\n            to.setOptions({referrer: this});\n            this.on(\"error\", err => to.raise(err));\n            this.tap().catch(async (err, ...args) => {\n                await to.raise(err, ...args);\n                return filter;\n            });\n        } else if (to instanceof Readable) {\n            this.on(\"error\", (...err) => to.emit(\"error\", ...err));\n        }\n\n        return super.pipe(to, options || {end: true});\n    }\n\n    graph(func) {\n        let referrer = this;\n        const ret = [];\n        while(referrer) {\n            ret.push(referrer);\n            referrer = referrer._options.referrer;\n        }\n        func(ret);\n        return this;\n    }\n\n    tap() {\n        this._tapped = true;\n        return this;\n    }\n\n    dropTransform(transform) {\n        if (!this._scramjet_options.transforms) {\n            if (!this._transform.currentTransform)\n                return this;\n\n            this._transform = this._transform.currentTransform;\n            return this;\n        }\n        let i = 0;\n        while (i++ < 1000) {\n            const x = this._scramjet_options.transforms.findIndex(t => t.ref === transform);\n            if (x > -1) {\n                this._scramjet_options.transforms.splice(x, 1);\n            } else {\n                return this;\n            }\n        }\n        throw new Error(\"Maximum remove attempt count reached!\");\n    }\n\n    pushTransform(options) {\n\n        if (typeof options.promiseTransform === \"function\") {\n            if (!this._scramjet_options.transforms) {\n                this._pushedTransform = options.promiseTransform;\n                return this;\n            }\n\n            const markTransform = (bound) => {\n                bound.ref = options.promiseTransform;\n                return bound;\n            };\n\n            const before = typeof options.beforeTransform === \"function\";\n            const after = typeof options.afterTransform === \"function\";\n\n            if (before)\n                this._scramjet_options.transforms.push(markTransform(\n                    options.beforeTransform.bind(this)\n                ));\n\n            if (after)\n                this._scramjet_options.transforms.push(markTransform(\n                    async (chunk) => options.afterTransform.call(\n                        this,\n                        chunk,\n                        await options.promiseTransform.call(this, chunk)\n                    )\n                ));\n            else\n                this._scramjet_options.transforms.push(markTransform(\n                    options.promiseTransform.bind(this)\n                ));\n\n        }\n\n        if (typeof options.promiseFlush === \"function\") {\n            if (this._scramjet_options.runFlush) {\n                throw new Error(\"Promised Flush cannot be overwritten!\");\n            } else {\n                this._scramjet_options.runFlush = options.promiseFlush;\n            }\n        }\n\n        return this;\n    }\n\n    _selfInstance(...args) {\n        return new this.constructor(...args);\n    }\n\n    async _transform(chunk, encoding, callback) {\n        if (!this._delayed_first) {\n            await new Promise(res => res());\n            this._delayed_first = 1;\n        }\n\n        try {\n            if (this._pushedTransform)\n                chunk = await this._pushedTransform(chunk);\n            callback(null, chunk);\n        } catch(err) {\n            callback(err);\n        }\n    }\n\n    _flush(callback) {\n        const last = Promise.resolve();\n\n        if (this._scramjet_options.runFlush) {\n            last\n                .then(this._scramjet_options.runFlush)\n                .then(\n                    (data) => {\n                        if (Array.isArray(data))\n                            data.forEach(item => this.push(item));\n                        else if (data)\n                            this.push(data);\n\n                        callback();\n                    },\n                    e => this.raise(e)\n                );\n        } else {\n            last.then(() => callback());\n        }\n    }\n\n    static get filter() { return filter; }\n}\n\nmodule.exports = {\n    plgctor: plgctor,\n    PromiseTransformStream\n};\n"]},"metadata":{},"sourceType":"script"}