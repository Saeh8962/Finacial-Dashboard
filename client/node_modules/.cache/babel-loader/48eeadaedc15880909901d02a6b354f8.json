{"ast":null,"code":"var _slicedToArray = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar scramjet = require(\"./\");\n\nvar os = require(\"os\");\n\nmodule.exports = {\n  /**\n   * Re-routes streams to a new MultiStream of specified size\n   *\n   * @meta.noreadme\n   * @memberof module:scramjet.MultiStream#\n   * @todo NYT: not yet tested\n   * @todo NYD: not yet documented\n   * @param  {Function} [policy=Affinity.RoundRobin] [description]\n   * @param  {number} [count=os.cpus().length]       [description]\n   * @return {MultiStream}                             [description]\n   */\n  route: function route(policy) {\n    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : os.cpus().length;\n    var affine = policy(null, count);\n    return this.mux().separate( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(item) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return affine(item);\n\n              case 2:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  },\n\n  /**\n   * Map stream synchronously\n   *\n   * @chainable\n   * @memberof module:scramjet.MultiStream#\n   * @param  {Function} transform mapping function ran on every stream (SYNCHRONOUS!)\n   */\n  smap: function smap(transform) {\n    var out = new this.constructor(this.streams.map(transform));\n    this.each(function (stream) {\n      return out.add(transform(stream));\n    }, function (stream) {\n      return out.remove(transform(stream));\n    });\n    return out;\n  },\n\n  /**\n   * Distribute options\n   *\n   * @typedef {object} DistributeOptions\n   * @memberof module:scramjet~\n   * @prop {Array} [plugins=[]] a list of scramjet plugins to load (if omitted, will use just the ones in scramjet itself)\n   * @prop {string} [StreamClass=DataStream] the class to deserialize the stream to.\n   * @prop {number} [threads=os.cpus().length * 2] maximum threads to use - defaults to number of processor threads in os, but it may be sensible to go over this value if you'd intend to run synchronous code.\n   * @prop {DataStreamOptions} [createOptions={}] maximum threads to use - defaults to number of processor threads in os, but it may be sensible to go over this value if you'd intend to run synchronous code.\n   * @prop {StreamWorker} [StreamWorker=scramjet.StreamWorker] worker implementation.\n   */\n\n  /**\n   * Distributes processing to multiple forked subprocesses.\n   *\n   * @chainable\n   * @memberof module:scramjet.MultiStream#\n   * @param {Function|string} clusterFunc a cluster callback with all operations working similarly to DataStream::use\n   * @param {DistributeOptions} [options={}]\n   */\n  cluster: function cluster(clusterFunc) {\n    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref2$plugins = _ref2.plugins,\n        plugins = _ref2$plugins === void 0 ? [] : _ref2$plugins,\n        _ref2$threads = _ref2.threads,\n        threads = _ref2$threads === void 0 ? os.cpus().length * 2 : _ref2$threads,\n        _ref2$StreamClass = _ref2.StreamClass,\n        StreamClass = _ref2$StreamClass === void 0 ? scramjet.DataStream : _ref2$StreamClass,\n        _ref2$createOptions = _ref2.createOptions,\n        createOptions = _ref2$createOptions === void 0 ? {} : _ref2$createOptions,\n        _ref2$StreamWorker = _ref2.StreamWorker,\n        StreamWorker = _ref2$StreamWorker === void 0 ? scramjet.StreamWorker : _ref2$StreamWorker;\n\n    var out = new this.constructor();\n    StreamWorker.fork(threads);\n    this.each(function (stream) {\n      return StreamWorker.fork(threads).then(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n            worker = _ref4[0];\n\n        return out.add(worker.delegate(stream, clusterFunc, plugins).pipe(new StreamClass(createOptions)));\n      });\n    });\n    return out;\n  }\n};","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/client/node_modules/scramjet/lib/multi-stream.js"],"names":["scramjet","require","os","module","exports","route","policy","count","cpus","length","affine","mux","separate","item","smap","transform","out","constructor","streams","map","each","stream","add","remove","cluster","clusterFunc","plugins","threads","StreamClass","DataStream","createOptions","StreamWorker","fork","then","worker","delegate","pipe"],"mappings":";;;;;;AAAA,IAAMA,QAAQ,GAAGC,OAAO,CAAC,IAAD,CAAxB;;AACA,IAAMC,EAAE,GAAGD,OAAO,CAAC,IAAD,CAAlB;;AAEAE,MAAM,CAACC,OAAP,GAAiB;AACb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,KAZa,iBAYPC,MAZO,EAY2B;AAAA,QAA1BC,KAA0B,uEAAlBL,EAAE,CAACM,IAAH,GAAUC,MAAQ;AACpC,QAAMC,MAAM,GAAGJ,MAAM,CAAC,IAAD,EAAOC,KAAP,CAArB;AACA,WAAO,KAAKI,GAAL,GAAWC,QAAX;AAAA,0EACH,iBAAOC,IAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAsBH,MAAM,CAACG,IAAD,CAA5B;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OADG;;AAAA;AAAA;AAAA;AAAA,QAAP;AAGH,GAjBY;;AAmBb;AACJ;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,IA1Ba,gBA0BRC,SA1BQ,EA0BG;AACZ,QAAMC,GAAG,GAAG,IAAI,KAAKC,WAAT,CAAqB,KAAKC,OAAL,CAAaC,GAAb,CAAiBJ,SAAjB,CAArB,CAAZ;AACA,SAAKK,IAAL,CACI,UAACC,MAAD;AAAA,aAAYL,GAAG,CAACM,GAAJ,CAAQP,SAAS,CAACM,MAAD,CAAjB,CAAZ;AAAA,KADJ,EAEI,UAACA,MAAD;AAAA,aAAYL,GAAG,CAACO,MAAJ,CAAWR,SAAS,CAACM,MAAD,CAApB,CAAZ;AAAA,KAFJ;AAIA,WAAOL,GAAP;AACH,GAjCY;;AAmCb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACIQ,EAAAA,OAvDa,mBAuDLC,WAvDK,EAuD0J;AAAA,oFAAJ,EAAI;AAAA,8BAAjJC,OAAiJ;AAAA,QAAjJA,OAAiJ,8BAAvI,EAAuI;AAAA,8BAAnIC,OAAmI;AAAA,QAAnIA,OAAmI,8BAAzHzB,EAAE,CAACM,IAAH,GAAUC,MAAV,GAAmB,CAAsG;AAAA,kCAAnGmB,WAAmG;AAAA,QAAnGA,WAAmG,kCAArF5B,QAAQ,CAAC6B,UAA4E;AAAA,oCAAhEC,aAAgE;AAAA,QAAhEA,aAAgE,oCAAhD,EAAgD;AAAA,mCAA5CC,YAA4C;AAAA,QAA5CA,YAA4C,mCAA7B/B,QAAQ,CAAC+B,YAAoB;;AACnK,QAAMf,GAAG,GAAG,IAAI,KAAKC,WAAT,EAAZ;AAEAc,IAAAA,YAAY,CAACC,IAAb,CAAkBL,OAAlB;AAEA,SAAKP,IAAL,CACI,UAACC,MAAD;AAAA,aAAYU,YAAY,CACnBC,IADO,CACFL,OADE,EAEPM,IAFO,CAGJ;AAAA;AAAA,YAAEC,MAAF;;AAAA,eAAclB,GAAG,CAACM,GAAJ,CAAQY,MAAM,CAACC,QAAP,CAAgBd,MAAhB,EAAwBI,WAAxB,EAAqCC,OAArC,EAA8CU,IAA9C,CAAmD,IAAIR,WAAJ,CAAgBE,aAAhB,CAAnD,CAAR,CAAd;AAAA,OAHI,CAAZ;AAAA,KADJ;AAQA,WAAOd,GAAP;AACH;AArEY,CAAjB","sourcesContent":["const scramjet = require(\"./\");\nconst os = require(\"os\");\n\nmodule.exports = {\n    /**\n     * Re-routes streams to a new MultiStream of specified size\n     *\n     * @meta.noreadme\n     * @memberof module:scramjet.MultiStream#\n     * @todo NYT: not yet tested\n     * @todo NYD: not yet documented\n     * @param  {Function} [policy=Affinity.RoundRobin] [description]\n     * @param  {number} [count=os.cpus().length]       [description]\n     * @return {MultiStream}                             [description]\n     */\n    route(policy, count = os.cpus().length) {\n        const affine = policy(null, count);\n        return this.mux().separate(\n            async (item) => await affine(item)\n        );\n    },\n\n    /**\n     * Map stream synchronously\n     *\n     * @chainable\n     * @memberof module:scramjet.MultiStream#\n     * @param  {Function} transform mapping function ran on every stream (SYNCHRONOUS!)\n     */\n    smap(transform) {\n        const out = new this.constructor(this.streams.map(transform));\n        this.each(\n            (stream) => out.add(transform(stream)),\n            (stream) => out.remove(transform(stream))\n        );\n        return out;\n    },\n\n    /**\n     * Distribute options\n     *\n     * @typedef {object} DistributeOptions\n     * @memberof module:scramjet~\n     * @prop {Array} [plugins=[]] a list of scramjet plugins to load (if omitted, will use just the ones in scramjet itself)\n     * @prop {string} [StreamClass=DataStream] the class to deserialize the stream to.\n     * @prop {number} [threads=os.cpus().length * 2] maximum threads to use - defaults to number of processor threads in os, but it may be sensible to go over this value if you'd intend to run synchronous code.\n     * @prop {DataStreamOptions} [createOptions={}] maximum threads to use - defaults to number of processor threads in os, but it may be sensible to go over this value if you'd intend to run synchronous code.\n     * @prop {StreamWorker} [StreamWorker=scramjet.StreamWorker] worker implementation.\n     */\n\n    /**\n     * Distributes processing to multiple forked subprocesses.\n     *\n     * @chainable\n     * @memberof module:scramjet.MultiStream#\n     * @param {Function|string} clusterFunc a cluster callback with all operations working similarly to DataStream::use\n     * @param {DistributeOptions} [options={}]\n     */\n    cluster(clusterFunc, {plugins = [], threads = os.cpus().length * 2, StreamClass = scramjet.DataStream, createOptions = {}, StreamWorker = scramjet.StreamWorker} = {}) {\n        const out = new this.constructor();\n\n        StreamWorker.fork(threads);\n\n        this.each(\n            (stream) => StreamWorker\n                .fork(threads)\n                .then(\n                    ([worker]) => out.add(worker.delegate(stream, clusterFunc, plugins).pipe(new StreamClass(createOptions)))\n                )\n        );\n\n        return out;\n    },\n\n};\n"]},"metadata":{},"sourceType":"script"}