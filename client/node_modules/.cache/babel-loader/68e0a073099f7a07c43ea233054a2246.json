{"ast":null,"code":"/** @ignore */\nvar _require = require(\"./util/promise-transform-stream\"),\n    plgctor = _require.plgctor;\n/**\n * Scramjet main exports expose all the stream classes and a number of methods.\n *\n * All scramjet streams allow writing, reading or transform modes - currently\n * exclusively (meaning you can't have two at once). Any of the scramjet streams\n * can be constructed with the following options passed to mimic node.js standard streams:\n *\n * * `async promiseTransform(chunk)` - transform method that resolves with a single output chunk\n * * `async promiseWrite(chunk)` - write method that that resolves when chunk is written\n * * `async promiseRead(count)` - read method that resolves with an array of chunks when called\n *\n * See {@link https://nodejs.org/api/stream.html#stream_api_for_stream_implementers node.js API for stream implementers for details}\n *\n * The object exposes the following classes:\n *\n * * `DataStream` {@see DataStream} - the basic object stream of any type\n * * `StringStream` {@see StringStream} - a stream of strings\n * * `BufferStream` {@see BufferStream} - a stream of buffers\n * * `MultiStream` {@see MultiStream} - a group of streams\n * * `NumberStream` {@see NumberStream} - a stream of numbers\n * * `WindowStream` {@see WindowStream} - a stream of windows of objects\n *\n * The general concept of Scramjet streams is facilitating node's TransformStream mechanism so that you don't need\n * to create a number of streams and create the pipeline, but use the concept of chaining instead. When you call `parse`\n * method for instance, scramjet creates a new stream, pipes it to the callee and forwards errors.\n *\n * What's worth mentioning - scramjet tries to limit the number of created transform streams and pushes the transforms\n * one after another into the same stream class therefore a code `stream.map(transform1).map(transform2).filter(transform3)`\n * will only operate on a single transform stream that evaluates all three transforms one after another.\n *\n * @exports scramjet\n * @module scramjet\n */\n\n\nmodule.exports = {\n  /**\n   * Creates a DataStream that's piped from the passed readable.\n   *\n   * @memberof module:scramjet\n   * @param {Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|string|Readable} input argument to be turned into new stream\n   * @param {DataStreamOptions|Writable} [options={}] options for creation of a new stream or the target stream\n   * @param {any[]} ...args additional arguments for the stream - will be passed to the function or generator\n   * @return {DataStream}\n   */\n  from: function from() {\n    var _this$DataStream;\n\n    return (_this$DataStream = this.DataStream).from.apply(_this$DataStream, arguments);\n  },\n\n  /**\n   * Creates a DataStream from an Array\n   *\n   * @memberof module:scramjet\n   * @param  {Array} array list of chunks\n   * @param {DataStreamOptions} [options={}] the read stream options\n   * @return {DataStream}\n   */\n  fromArray: function fromArray() {\n    var _this$DataStream2;\n\n    return (_this$DataStream2 = this.DataStream).fromArray.apply(_this$DataStream2, arguments);\n  },\n\n  get ScramjetOptions() {\n    return require(\"./util/options\");\n  },\n\n  /**\n   * Creates a safe wrapper for scramjet transform module. See [Modules documentation](modules.md) for more info.\n   *\n   * @param {UseCallback} transform\n   * @param {CreateModuleOptions} [options={}]\n   * @param  {any[]} ...initialArgs\n   * @return {Function} a scramjet module function\n   */\n  createTransformModule: function createTransformModule(transform) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$StreamClass = _ref.StreamClass,\n        StreamClass = _ref$StreamClass === void 0 ? module.exports.DataStream : _ref$StreamClass;\n\n    for (var _len = arguments.length, initialArgs = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      initialArgs[_key - 2] = arguments[_key];\n    }\n\n    return function (stream) {\n      var _StreamClass$from;\n\n      for (var _len2 = arguments.length, extraArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        extraArgs[_key2 - 1] = arguments[_key2];\n      }\n\n      return (_StreamClass$from = StreamClass.from(stream)).use.apply(_StreamClass$from, [transform].concat(initialArgs, extraArgs));\n    };\n  },\n\n  /**\n   * Creates a safe wrapper for scramjet read module. See [Modules documentation](modules.md) for more info.\n   *\n   * @param {Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|string|Readable} anything\n   * @param {CreateModuleOptions} [options={}]\n   * @param  {any[]} ...initialArgs\n   * @return {Function} a scramjet module function\n   */\n  createReadModule: function createReadModule(anything) {\n    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref2$StreamClass = _ref2.StreamClass,\n        StreamClass = _ref2$StreamClass === void 0 ? module.exports.DataStream : _ref2$StreamClass;\n\n    for (var _len3 = arguments.length, initialArgs = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      initialArgs[_key3 - 2] = arguments[_key3];\n    }\n\n    StreamClass = StreamClass || this.DataStream;\n    return function () {\n      var _StreamClass;\n\n      for (var _len4 = arguments.length, extraArgs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        extraArgs[_key4] = arguments[_key4];\n      }\n\n      return (_StreamClass = StreamClass).from.apply(_StreamClass, [anything].concat(initialArgs, extraArgs));\n    };\n  },\n\n  /**\n   * Options for createModule\n   *\n   * @typedef {object} CreateModuleOptions\n   * @memberof module:scramjet~\n   * @prop {DataStream} StreamClass defines what class should the module assume\n   */\n  get errors() {\n    return require(\"./util/stream-errors\");\n  },\n\n  /**\n   * @ignore\n   * @see {@link buffer-stream.md}\n   */\n  get BufferStream() {\n    return require(\"./buffer-stream\");\n  },\n\n  /**\n   * @ignore\n   * @see {@link data-stream.md}\n   */\n  get DataStream() {\n    return require(\"./data-stream\");\n  },\n\n  /**\n   * @ignore\n   * @see {@link multi-stream.md}\n   */\n  get MultiStream() {\n    return require(\"./multi-stream\");\n  },\n\n  /**\n   * @ignore\n   * @see {@link string-stream.md}\n   */\n  get StringStream() {\n    return require(\"./string-stream\");\n  },\n\n  /**\n   * Provides a lazy-load accessor to PromiseTransformStream - the base class of scramjet streams\n   *\n   * @ignore\n   */\n  get PromiseTransformStream() {\n    return require(\"./util/promise-transform-stream\").PromiseTransformStream;\n  },\n\n  /**\n   * Definition of a single mixin for a specific Scramjet class. Should contain any number of stream methods.\n   *\n   * @typedef {object} StreamMixin\n   * @memberof module:scramjet~\n   * @property {Function} constructor optional constructor that will be called in the stream constructor (this has to be an own property!)\n   */\n\n  /**\n   * Definition of a plugin in Scramjet\n   *\n   * @typedef {object} ScramjetPlugin\n   * @memberof module:scramjet~\n   * @internal\n   * @property {StreamMixin} BufferStream definition of constructor and properties for the BufferStream prototype.\n   * @property {StreamMixin} DataStream definition of constructor and properties for the DataStream prototype.\n   * @property {StreamMixin} MultiStream definition of constructor and properties for the MultiStream prototype.\n   * @property {StreamMixin} StringStream definition of constructor and properties for the StringStream prototype.\n   */\n\n  /**\n   * Plugs in methods for any of the classes\n   *\n   * @static\n   * @memberof module:scramjet\n   * @param  {ScramjetPlugin} mixin the plugin object\n   * @return {ScramjetPlugin}\n   *\n   * @test test/methods/scramjet-plugin.js\n   */\n  plugin: function plugin(mixins) {\n    var _this = this;\n\n    for (var _i = 0, _Object$keys = Object.keys(mixins); _i < _Object$keys.length; _i++) {\n      var key = _Object$keys[_i];\n\n      if (key in this) {\n        (function () {\n          var Mixin = mixins[key];\n          var Stream = _this[key];\n\n          if (Object.prototype.hasOwnProperty.call(Mixin, \"constructor\") && Stream[plgctor]) {\n            Stream[plgctor].ctors.push(Mixin.constructor);\n            delete Mixin.constructor;\n          }\n\n          Object.getOwnPropertyNames(Mixin).forEach(function (prop) {\n            return Object.defineProperty(Stream.prototype, prop, Object.getOwnPropertyDescriptor(Mixin, prop));\n          });\n        })();\n      } else {\n        this[key] = mixins[key];\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Gets an API version (this may be important for future use)\n   *\n   * @static\n   * @memberof module:scramjet\n   * @param {number} version The required version (currently only: 1)\n   * @return {ScramjetPlugin}\n   */\n  API: function API(version) {\n    if (version === 1) {\n      return module.exports;\n    }\n  }\n}; // ----- Externals documentation -----\n\n/**\n * Asynchronous Generator.\n *\n * @ignore\n * @external AsyncGeneratorFunction\n * @see https://github.com/tc39/proposal-async-iteration#async-generator-functions\n */\n\n/**\n * Generator function (`function* ()`).\n *\n * @ignore\n * @external GeneratorFunction\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction\n */\n\n/**\n * Simple Node.js Passthrough stream.\n *\n * @ignore\n * @external stream.PassThrough\n * @see https://nodejs.org/api/stream.html#stream_class_stream_passthrough\n */","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/client/node_modules/scramjet-core/lib/index.js"],"names":["require","plgctor","module","exports","from","DataStream","fromArray","ScramjetOptions","createTransformModule","transform","StreamClass","initialArgs","stream","extraArgs","use","createReadModule","anything","errors","BufferStream","MultiStream","StringStream","PromiseTransformStream","plugin","mixins","Object","keys","key","Mixin","Stream","prototype","hasOwnProperty","call","ctors","push","constructor","getOwnPropertyNames","forEach","prop","defineProperty","getOwnPropertyDescriptor","API","version"],"mappings":"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","sourcesContent":["/** @ignore */\nconst {plgctor} = require(\"./util/promise-transform-stream\");\n\n/**\n * Scramjet main exports expose all the stream classes and a number of methods.\n *\n * All scramjet streams allow writing, reading or transform modes - currently\n * exclusively (meaning you can't have two at once). Any of the scramjet streams\n * can be constructed with the following options passed to mimic node.js standard streams:\n *\n * * `async promiseTransform(chunk)` - transform method that resolves with a single output chunk\n * * `async promiseWrite(chunk)` - write method that that resolves when chunk is written\n * * `async promiseRead(count)` - read method that resolves with an array of chunks when called\n *\n * See {@link https://nodejs.org/api/stream.html#stream_api_for_stream_implementers node.js API for stream implementers for details}\n *\n * The object exposes the following classes:\n *\n * * `DataStream` {@see DataStream} - the basic object stream of any type\n * * `StringStream` {@see StringStream} - a stream of strings\n * * `BufferStream` {@see BufferStream} - a stream of buffers\n * * `MultiStream` {@see MultiStream} - a group of streams\n * * `NumberStream` {@see NumberStream} - a stream of numbers\n * * `WindowStream` {@see WindowStream} - a stream of windows of objects\n *\n * The general concept of Scramjet streams is facilitating node's TransformStream mechanism so that you don't need\n * to create a number of streams and create the pipeline, but use the concept of chaining instead. When you call `parse`\n * method for instance, scramjet creates a new stream, pipes it to the callee and forwards errors.\n *\n * What's worth mentioning - scramjet tries to limit the number of created transform streams and pushes the transforms\n * one after another into the same stream class therefore a code `stream.map(transform1).map(transform2).filter(transform3)`\n * will only operate on a single transform stream that evaluates all three transforms one after another.\n *\n * @exports scramjet\n * @module scramjet\n */\nmodule.exports = {\n    /**\n     * Creates a DataStream that's piped from the passed readable.\n     *\n     * @memberof module:scramjet\n     * @param {Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|string|Readable} input argument to be turned into new stream\n     * @param {DataStreamOptions|Writable} [options={}] options for creation of a new stream or the target stream\n     * @param {any[]} ...args additional arguments for the stream - will be passed to the function or generator\n     * @return {DataStream}\n     */\n    from(...args) {\n        return this.DataStream.from(...args);\n    },\n\n    /**\n     * Creates a DataStream from an Array\n     *\n     * @memberof module:scramjet\n     * @param  {Array} array list of chunks\n     * @param {DataStreamOptions} [options={}] the read stream options\n     * @return {DataStream}\n     */\n    fromArray(...args) {\n        return this.DataStream.fromArray(...args);\n    },\n\n    get ScramjetOptions() { return require(\"./util/options\"); },\n\n    /**\n     * Creates a safe wrapper for scramjet transform module. See [Modules documentation](modules.md) for more info.\n     *\n     * @param {UseCallback} transform\n     * @param {CreateModuleOptions} [options={}]\n     * @param  {any[]} ...initialArgs\n     * @return {Function} a scramjet module function\n     */\n    createTransformModule(transform, {StreamClass = module.exports.DataStream} = {}, ...initialArgs) {\n        return function (stream, ...extraArgs) {\n            return StreamClass.from(stream)\n                .use(transform, ...initialArgs, ...extraArgs);\n        };\n    },\n\n    /**\n     * Creates a safe wrapper for scramjet read module. See [Modules documentation](modules.md) for more info.\n     *\n     * @param {Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|string|Readable} anything\n     * @param {CreateModuleOptions} [options={}]\n     * @param  {any[]} ...initialArgs\n     * @return {Function} a scramjet module function\n     */\n    createReadModule(anything, {StreamClass = module.exports.DataStream} = {}, ...initialArgs) {\n        StreamClass = StreamClass || this.DataStream;\n\n        return (...extraArgs) => {\n            return StreamClass.from(anything, ...initialArgs, ...extraArgs);\n        };\n    },\n\n    /**\n     * Options for createModule\n     *\n     * @typedef {object} CreateModuleOptions\n     * @memberof module:scramjet~\n     * @prop {DataStream} StreamClass defines what class should the module assume\n     */\n\n    get errors()  { return require(\"./util/stream-errors\"); },\n\n    /**\n     * @ignore\n     * @see {@link buffer-stream.md}\n     */\n    get BufferStream() { return require(\"./buffer-stream\"); },\n\n    /**\n     * @ignore\n     * @see {@link data-stream.md}\n     */\n    get DataStream() { return require(\"./data-stream\"); },\n\n    /**\n     * @ignore\n     * @see {@link multi-stream.md}\n     */\n    get MultiStream() { return require(\"./multi-stream\"); },\n\n    /**\n     * @ignore\n     * @see {@link string-stream.md}\n     */\n    get StringStream() { return require(\"./string-stream\"); },\n\n    /**\n     * Provides a lazy-load accessor to PromiseTransformStream - the base class of scramjet streams\n     *\n     * @ignore\n     */\n    get PromiseTransformStream() { return require(\"./util/promise-transform-stream\").PromiseTransformStream; },\n\n    /**\n     * Definition of a single mixin for a specific Scramjet class. Should contain any number of stream methods.\n     *\n     * @typedef {object} StreamMixin\n     * @memberof module:scramjet~\n     * @property {Function} constructor optional constructor that will be called in the stream constructor (this has to be an own property!)\n     */\n\n    /**\n     * Definition of a plugin in Scramjet\n     *\n     * @typedef {object} ScramjetPlugin\n     * @memberof module:scramjet~\n     * @internal\n     * @property {StreamMixin} BufferStream definition of constructor and properties for the BufferStream prototype.\n     * @property {StreamMixin} DataStream definition of constructor and properties for the DataStream prototype.\n     * @property {StreamMixin} MultiStream definition of constructor and properties for the MultiStream prototype.\n     * @property {StreamMixin} StringStream definition of constructor and properties for the StringStream prototype.\n     */\n\n    /**\n     * Plugs in methods for any of the classes\n     *\n     * @static\n     * @memberof module:scramjet\n     * @param  {ScramjetPlugin} mixin the plugin object\n     * @return {ScramjetPlugin}\n     *\n     * @test test/methods/scramjet-plugin.js\n     */\n    plugin(mixins) {\n        for (const key of Object.keys(mixins)) {\n            if (key in this) {\n                const Mixin = mixins[key];\n                const Stream = this[key];\n                if (Object.prototype.hasOwnProperty.call(Mixin, \"constructor\") && Stream[plgctor]) {\n                    Stream[plgctor].ctors.push(Mixin.constructor);\n                    delete Mixin.constructor;\n                }\n                Object.getOwnPropertyNames(Mixin).forEach(\n                    (prop) => Object.defineProperty(Stream.prototype, prop, Object.getOwnPropertyDescriptor(Mixin, prop))\n                );\n            } else {\n                this[key] = mixins[key];\n            }\n        }\n        return this;\n    },\n\n    /**\n     * Gets an API version (this may be important for future use)\n     *\n     * @static\n     * @memberof module:scramjet\n     * @param {number} version The required version (currently only: 1)\n     * @return {ScramjetPlugin}\n     */\n    API(version) {\n        if (version === 1) {\n            return module.exports;\n        }\n    }\n};\n\n// ----- Externals documentation -----\n\n/**\n * Asynchronous Generator.\n *\n * @ignore\n * @external AsyncGeneratorFunction\n * @see https://github.com/tc39/proposal-async-iteration#async-generator-functions\n */\n\n/**\n * Generator function (`function* ()`).\n *\n * @ignore\n * @external GeneratorFunction\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction\n */\n\n/**\n * Simple Node.js Passthrough stream.\n *\n * @ignore\n * @external stream.PassThrough\n * @see https://nodejs.org/api/stream.html#stream_class_stream_passthrough\n */\n"]},"metadata":{},"sourceType":"script"}