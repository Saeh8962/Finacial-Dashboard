{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require(\"../\"),\n    DataStream = _require.DataStream,\n    StringStream = _require.StringStream;\n\nvar ref = {};\n\nvar _require2 = require(\"child_process\"),\n    fork = _require2.fork;\n\nvar os = require(\"os\");\n\nvar net = require(\"net\");\n\nvar workerSeq = 0;\nvar workers = [];\n/**\n * StreamWorker class - intended for internal use\n *\n * This class provides control over the subprocesses, including:\n *  - spawning\n *  - communicating\n *  - delivering streams\n *\n * @internal\n * @memberof module:scramjet\n */\n\nvar StreamWorker = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * Private constructor\n   */\n  function StreamWorker(def) {\n    _classCallCheck(this, StreamWorker);\n\n    if (def !== ref) {\n      throw new Error(\"Private constructor\");\n    }\n\n    this._refcount = 0;\n    this.timeout = 1e3;\n    this.child = null;\n    this.resolving = null;\n    this.ip = \"localhost\";\n    this.port = 0;\n  }\n  /**\n   * Spawns the worker if necessary and provides the port information to it.\n   *\n   * @async\n   * @return {StreamWorker}\n   */\n\n\n  _createClass(StreamWorker, [{\n    key: \"spawn\",\n    value: function () {\n      var _spawn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.resolving || (this.resolving = new Promise(function (res, rej) {\n                  _this._child = fork(__dirname + \"/stream-child\", [_this.ip, _this.timeout]);\n                  var resolved = false;\n                  var rejected = false;\n\n                  _this._child.once(\"message\", function (_ref) {\n                    var port = _ref.port;\n                    return _this.port = +port, resolved = true, res(_this);\n                  });\n\n                  _this._child.once(\"error\", function (e) {\n                    return rejected = true, rej(e);\n                  });\n\n                  _this._child.once(\"exit\", function (code) {\n                    if (!code) // no error, child exited, clear the promise so that it respawns when needed\n                      _this.resolving = null;else _this.resolving = Promise.reject(new Error(\"Child exited with non-zero status code: \" + code));\n                  });\n\n                  setTimeout(function () {\n                    return resolved || rejected || (rejected = true) && rej(new Error(\"StreamWorker child timeout!\"));\n                  }, _this.timeout);\n                })));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function spawn() {\n        return _spawn.apply(this, arguments);\n      }\n\n      return spawn;\n    }()\n    /**\n     * Delegates a stream to the child using tcp socket.\n     *\n     * The stream gets serialized using JSON and passed on to the sub-process.\n     * The sub-process then performs transforms on the stream and pushes them back to the main process.\n     * The stream gets deserialized and outputted to the returned DataStream.\n     *\n     * @param  {DataStream} input stream to be delegated\n     * @param  {TeeCallback[]|Array} delegateFunc Array of transforms or arrays describing ['module', 'method']\n     * @param  {any[]} [plugins=[]] List of plugins to load in the child\n     * @return {DataStream} stream after transforms and back to the main process.\n     */\n\n  }, {\n    key: \"delegate\",\n    value: function delegate(input, delegateFunc) {\n      var plugins = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var sock = new net.Socket().setNoDelay(true);\n\n      var _in = new DataStream();\n\n      var _out = _in.JSONStringify().pipe(sock.connect(this.port, this.ip)).pipe(new StringStream()).JSONParse().filter(function (_ref2) {\n        var error = _ref2.error;\n\n        if (error) {\n          var err = new Error(error.message);\n          err.stack = \"[child]\" + error.stack;\n        }\n\n        return true;\n      });\n\n      _in.unshift({\n        type: 0,\n        // 0 - start, 1 - end\n        plugins: plugins,\n        streamClass: input.constructor.name,\n        transforms: delegateFunc.map(function (func) {\n          return typeof func === \"function\" ? func.toString() : Array.isArray(func) ? func : [func];\n        })\n      });\n\n      input.pipe(_in);\n      return _out;\n    }\n    /**\n     * Spawns (Preforks) a given number of subprocesses and returns the worker asynchronously.\n     *\n     * @async\n     * @param  {number}  [count=os.cpus().length] Number of processes to spawn. If other subprocesses are active only the missing ones will be spawned.\n     * @return {Array<StreamWorker>}  list of StreamWorkers\n     */\n\n  }], [{\n    key: \"fork\",\n    value: function () {\n      var _fork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this2 = this;\n\n        var count,\n            i,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                count = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : os.cpus().length;\n\n                for (i = workers.length; i < count; i++) {\n                  workers.push(new StreamWorker(ref));\n                }\n\n                return _context2.abrupt(\"return\", Promise.all(new Array(count).fill(1).map(function () {\n                  return _this2._getWorker();\n                })));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function fork() {\n        return _fork.apply(this, arguments);\n      }\n\n      return fork;\n    }()\n    /**\n     * Picks next worker (not necessarily free one!)\n     *\n     * @async\n     * @return {StreamWorker}\n     */\n\n  }, {\n    key: \"_getWorker\",\n    value: function () {\n      var _getWorker2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", workers[workerSeq = ++workerSeq % workers.length].spawn());\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function _getWorker() {\n        return _getWorker2.apply(this, arguments);\n      }\n\n      return _getWorker;\n    }()\n  }]);\n\n  return StreamWorker;\n}();\n\nmodule.exports = StreamWorker;","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/client/node_modules/scramjet/lib/stream-worker.js"],"names":["require","DataStream","StringStream","ref","fork","os","net","workerSeq","workers","StreamWorker","def","Error","_refcount","timeout","child","resolving","ip","port","Promise","res","rej","_child","__dirname","resolved","rejected","once","e","code","reject","setTimeout","input","delegateFunc","plugins","sock","Socket","setNoDelay","_in","_out","JSONStringify","pipe","connect","JSONParse","filter","error","err","message","stack","unshift","type","streamClass","constructor","name","transforms","map","func","toString","Array","isArray","count","cpus","length","i","push","all","fill","_getWorker","spawn","module","exports"],"mappings":"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","sourcesContent":["const {DataStream, StringStream} = require(\"../\");\nconst ref = {};\nconst {fork} = require(\"child_process\");\nconst os = require(\"os\");\n\nconst net = require(\"net\");\n\nlet workerSeq = 0;\nconst workers = [];\n\n/**\n * StreamWorker class - intended for internal use\n *\n * This class provides control over the subprocesses, including:\n *  - spawning\n *  - communicating\n *  - delivering streams\n *\n * @internal\n * @memberof module:scramjet\n */\nclass StreamWorker {\n\n    /**\n     * Private constructor\n     */\n    constructor(def) {\n        if (def !== ref) {\n            throw new Error(\"Private constructor\");\n        }\n\n        this._refcount = 0;\n\n        this.timeout = 1e3;\n        this.child = null;\n        this.resolving = null;\n\n        this.ip = \"localhost\";\n        this.port = 0;\n    }\n\n    /**\n     * Spawns the worker if necessary and provides the port information to it.\n     *\n     * @async\n     * @return {StreamWorker}\n     */\n    async spawn() {\n        return this.resolving || (this.resolving = new Promise((res, rej) => {\n            this._child = fork(__dirname + \"/stream-child\", [this.ip, this.timeout]);\n\n            let resolved = false;\n            let rejected = false;\n\n            this._child.once(\"message\", ({port}) => (this.port = +port, resolved = true, res(this)));\n            this._child.once(\"error\", (e) => (rejected = true, rej(e)));\n            this._child.once(\"exit\", (code) => {\n                if (!code) // no error, child exited, clear the promise so that it respawns when needed\n                    this.resolving = null;\n                else\n                    this.resolving = Promise.reject(new Error(\"Child exited with non-zero status code: \" + code));\n            });\n\n            setTimeout(() => resolved || rejected || (rejected = true) && rej(new Error(\"StreamWorker child timeout!\")), this.timeout);\n        }));\n    }\n\n    /**\n     * Delegates a stream to the child using tcp socket.\n     *\n     * The stream gets serialized using JSON and passed on to the sub-process.\n     * The sub-process then performs transforms on the stream and pushes them back to the main process.\n     * The stream gets deserialized and outputted to the returned DataStream.\n     *\n     * @param  {DataStream} input stream to be delegated\n     * @param  {TeeCallback[]|Array} delegateFunc Array of transforms or arrays describing ['module', 'method']\n     * @param  {any[]} [plugins=[]] List of plugins to load in the child\n     * @return {DataStream} stream after transforms and back to the main process.\n     */\n    delegate(input, delegateFunc, plugins = []) {\n\n        const sock = new net.Socket().setNoDelay(true);\n\n        const _in = new DataStream();\n\n        const _out = _in\n            .JSONStringify()\n            .pipe(sock.connect(this.port, this.ip))\n            .pipe(new StringStream)\n            .JSONParse()\n            .filter(\n                ({error}) => {\n                    if (error) {\n                        const err = new Error(error.message);\n                        err.stack = \"[child]\" + error.stack;\n                    }\n                    return true;\n                }\n            )\n        ;\n\n        _in.unshift({\n            type: 0, // 0 - start, 1 - end\n            plugins,\n            streamClass: input.constructor.name,\n            transforms: delegateFunc.map(\n                func => typeof func === \"function\" ? func.toString() : (Array.isArray(func) ? func : [func])\n            )\n        });\n\n        input.pipe(_in);\n\n        return _out;\n    }\n\n    /**\n     * Spawns (Preforks) a given number of subprocesses and returns the worker asynchronously.\n     *\n     * @async\n     * @param  {number}  [count=os.cpus().length] Number of processes to spawn. If other subprocesses are active only the missing ones will be spawned.\n     * @return {Array<StreamWorker>}  list of StreamWorkers\n     */\n    static async fork(count = os.cpus().length) {\n\n        for (let i = workers.length; i < count; i++)\n            workers.push(new StreamWorker(ref));\n\n        return Promise.all(new Array(count).fill(1).map(() => this._getWorker()));\n    }\n\n    /**\n     * Picks next worker (not necessarily free one!)\n     *\n     * @async\n     * @return {StreamWorker}\n     */\n    static async _getWorker() {\n        // TODO: Use free / not fully utilized workers first.\n\n        return workers[workerSeq = ++workerSeq % workers.length].spawn();\n    }\n\n}\n\nmodule.exports = StreamWorker;\n"]},"metadata":{},"sourceType":"script"}