{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _createForOfIteratorHelper = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar DOMException = require(\"domexception/webidl2js-wrapper\");\n\nvar EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\n\nvar _require = require(\"../../utils\"),\n    simultaneousIterators = _require.simultaneousIterators;\n\nvar NODE_TYPE = require(\"../node-type\");\n\nvar NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\n\nvar _require2 = require(\"../node\"),\n    clone = _require2.clone,\n    locateNamespacePrefix = _require2.locateNamespacePrefix,\n    locateNamespace = _require2.locateNamespace;\n\nvar _require3 = require(\"../attributes\"),\n    setAnExistingAttributeValue = _require3.setAnExistingAttributeValue;\n\nvar NodeList = require(\"../generated/NodeList\");\n\nvar _require4 = require(\"../helpers/node\"),\n    nodeRoot = _require4.nodeRoot,\n    nodeLength = _require4.nodeLength;\n\nvar _require5 = require(\"../helpers/internal-constants\"),\n    domSymbolTree = _require5.domSymbolTree;\n\nvar _require6 = require(\"../helpers/document-base-url\"),\n    documentBaseURLSerialized = _require6.documentBaseURLSerialized;\n\nvar _require7 = require(\"../helpers/mutation-observers\"),\n    queueTreeMutationRecord = _require7.queueTreeMutationRecord;\n\nvar _require8 = require(\"../helpers/custom-elements\"),\n    enqueueCECallbackReaction = _require8.enqueueCECallbackReaction,\n    tryUpgradeElement = _require8.tryUpgradeElement;\n\nvar _require9 = require(\"../helpers/shadow-dom\"),\n    isShadowRoot = _require9.isShadowRoot,\n    shadowIncludingRoot = _require9.shadowIncludingRoot,\n    assignSlot = _require9.assignSlot,\n    assignSlotableForTree = _require9.assignSlotableForTree,\n    assignSlotable = _require9.assignSlotable,\n    signalSlotChange = _require9.signalSlotChange,\n    isSlot = _require9.isSlot,\n    shadowIncludingInclusiveDescendantsIterator = _require9.shadowIncludingInclusiveDescendantsIterator,\n    shadowIncludingDescendantsIterator = _require9.shadowIncludingDescendantsIterator;\n\nfunction isObsoleteNodeType(node) {\n  return node.nodeType === NODE_TYPE.ENTITY_NODE || node.nodeType === NODE_TYPE.ENTITY_REFERENCE_NODE || node.nodeType === NODE_TYPE.NOTATION_NODE || node.nodeType === NODE_TYPE.CDATA_SECTION_NODE;\n}\n\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId || a.systemId !== b.systemId) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName || a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.ATTRIBUTE_NODE:\n      if (a._namespace !== b._namespace || a._localName !== b._localName || a._value !== b._value) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n\n      break;\n  }\n\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributeListsEqual(a, b)) {\n    return false;\n  }\n\n  var _iterator = _createForOfIteratorHelper(simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var nodes = _step.value;\n\n      if (!nodes[0] || !nodes[1]) {\n        // mismatch in the amount of childNodes\n        return false;\n      }\n\n      if (!nodeEquals(nodes[0], nodes[1])) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return true;\n} // Needed by https://dom.spec.whatwg.org/#concept-node-equals\n\n\nfunction attributeListsEqual(elementA, elementB) {\n  var listA = elementA._attributeList;\n  var listB = elementB._attributeList;\n  var lengthA = listA.length;\n  var lengthB = listB.length;\n\n  if (lengthA !== lengthB) {\n    return false;\n  }\n\n  var _loop = function _loop(i) {\n    var attrA = listA[i];\n\n    if (!listB.some(function (attrB) {\n      return nodeEquals(attrA, attrB);\n    })) {\n      return {\n        v: false\n      };\n    }\n  };\n\n  for (var i = 0; i < lengthA; ++i) {\n    var _ret = _loop(i);\n\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n\n  return true;\n} // https://dom.spec.whatwg.org/#concept-tree-host-including-inclusive-ancestor\n\n\nfunction isHostInclusiveAncestor(nodeImplA, nodeImplB) {\n  var _iterator2 = _createForOfIteratorHelper(domSymbolTree.ancestorsIterator(nodeImplB)),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var ancestor = _step2.value;\n\n      if (ancestor === nodeImplA) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var rootImplB = nodeRoot(nodeImplB);\n\n  if (rootImplB._host) {\n    return isHostInclusiveAncestor(nodeImplA, rootImplB._host);\n  }\n\n  return false;\n}\n\nvar NodeImpl = /*#__PURE__*/function (_EventTargetImpl) {\n  _inherits(NodeImpl, _EventTargetImpl);\n\n  var _super = _createSuper(NodeImpl);\n\n  function NodeImpl(globalObject, args, privateData) {\n    var _this;\n\n    _classCallCheck(this, NodeImpl);\n\n    _this = _super.call(this, globalObject, args, privateData);\n    domSymbolTree.initialize(_assertThisInitialized(_this));\n    _this._ownerDocument = privateData.ownerDocument;\n    _this._childNodesList = null;\n    _this._childrenList = null;\n    _this._version = 0;\n    _this._memoizedQueries = {};\n    _this._registeredObserverList = [];\n    _this._referencedRanges = new Set();\n    return _this;\n  }\n\n  _createClass(NodeImpl, [{\n    key: \"_getTheParent\",\n    value: function _getTheParent() {\n      if (this._assignedSlot) {\n        return this._assignedSlot;\n      }\n\n      return domSymbolTree.parent(this);\n    }\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return domSymbolTree.parent(this);\n    }\n  }, {\n    key: \"getRootNode\",\n    value: function getRootNode(options) {\n      return options.composed ? shadowIncludingRoot(this) : nodeRoot(this);\n    }\n  }, {\n    key: \"nodeName\",\n    get: function get() {\n      switch (this.nodeType) {\n        case NODE_TYPE.ELEMENT_NODE:\n          return this.tagName;\n\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          return this._qualifiedName;\n\n        case NODE_TYPE.TEXT_NODE:\n          return \"#text\";\n\n        case NODE_TYPE.CDATA_SECTION_NODE:\n          return \"#cdata-section\";\n\n        case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n          return this.target;\n\n        case NODE_TYPE.COMMENT_NODE:\n          return \"#comment\";\n\n        case NODE_TYPE.DOCUMENT_NODE:\n          return \"#document\";\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          return this.name;\n\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n          return \"#document-fragment\";\n      } // should never happen\n\n\n      return null;\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return domSymbolTree.firstChild(this);\n    } // https://dom.spec.whatwg.org/#connected\n    // https://dom.spec.whatwg.org/#dom-node-isconnected\n\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      var root = shadowIncludingRoot(this);\n      return root && root.nodeType === NODE_TYPE.DOCUMENT_NODE;\n    }\n  }, {\n    key: \"ownerDocument\",\n    get: function get() {\n      return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return domSymbolTree.lastChild(this);\n    }\n  }, {\n    key: \"childNodes\",\n    get: function get() {\n      var _this2 = this;\n\n      if (!this._childNodesList) {\n        this._childNodesList = NodeList.createImpl(this._globalObject, [], {\n          element: this,\n          query: function query() {\n            return domSymbolTree.childrenToArray(_this2);\n          }\n        });\n      } else {\n        this._childNodesList._update();\n      }\n\n      return this._childNodesList;\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      return domSymbolTree.nextSibling(this);\n    }\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      return domSymbolTree.previousSibling(this);\n    }\n  }, {\n    key: \"_modified\",\n    value: function _modified() {\n      this._version++;\n\n      var _iterator3 = _createForOfIteratorHelper(domSymbolTree.ancestorsIterator(this)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var ancestor = _step3.value;\n          ancestor._version++;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      if (this._childrenList) {\n        this._childrenList._update();\n      }\n\n      if (this._childNodesList) {\n        this._childNodesList._update();\n      }\n\n      this._clearMemoizedQueries();\n    }\n  }, {\n    key: \"_childTextContentChangeSteps\",\n    value: function _childTextContentChangeSteps() {// Default: do nothing\n    }\n  }, {\n    key: \"_clearMemoizedQueries\",\n    value: function _clearMemoizedQueries() {\n      this._memoizedQueries = {};\n      var myParent = domSymbolTree.parent(this);\n\n      if (myParent) {\n        myParent._clearMemoizedQueries();\n      }\n    }\n  }, {\n    key: \"_descendantRemoved\",\n    value: function _descendantRemoved(parent, child) {\n      var myParent = domSymbolTree.parent(this);\n\n      if (myParent) {\n        myParent._descendantRemoved(parent, child);\n      }\n    }\n  }, {\n    key: \"_descendantAdded\",\n    value: function _descendantAdded(parent, child) {\n      var myParent = domSymbolTree.parent(this);\n\n      if (myParent) {\n        myParent._descendantAdded(parent, child);\n      }\n    }\n  }, {\n    key: \"_attach\",\n    value: function _attach() {\n      this._attached = true;\n\n      var _iterator4 = _createForOfIteratorHelper(domSymbolTree.childrenIterator(this)),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var child = _step4.value;\n\n          if (child._attach) {\n            child._attach();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"_detach\",\n    value: function _detach() {\n      this._attached = false;\n\n      if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n        this._ownerDocument._lastFocusedElement = null;\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(domSymbolTree.childrenIterator(this)),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var child = _step5.value;\n\n          if (child._detach) {\n            child._detach();\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }, {\n    key: \"hasChildNodes\",\n    value: function hasChildNodes() {\n      return domSymbolTree.hasChildren(this);\n    } // https://dom.spec.whatwg.org/#dom-node-normalize\n\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      // It is important to use a treeToArray instead of a treeToIterator here, because the\n      // treeToIterator doesn't support tree mutation in the middle of the traversal.\n      var _iterator6 = _createForOfIteratorHelper(domSymbolTree.treeToArray(this)),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var node = _step6.value;\n          var parentNode = domSymbolTree.parent(node);\n\n          if (parentNode === null || node.nodeType !== NODE_TYPE.TEXT_NODE) {\n            continue;\n          }\n\n          var length = nodeLength(node);\n\n          if (length === 0) {\n            parentNode._remove(node);\n\n            continue;\n          }\n\n          var continuousExclusiveTextNodes = [];\n\n          var _iterator7 = _createForOfIteratorHelper(domSymbolTree.previousSiblingsIterator(node)),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _currentNode = _step7.value;\n\n              if (_currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n                break;\n              }\n\n              continuousExclusiveTextNodes.unshift(_currentNode);\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n\n          var _iterator8 = _createForOfIteratorHelper(domSymbolTree.nextSiblingsIterator(node)),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _currentNode2 = _step8.value;\n\n              if (_currentNode2.nodeType !== NODE_TYPE.TEXT_NODE) {\n                break;\n              }\n\n              continuousExclusiveTextNodes.push(_currentNode2);\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n\n          var data = continuousExclusiveTextNodes.reduce(function (d, n) {\n            return d + n._data;\n          }, \"\");\n          node.replaceData(length, 0, data);\n          var currentNode = domSymbolTree.nextSibling(node);\n\n          while (currentNode && currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n            var currentNodeParent = domSymbolTree.parent(currentNode);\n            var currentNodeIndex = domSymbolTree.index(currentNode);\n\n            var _iterator9 = _createForOfIteratorHelper(node._referencedRanges),\n                _step9;\n\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var range = _step9.value;\n                var _start = range._start,\n                    _end = range._end;\n\n                if (_start.node === currentNode) {\n                  range._setLiveRangeStart(node, _start.offset + length);\n                }\n\n                if (_end.node === currentNode) {\n                  range._setLiveRangeEnd(node, _end.offset + length);\n                }\n\n                if (_start.node === currentNodeParent && _start.offset === currentNodeIndex) {\n                  range._setLiveRangeStart(node, length);\n                }\n\n                if (_end.node === currentNodeParent && _end.offset === currentNodeIndex) {\n                  range._setLiveRangeStart(node, length);\n                }\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n\n            length += nodeLength(currentNode);\n            currentNode = domSymbolTree.nextSibling(currentNode);\n          }\n\n          for (var _i = 0, _continuousExclusiveT = continuousExclusiveTextNodes; _i < _continuousExclusiveT.length; _i++) {\n            var continuousExclusiveTextNode = _continuousExclusiveT[_i];\n\n            parentNode._remove(continuousExclusiveTextNode);\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }, {\n    key: \"parentElement\",\n    get: function get() {\n      var parentNode = domSymbolTree.parent(this);\n      return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n    }\n  }, {\n    key: \"baseURI\",\n    get: function get() {\n      return documentBaseURLSerialized(this._ownerDocument);\n    }\n  }, {\n    key: \"compareDocumentPosition\",\n    value: function compareDocumentPosition(other) {\n      // Let node1 be other and node2 be the context object.\n      var node1 = other;\n      var node2 = this;\n\n      if (isObsoleteNodeType(node2) || isObsoleteNodeType(node1)) {\n        throw new Error(\"Obsolete node type\");\n      }\n\n      var attr1 = null;\n      var attr2 = null;\n\n      if (node1.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n        attr1 = node1;\n        node1 = attr1._element;\n      }\n\n      if (node2.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n        attr2 = node2;\n        node2 = attr2._element;\n\n        if (attr1 !== null && node1 !== null && node2 === node1) {\n          var _iterator10 = _createForOfIteratorHelper(node2._attributeList),\n              _step10;\n\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var attr = _step10.value;\n\n              if (nodeEquals(attr, attr1)) {\n                return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_PRECEDING;\n              }\n\n              if (nodeEquals(attr, attr2)) {\n                return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n              }\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        }\n      }\n\n      var result = domSymbolTree.compareTreePosition(node2, node1); // “If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n      //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n      // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.”\n\n      if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n        // symbol-tree does not add these bits required by the spec:\n        return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"lookupPrefix\",\n    value: function lookupPrefix(namespace) {\n      if (namespace === null || namespace === \"\") {\n        return null;\n      }\n\n      switch (this.nodeType) {\n        case NODE_TYPE.ELEMENT_NODE:\n          {\n            return locateNamespacePrefix(this, namespace);\n          }\n\n        case NODE_TYPE.DOCUMENT_NODE:\n          {\n            return this.documentElement !== null ? locateNamespacePrefix(this.documentElement, namespace) : null;\n          }\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n          {\n            return null;\n          }\n\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          {\n            return this._element !== null ? locateNamespacePrefix(this._element, namespace) : null;\n          }\n\n        default:\n          {\n            return this.parentElement !== null ? locateNamespacePrefix(this.parentElement, namespace) : null;\n          }\n      }\n    }\n  }, {\n    key: \"lookupNamespaceURI\",\n    value: function lookupNamespaceURI(prefix) {\n      if (prefix === \"\") {\n        prefix = null;\n      }\n\n      return locateNamespace(this, prefix);\n    }\n  }, {\n    key: \"isDefaultNamespace\",\n    value: function isDefaultNamespace(namespace) {\n      if (namespace === \"\") {\n        namespace = null;\n      }\n\n      var defaultNamespace = locateNamespace(this, null);\n      return defaultNamespace === namespace;\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(other) {\n      if (other === null) {\n        return false;\n      } else if (this === other) {\n        return true;\n      }\n\n      return Boolean(this.compareDocumentPosition(other) & NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_CONTAINED_BY);\n    }\n  }, {\n    key: \"isEqualNode\",\n    value: function isEqualNode(node) {\n      if (node === null) {\n        return false;\n      } // Fast-path, not in the spec\n\n\n      if (this === node) {\n        return true;\n      }\n\n      return nodeEquals(this, node);\n    }\n  }, {\n    key: \"isSameNode\",\n    value: function isSameNode(node) {\n      if (this === node) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"cloneNode\",\n    value: function cloneNode(deep) {\n      if (isShadowRoot(this)) {\n        throw DOMException.create(this._globalObject, [\"ShadowRoot nodes are not clonable.\", \"NotSupportedError\"]);\n      }\n\n      deep = Boolean(deep);\n      return clone(this, undefined, deep);\n    }\n  }, {\n    key: \"nodeValue\",\n    get: function get() {\n      switch (this.nodeType) {\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          {\n            return this._value;\n          }\n\n        case NODE_TYPE.TEXT_NODE:\n        case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n        case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        case NODE_TYPE.COMMENT_NODE:\n          {\n            return this._data;\n          }\n\n        default:\n          {\n            return null;\n          }\n      }\n    },\n    set: function set(value) {\n      if (value === null) {\n        value = \"\";\n      }\n\n      switch (this.nodeType) {\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          {\n            setAnExistingAttributeValue(this, value);\n            break;\n          }\n\n        case NODE_TYPE.TEXT_NODE:\n        case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n        case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        case NODE_TYPE.COMMENT_NODE:\n          {\n            this.replaceData(0, this.length, value);\n            break;\n          }\n      }\n    } // https://dom.spec.whatwg.org/#dom-node-textcontent\n\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      switch (this.nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        case NODE_TYPE.ELEMENT_NODE:\n          {\n            var text = \"\";\n\n            var _iterator11 = _createForOfIteratorHelper(domSymbolTree.treeIterator(this)),\n                _step11;\n\n            try {\n              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                var child = _step11.value;\n\n                if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n                  text += child.nodeValue;\n                }\n              }\n            } catch (err) {\n              _iterator11.e(err);\n            } finally {\n              _iterator11.f();\n            }\n\n            return text;\n          }\n\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          {\n            return this._value;\n          }\n\n        case NODE_TYPE.TEXT_NODE:\n        case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n        case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        case NODE_TYPE.COMMENT_NODE:\n          {\n            return this._data;\n          }\n\n        default:\n          {\n            return null;\n          }\n      }\n    },\n    set: function set(value) {\n      if (value === null) {\n        value = \"\";\n      }\n\n      switch (this.nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        case NODE_TYPE.ELEMENT_NODE:\n          {\n            // https://dom.spec.whatwg.org/#string-replace-all\n            var nodeImpl = null;\n\n            if (value !== \"\") {\n              nodeImpl = this._ownerDocument.createTextNode(value);\n            }\n\n            this._replaceAll(nodeImpl);\n\n            break;\n          }\n\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          {\n            setAnExistingAttributeValue(this, value);\n            break;\n          }\n\n        case NODE_TYPE.TEXT_NODE:\n        case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n        case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        case NODE_TYPE.COMMENT_NODE:\n          {\n            this.replaceData(0, this.length, value);\n            break;\n          }\n      }\n    } // https://dom.spec.whatwg.org/#dom-node-insertbefore\n\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(nodeImpl, childImpl) {\n      return this._preInsert(nodeImpl, childImpl);\n    } // https://dom.spec.whatwg.org/#dom-node-appendchild\n\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(nodeImpl) {\n      return this._append(nodeImpl);\n    } // https://dom.spec.whatwg.org/#dom-node-replacechild\n\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(nodeImpl, childImpl) {\n      return this._replace(nodeImpl, childImpl);\n    } // https://dom.spec.whatwg.org/#dom-node-removechild\n\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(oldChildImpl) {\n      return this._preRemove(oldChildImpl);\n    } // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n\n  }, {\n    key: \"_preInsertValidity\",\n    value: function _preInsertValidity(nodeImpl, childImpl) {\n      var nodeType = nodeImpl.nodeType,\n          nodeName = nodeImpl.nodeName;\n      var parentType = this.nodeType,\n          parentName = this.nodeName;\n\n      if (parentType !== NODE_TYPE.DOCUMENT_NODE && parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && parentType !== NODE_TYPE.ELEMENT_NODE) {\n        throw DOMException.create(this._globalObject, [\"Node can't be inserted in a \".concat(parentName, \" parent.\"), \"HierarchyRequestError\"]);\n      }\n\n      if (isHostInclusiveAncestor(nodeImpl, this)) {\n        throw DOMException.create(this._globalObject, [\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\"]);\n      }\n\n      if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n        throw DOMException.create(this._globalObject, [\"The child can not be found in the parent.\", \"NotFoundError\"]);\n      }\n\n      if (nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE && nodeType !== NODE_TYPE.ELEMENT_NODE && nodeType !== NODE_TYPE.TEXT_NODE && nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n      nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE && nodeType !== NODE_TYPE.COMMENT_NODE) {\n        throw DOMException.create(this._globalObject, [\"\".concat(nodeName, \" node can't be inserted in parent node.\"), \"HierarchyRequestError\"]);\n      }\n\n      if (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE || nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE) {\n        throw DOMException.create(this._globalObject, [\"\".concat(nodeName, \" node can't be inserted in \").concat(parentName, \" parent.\"), \"HierarchyRequestError\"]);\n      }\n\n      if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n        var nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n        var parentChildren = domSymbolTree.childrenToArray(this);\n\n        switch (nodeType) {\n          case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n            {\n              var nodeChildrenElements = nodeChildren.filter(function (child) {\n                return child.nodeType === NODE_TYPE.ELEMENT_NODE;\n              });\n\n              if (nodeChildrenElements.length > 1) {\n                throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n              }\n\n              var hasNodeTextChildren = nodeChildren.some(function (child) {\n                return child.nodeType === NODE_TYPE.TEXT_NODE;\n              });\n\n              if (hasNodeTextChildren) {\n                throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n              }\n\n              if (nodeChildrenElements.length === 1 && (parentChildren.some(function (child) {\n                return child.nodeType === NODE_TYPE.ELEMENT_NODE;\n              }) || childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE)) {\n                throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n              }\n\n              break;\n            }\n\n          case NODE_TYPE.ELEMENT_NODE:\n            if (parentChildren.some(function (child) {\n              return child.nodeType === NODE_TYPE.ELEMENT_NODE;\n            }) || childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n              throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n            }\n\n            break;\n\n          case NODE_TYPE.DOCUMENT_TYPE_NODE:\n            if (parentChildren.some(function (child) {\n              return child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE;\n            }) || childImpl && domSymbolTree.previousSibling(childImpl) && domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE || !childImpl && parentChildren.some(function (child) {\n              return child.nodeType === NODE_TYPE.ELEMENT_NODE;\n            })) {\n              throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n            }\n\n            break;\n        }\n      }\n    } // https://dom.spec.whatwg.org/#concept-node-pre-insert\n\n  }, {\n    key: \"_preInsert\",\n    value: function _preInsert(nodeImpl, childImpl) {\n      this._preInsertValidity(nodeImpl, childImpl);\n\n      var referenceChildImpl = childImpl;\n\n      if (referenceChildImpl === nodeImpl) {\n        referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n      }\n\n      this._ownerDocument._adoptNode(nodeImpl);\n\n      this._insert(nodeImpl, referenceChildImpl);\n\n      return nodeImpl;\n    } // https://dom.spec.whatwg.org/#concept-node-insert\n\n  }, {\n    key: \"_insert\",\n    value: function _insert(nodeImpl, childImpl, suppressObservers) {\n      var count = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? domSymbolTree.childrenCount(nodeImpl) : 1;\n\n      if (childImpl) {\n        var childIndex = domSymbolTree.index(childImpl);\n\n        var _iterator12 = _createForOfIteratorHelper(this._referencedRanges),\n            _step12;\n\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var range = _step12.value;\n            var _start = range._start,\n                _end = range._end;\n\n            if (_start.offset > childIndex) {\n              range._setLiveRangeStart(this, _start.offset + count);\n            }\n\n            if (_end.offset > childIndex) {\n              range._setLiveRangeEnd(this, _end.offset + count);\n            }\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n      }\n\n      var nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? domSymbolTree.childrenToArray(nodeImpl) : [nodeImpl];\n\n      if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n        var grandChildImpl;\n\n        while (grandChildImpl = domSymbolTree.firstChild(nodeImpl)) {\n          nodeImpl._remove(grandChildImpl, true);\n        }\n      }\n\n      if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n        queueTreeMutationRecord(nodeImpl, [], nodesImpl, null, null);\n      }\n\n      var previousChildImpl = childImpl ? domSymbolTree.previousSibling(childImpl) : domSymbolTree.lastChild(this);\n\n      var _iterator13 = _createForOfIteratorHelper(nodesImpl),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var node = _step13.value;\n\n          if (!childImpl) {\n            domSymbolTree.appendChild(this, node);\n          } else {\n            domSymbolTree.insertBefore(childImpl, node);\n          }\n\n          if (this.nodeType === NODE_TYPE.ELEMENT_NODE && this._shadowRoot !== null && (node.nodeType === NODE_TYPE.ELEMENT_NODE || node.nodeType === NODE_TYPE.TEXT_NODE)) {\n            assignSlot(node);\n          }\n\n          this._modified();\n\n          if (node.nodeType === NODE_TYPE.TEXT_NODE || node.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n            this._childTextContentChangeSteps();\n          }\n\n          if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(nodeRoot(this))) {\n            signalSlotChange(this);\n          }\n\n          var root = nodeRoot(node);\n\n          if (isShadowRoot(root)) {\n            assignSlotableForTree(root);\n          }\n\n          if (this._attached && nodeImpl._attach) {\n            node._attach();\n          }\n\n          this._descendantAdded(this, node);\n\n          var _iterator14 = _createForOfIteratorHelper(shadowIncludingInclusiveDescendantsIterator(node)),\n              _step14;\n\n          try {\n            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n              var inclusiveDescendant = _step14.value;\n\n              if (inclusiveDescendant.isConnected) {\n                if (inclusiveDescendant._ceState === \"custom\") {\n                  enqueueCECallbackReaction(inclusiveDescendant, \"connectedCallback\", []);\n                } else {\n                  tryUpgradeElement(inclusiveDescendant);\n                }\n              }\n            }\n          } catch (err) {\n            _iterator14.e(err);\n          } finally {\n            _iterator14.f();\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      if (!suppressObservers) {\n        queueTreeMutationRecord(this, nodesImpl, [], previousChildImpl, childImpl);\n      }\n    } // https://dom.spec.whatwg.org/#concept-node-append\n\n  }, {\n    key: \"_append\",\n    value: function _append(nodeImpl) {\n      return this._preInsert(nodeImpl, null);\n    } // https://dom.spec.whatwg.org/#concept-node-replace\n\n  }, {\n    key: \"_replace\",\n    value: function _replace(nodeImpl, childImpl) {\n      var nodeType = nodeImpl.nodeType,\n          nodeName = nodeImpl.nodeName;\n      var parentType = this.nodeType,\n          parentName = this.nodeName; // Note: This section differs from the pre-insert validation algorithm.\n\n      if (parentType !== NODE_TYPE.DOCUMENT_NODE && parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && parentType !== NODE_TYPE.ELEMENT_NODE) {\n        throw DOMException.create(this._globalObject, [\"Node can't be inserted in a \".concat(parentName, \" parent.\"), \"HierarchyRequestError\"]);\n      }\n\n      if (isHostInclusiveAncestor(nodeImpl, this)) {\n        throw DOMException.create(this._globalObject, [\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\"]);\n      }\n\n      if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n        throw DOMException.create(this._globalObject, [\"The child can not be found in the parent.\", \"NotFoundError\"]);\n      }\n\n      if (nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE && nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE && nodeType !== NODE_TYPE.ELEMENT_NODE && nodeType !== NODE_TYPE.TEXT_NODE && nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n      nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE && nodeType !== NODE_TYPE.COMMENT_NODE) {\n        throw DOMException.create(this._globalObject, [\"\".concat(nodeName, \" node can't be inserted in parent node.\"), \"HierarchyRequestError\"]);\n      }\n\n      if (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE || nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE) {\n        throw DOMException.create(this._globalObject, [\"\".concat(nodeName, \" node can't be inserted in \").concat(parentName, \" parent.\"), \"HierarchyRequestError\"]);\n      }\n\n      if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n        var nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n        var parentChildren = domSymbolTree.childrenToArray(this);\n\n        switch (nodeType) {\n          case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n            {\n              var nodeChildrenElements = nodeChildren.filter(function (child) {\n                return child.nodeType === NODE_TYPE.ELEMENT_NODE;\n              });\n\n              if (nodeChildrenElements.length > 1) {\n                throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n              }\n\n              var hasNodeTextChildren = nodeChildren.some(function (child) {\n                return child.nodeType === NODE_TYPE.TEXT_NODE;\n              });\n\n              if (hasNodeTextChildren) {\n                throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n              }\n\n              var parentChildElements = parentChildren.filter(function (child) {\n                return child.nodeType === NODE_TYPE.ELEMENT_NODE;\n              });\n\n              if (nodeChildrenElements.length === 1 && (parentChildElements.length === 1 && parentChildElements[0] !== childImpl || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE)) {\n                throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n              }\n\n              break;\n            }\n\n          case NODE_TYPE.ELEMENT_NODE:\n            if (parentChildren.some(function (child) {\n              return child.nodeType === NODE_TYPE.ELEMENT_NODE && child !== childImpl;\n            }) || childImpl && domSymbolTree.nextSibling(childImpl) && domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n              throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n            }\n\n            break;\n\n          case NODE_TYPE.DOCUMENT_TYPE_NODE:\n            if (parentChildren.some(function (child) {\n              return child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && child !== childImpl;\n            }) || childImpl && domSymbolTree.previousSibling(childImpl) && domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE) {\n              throw DOMException.create(this._globalObject, [\"Invalid insertion of \".concat(nodeName, \" node in \").concat(parentName, \" node.\"), \"HierarchyRequestError\"]);\n            }\n\n            break;\n        }\n      }\n\n      var referenceChildImpl = domSymbolTree.nextSibling(childImpl);\n\n      if (referenceChildImpl === nodeImpl) {\n        referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n      }\n\n      var previousSiblingImpl = domSymbolTree.previousSibling(childImpl);\n\n      this._ownerDocument._adoptNode(nodeImpl);\n\n      var removedNodesImpl = [];\n\n      if (domSymbolTree.parent(childImpl)) {\n        removedNodesImpl = [childImpl];\n\n        this._remove(childImpl, true);\n      }\n\n      var nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? domSymbolTree.childrenToArray(nodeImpl) : [nodeImpl];\n\n      this._insert(nodeImpl, referenceChildImpl, true);\n\n      queueTreeMutationRecord(this, nodesImpl, removedNodesImpl, previousSiblingImpl, referenceChildImpl);\n      return childImpl;\n    } // https://dom.spec.whatwg.org/#concept-node-replace-all\n\n  }, {\n    key: \"_replaceAll\",\n    value: function _replaceAll(nodeImpl) {\n      if (nodeImpl !== null) {\n        this._ownerDocument._adoptNode(nodeImpl);\n      }\n\n      var removedNodesImpl = domSymbolTree.childrenToArray(this);\n      var addedNodesImpl;\n\n      if (nodeImpl === null) {\n        addedNodesImpl = [];\n      } else if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n        addedNodesImpl = domSymbolTree.childrenToArray(nodeImpl);\n      } else {\n        addedNodesImpl = [nodeImpl];\n      }\n\n      var _iterator15 = _createForOfIteratorHelper(domSymbolTree.childrenIterator(this)),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var childImpl = _step15.value;\n\n          this._remove(childImpl, true);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n\n      if (nodeImpl !== null) {\n        this._insert(nodeImpl, null, true);\n      }\n\n      if (addedNodesImpl.length > 0 || removedNodesImpl.length > 0) {\n        queueTreeMutationRecord(this, addedNodesImpl, removedNodesImpl, null, null);\n      }\n    } // https://dom.spec.whatwg.org/#concept-node-pre-remove\n\n  }, {\n    key: \"_preRemove\",\n    value: function _preRemove(childImpl) {\n      if (domSymbolTree.parent(childImpl) !== this) {\n        throw DOMException.create(this._globalObject, [\"The node to be removed is not a child of this node.\", \"NotFoundError\"]);\n      }\n\n      this._remove(childImpl);\n\n      return childImpl;\n    } // https://dom.spec.whatwg.org/#concept-node-remove\n\n  }, {\n    key: \"_remove\",\n    value: function _remove(nodeImpl, suppressObservers) {\n      var index = domSymbolTree.index(nodeImpl);\n\n      var _iterator16 = _createForOfIteratorHelper(domSymbolTree.treeIterator(nodeImpl)),\n          _step16;\n\n      try {\n        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n          var descendant = _step16.value;\n\n          var _iterator20 = _createForOfIteratorHelper(descendant._referencedRanges),\n              _step20;\n\n          try {\n            for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n              var range = _step20.value;\n              var _start = range._start,\n                  _end = range._end;\n\n              if (_start.node === descendant) {\n                range._setLiveRangeStart(this, index);\n              }\n\n              if (_end.node === descendant) {\n                range._setLiveRangeEnd(this, index);\n              }\n            }\n          } catch (err) {\n            _iterator20.e(err);\n          } finally {\n            _iterator20.f();\n          }\n        }\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n\n      var _iterator17 = _createForOfIteratorHelper(this._referencedRanges),\n          _step17;\n\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var _range = _step17.value;\n          var _start2 = _range._start,\n              _end2 = _range._end;\n\n          if (_start2.node === this && _start2.offset > index) {\n            _range._setLiveRangeStart(this, _start2.offset - 1);\n          }\n\n          if (_end2.node === this && _end2.offset > index) {\n            _range._setLiveRangeEnd(this, _end2.offset - 1);\n          }\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n\n      if (this._ownerDocument) {\n        this._ownerDocument._runPreRemovingSteps(nodeImpl);\n      }\n\n      var oldPreviousSiblingImpl = domSymbolTree.previousSibling(nodeImpl);\n      var oldNextSiblingImpl = domSymbolTree.nextSibling(nodeImpl);\n      domSymbolTree.remove(nodeImpl);\n\n      if (nodeImpl._assignedSlot) {\n        assignSlotable(nodeImpl._assignedSlot);\n      }\n\n      if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(nodeRoot(this))) {\n        signalSlotChange(this);\n      }\n\n      var hasSlotDescendant = isSlot(nodeImpl);\n\n      if (!hasSlotDescendant) {\n        var _iterator18 = _createForOfIteratorHelper(domSymbolTree.treeIterator(nodeImpl)),\n            _step18;\n\n        try {\n          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n            var child = _step18.value;\n\n            if (isSlot(child)) {\n              hasSlotDescendant = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator18.e(err);\n        } finally {\n          _iterator18.f();\n        }\n      }\n\n      if (hasSlotDescendant) {\n        assignSlotableForTree(nodeRoot(this));\n        assignSlotableForTree(nodeImpl);\n      }\n\n      this._modified();\n\n      nodeImpl._detach();\n\n      this._descendantRemoved(this, nodeImpl);\n\n      if (this.isConnected) {\n        if (nodeImpl._ceState === \"custom\") {\n          enqueueCECallbackReaction(nodeImpl, \"disconnectedCallback\", []);\n        }\n\n        var _iterator19 = _createForOfIteratorHelper(shadowIncludingDescendantsIterator(nodeImpl)),\n            _step19;\n\n        try {\n          for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n            var descendantImpl = _step19.value;\n\n            if (descendantImpl._ceState === \"custom\") {\n              enqueueCECallbackReaction(descendantImpl, \"disconnectedCallback\", []);\n            }\n          }\n        } catch (err) {\n          _iterator19.e(err);\n        } finally {\n          _iterator19.f();\n        }\n      }\n\n      if (!suppressObservers) {\n        queueTreeMutationRecord(this, [], [nodeImpl], oldPreviousSiblingImpl, oldNextSiblingImpl);\n      }\n\n      if (nodeImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n        this._childTextContentChangeSteps();\n      }\n    }\n  }]);\n\n  return NodeImpl;\n}(EventTargetImpl);\n\nmodule.exports = {\n  implementation: NodeImpl\n};","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/node_modules/jsdom/lib/jsdom/living/nodes/Node-impl.js"],"names":["DOMException","require","EventTargetImpl","implementation","simultaneousIterators","NODE_TYPE","NODE_DOCUMENT_POSITION","clone","locateNamespacePrefix","locateNamespace","setAnExistingAttributeValue","NodeList","nodeRoot","nodeLength","domSymbolTree","documentBaseURLSerialized","queueTreeMutationRecord","enqueueCECallbackReaction","tryUpgradeElement","isShadowRoot","shadowIncludingRoot","assignSlot","assignSlotableForTree","assignSlotable","signalSlotChange","isSlot","shadowIncludingInclusiveDescendantsIterator","shadowIncludingDescendantsIterator","isObsoleteNodeType","node","nodeType","ENTITY_NODE","ENTITY_REFERENCE_NODE","NOTATION_NODE","CDATA_SECTION_NODE","nodeEquals","a","b","DOCUMENT_TYPE_NODE","name","publicId","systemId","ELEMENT_NODE","_namespaceURI","_prefix","_localName","_attributes","length","ATTRIBUTE_NODE","_namespace","_value","PROCESSING_INSTRUCTION_NODE","_target","_data","TEXT_NODE","COMMENT_NODE","attributeListsEqual","childrenIterator","nodes","elementA","elementB","listA","_attributeList","listB","lengthA","lengthB","i","attrA","some","attrB","isHostInclusiveAncestor","nodeImplA","nodeImplB","ancestorsIterator","ancestor","rootImplB","_host","NodeImpl","globalObject","args","privateData","initialize","_ownerDocument","ownerDocument","_childNodesList","_childrenList","_version","_memoizedQueries","_registeredObserverList","_referencedRanges","Set","_assignedSlot","parent","options","composed","tagName","_qualifiedName","target","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","firstChild","root","lastChild","createImpl","_globalObject","element","query","childrenToArray","_update","nextSibling","previousSibling","_clearMemoizedQueries","myParent","child","_descendantRemoved","_descendantAdded","_attached","_attach","_lastFocusedElement","_detach","hasChildren","treeToArray","parentNode","_remove","continuousExclusiveTextNodes","previousSiblingsIterator","currentNode","unshift","nextSiblingsIterator","push","data","reduce","d","n","replaceData","currentNodeParent","currentNodeIndex","index","range","_start","_end","_setLiveRangeStart","offset","_setLiveRangeEnd","continuousExclusiveTextNode","other","node1","node2","Error","attr1","attr2","_element","attr","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","result","compareTreePosition","DOCUMENT_POSITION_DISCONNECTED","namespace","documentElement","parentElement","prefix","defaultNamespace","Boolean","compareDocumentPosition","DOCUMENT_POSITION_CONTAINED_BY","deep","create","undefined","value","text","treeIterator","nodeValue","nodeImpl","createTextNode","_replaceAll","childImpl","_preInsert","_append","_replace","oldChildImpl","_preRemove","nodeName","parentType","parentName","nodeChildren","parentChildren","nodeChildrenElements","filter","hasNodeTextChildren","_preInsertValidity","referenceChildImpl","_adoptNode","_insert","suppressObservers","count","childrenCount","childIndex","nodesImpl","grandChildImpl","previousChildImpl","appendChild","insertBefore","_shadowRoot","_modified","_childTextContentChangeSteps","_assignedNodes","inclusiveDescendant","isConnected","_ceState","parentChildElements","previousSiblingImpl","removedNodesImpl","addedNodesImpl","descendant","_runPreRemovingSteps","oldPreviousSiblingImpl","oldNextSiblingImpl","remove","hasSlotDescendant","descendantImpl","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\nconst { simultaneousIterators } = require(\"../../utils\");\nconst NODE_TYPE = require(\"../node-type\");\nconst NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\nconst { clone, locateNamespacePrefix, locateNamespace } = require(\"../node\");\nconst { setAnExistingAttributeValue } = require(\"../attributes\");\n\nconst NodeList = require(\"../generated/NodeList\");\n\nconst { nodeRoot, nodeLength } = require(\"../helpers/node\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst { documentBaseURLSerialized } = require(\"../helpers/document-base-url\");\nconst { queueTreeMutationRecord } = require(\"../helpers/mutation-observers\");\nconst { enqueueCECallbackReaction, tryUpgradeElement } = require(\"../helpers/custom-elements\");\nconst {\n  isShadowRoot, shadowIncludingRoot, assignSlot, assignSlotableForTree, assignSlotable, signalSlotChange, isSlot,\n  shadowIncludingInclusiveDescendantsIterator, shadowIncludingDescendantsIterator\n} = require(\"../helpers/shadow-dom\");\n\nfunction isObsoleteNodeType(node) {\n  return node.nodeType === NODE_TYPE.ENTITY_NODE ||\n    node.nodeType === NODE_TYPE.ENTITY_REFERENCE_NODE ||\n    node.nodeType === NODE_TYPE.NOTATION_NODE ||\n    node.nodeType === NODE_TYPE.CDATA_SECTION_NODE;\n}\n\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId ||\n          a.systemId !== b.systemId) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName ||\n          a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.ATTRIBUTE_NODE:\n      if (a._namespace !== b._namespace || a._localName !== b._localName || a._value !== b._value) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n      break;\n  }\n\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributeListsEqual(a, b)) {\n    return false;\n  }\n\n  for (const nodes of simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))) {\n    if (!nodes[0] || !nodes[1]) {\n      // mismatch in the amount of childNodes\n      return false;\n    }\n\n    if (!nodeEquals(nodes[0], nodes[1])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Needed by https://dom.spec.whatwg.org/#concept-node-equals\nfunction attributeListsEqual(elementA, elementB) {\n  const listA = elementA._attributeList;\n  const listB = elementB._attributeList;\n\n  const lengthA = listA.length;\n  const lengthB = listB.length;\n\n  if (lengthA !== lengthB) {\n    return false;\n  }\n\n  for (let i = 0; i < lengthA; ++i) {\n    const attrA = listA[i];\n\n    if (!listB.some(attrB => nodeEquals(attrA, attrB))) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// https://dom.spec.whatwg.org/#concept-tree-host-including-inclusive-ancestor\nfunction isHostInclusiveAncestor(nodeImplA, nodeImplB) {\n  for (const ancestor of domSymbolTree.ancestorsIterator(nodeImplB)) {\n    if (ancestor === nodeImplA) {\n      return true;\n    }\n  }\n\n  const rootImplB = nodeRoot(nodeImplB);\n  if (rootImplB._host) {\n    return isHostInclusiveAncestor(nodeImplA, rootImplB._host);\n  }\n\n  return false;\n}\n\nclass NodeImpl extends EventTargetImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n\n    domSymbolTree.initialize(this);\n\n    this._ownerDocument = privateData.ownerDocument;\n\n    this._childNodesList = null;\n    this._childrenList = null;\n    this._version = 0;\n    this._memoizedQueries = {};\n    this._registeredObserverList = [];\n    this._referencedRanges = new Set();\n  }\n\n  _getTheParent() {\n    if (this._assignedSlot) {\n      return this._assignedSlot;\n    }\n\n    return domSymbolTree.parent(this);\n  }\n\n  get parentNode() {\n    return domSymbolTree.parent(this);\n  }\n\n  getRootNode(options) {\n    return options.composed ? shadowIncludingRoot(this) : nodeRoot(this);\n  }\n\n  get nodeName() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        return this.tagName;\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        return this._qualifiedName;\n      case NODE_TYPE.TEXT_NODE:\n        return \"#text\";\n      case NODE_TYPE.CDATA_SECTION_NODE:\n        return \"#cdata-section\";\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        return this.target;\n      case NODE_TYPE.COMMENT_NODE:\n        return \"#comment\";\n      case NODE_TYPE.DOCUMENT_NODE:\n        return \"#document\";\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        return this.name;\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        return \"#document-fragment\";\n    }\n\n    // should never happen\n    return null;\n  }\n\n  get firstChild() {\n    return domSymbolTree.firstChild(this);\n  }\n\n  // https://dom.spec.whatwg.org/#connected\n  // https://dom.spec.whatwg.org/#dom-node-isconnected\n  get isConnected() {\n    const root = shadowIncludingRoot(this);\n    return root && root.nodeType === NODE_TYPE.DOCUMENT_NODE;\n  }\n\n  get ownerDocument() {\n    return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n  }\n\n  get lastChild() {\n    return domSymbolTree.lastChild(this);\n  }\n\n  get childNodes() {\n    if (!this._childNodesList) {\n      this._childNodesList = NodeList.createImpl(this._globalObject, [], {\n        element: this,\n        query: () => domSymbolTree.childrenToArray(this)\n      });\n    } else {\n      this._childNodesList._update();\n    }\n\n    return this._childNodesList;\n  }\n\n  get nextSibling() {\n    return domSymbolTree.nextSibling(this);\n  }\n\n  get previousSibling() {\n    return domSymbolTree.previousSibling(this);\n  }\n\n  _modified() {\n    this._version++;\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      ancestor._version++;\n    }\n\n    if (this._childrenList) {\n      this._childrenList._update();\n    }\n    if (this._childNodesList) {\n      this._childNodesList._update();\n    }\n    this._clearMemoizedQueries();\n  }\n\n  _childTextContentChangeSteps() {\n    // Default: do nothing\n  }\n\n  _clearMemoizedQueries() {\n    this._memoizedQueries = {};\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._clearMemoizedQueries();\n    }\n  }\n\n  _descendantRemoved(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantRemoved(parent, child);\n    }\n  }\n\n  _descendantAdded(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantAdded(parent, child);\n    }\n  }\n\n  _attach() {\n    this._attached = true;\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._attach) {\n        child._attach();\n      }\n    }\n  }\n\n  _detach() {\n    this._attached = false;\n\n    if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n      this._ownerDocument._lastFocusedElement = null;\n    }\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._detach) {\n        child._detach();\n      }\n    }\n  }\n\n  hasChildNodes() {\n    return domSymbolTree.hasChildren(this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-normalize\n  normalize() {\n    // It is important to use a treeToArray instead of a treeToIterator here, because the\n    // treeToIterator doesn't support tree mutation in the middle of the traversal.\n    for (const node of domSymbolTree.treeToArray(this)) {\n      const parentNode = domSymbolTree.parent(node);\n      if (parentNode === null || node.nodeType !== NODE_TYPE.TEXT_NODE) {\n        continue;\n      }\n\n      let length = nodeLength(node);\n\n      if (length === 0) {\n        parentNode._remove(node);\n        continue;\n      }\n\n      const continuousExclusiveTextNodes = [];\n\n      for (const currentNode of domSymbolTree.previousSiblingsIterator(node)) {\n        if (currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n          break;\n        }\n\n        continuousExclusiveTextNodes.unshift(currentNode);\n      }\n      for (const currentNode of domSymbolTree.nextSiblingsIterator(node)) {\n        if (currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n          break;\n        }\n\n        continuousExclusiveTextNodes.push(currentNode);\n      }\n\n      const data = continuousExclusiveTextNodes.reduce((d, n) => d + n._data, \"\");\n      node.replaceData(length, 0, data);\n\n      let currentNode = domSymbolTree.nextSibling(node);\n      while (currentNode && currentNode.nodeType !== NODE_TYPE.TEXT_NODE) {\n        const currentNodeParent = domSymbolTree.parent(currentNode);\n        const currentNodeIndex = domSymbolTree.index(currentNode);\n\n        for (const range of node._referencedRanges) {\n          const { _start, _end } = range;\n\n          if (_start.node === currentNode) {\n            range._setLiveRangeStart(node, _start.offset + length);\n          }\n          if (_end.node === currentNode) {\n            range._setLiveRangeEnd(node, _end.offset + length);\n          }\n          if (_start.node === currentNodeParent && _start.offset === currentNodeIndex) {\n            range._setLiveRangeStart(node, length);\n          }\n          if (_end.node === currentNodeParent && _end.offset === currentNodeIndex) {\n            range._setLiveRangeStart(node, length);\n          }\n        }\n\n        length += nodeLength(currentNode);\n        currentNode = domSymbolTree.nextSibling(currentNode);\n      }\n\n      for (const continuousExclusiveTextNode of continuousExclusiveTextNodes) {\n        parentNode._remove(continuousExclusiveTextNode);\n      }\n    }\n  }\n\n  get parentElement() {\n    const parentNode = domSymbolTree.parent(this);\n    return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n  }\n\n  get baseURI() {\n    return documentBaseURLSerialized(this._ownerDocument);\n  }\n\n  compareDocumentPosition(other) {\n    // Let node1 be other and node2 be the context object.\n    let node1 = other;\n    let node2 = this;\n\n    if (isObsoleteNodeType(node2) || isObsoleteNodeType(node1)) {\n      throw new Error(\"Obsolete node type\");\n    }\n\n    let attr1 = null;\n    let attr2 = null;\n\n    if (node1.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      attr1 = node1;\n      node1 = attr1._element;\n    }\n\n    if (node2.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      attr2 = node2;\n      node2 = attr2._element;\n\n      if (attr1 !== null && node1 !== null && node2 === node1) {\n        for (const attr of node2._attributeList) {\n          if (nodeEquals(attr, attr1)) {\n            return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n              NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_PRECEDING;\n          }\n\n          if (nodeEquals(attr, attr2)) {\n            return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n              NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n          }\n        }\n      }\n    }\n\n    const result = domSymbolTree.compareTreePosition(node2, node1);\n\n    // “If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n    // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.”\n    if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n      // symbol-tree does not add these bits required by the spec:\n      return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    return result;\n  }\n\n  lookupPrefix(namespace) {\n    if (namespace === null || namespace === \"\") {\n      return null;\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE: {\n        return locateNamespacePrefix(this, namespace);\n      }\n      case NODE_TYPE.DOCUMENT_NODE: {\n        return this.documentElement !== null ? locateNamespacePrefix(this.documentElement, namespace) : null;\n      }\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE: {\n        return null;\n      }\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._element !== null ? locateNamespacePrefix(this._element, namespace) : null;\n      }\n      default: {\n        return this.parentElement !== null ? locateNamespacePrefix(this.parentElement, namespace) : null;\n      }\n    }\n  }\n\n  lookupNamespaceURI(prefix) {\n    if (prefix === \"\") {\n      prefix = null;\n    }\n\n    return locateNamespace(this, prefix);\n  }\n\n  isDefaultNamespace(namespace) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    const defaultNamespace = locateNamespace(this, null);\n    return defaultNamespace === namespace;\n  }\n\n  contains(other) {\n    if (other === null) {\n      return false;\n    } else if (this === other) {\n      return true;\n    }\n    return Boolean(this.compareDocumentPosition(other) & NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n\n  isEqualNode(node) {\n    if (node === null) {\n      return false;\n    }\n\n    // Fast-path, not in the spec\n    if (this === node) {\n      return true;\n    }\n\n    return nodeEquals(this, node);\n  }\n\n  isSameNode(node) {\n    if (this === node) {\n      return true;\n    }\n\n    return false;\n  }\n\n  cloneNode(deep) {\n    if (isShadowRoot(this)) {\n      throw DOMException.create(this._globalObject, [\"ShadowRoot nodes are not clonable.\", \"NotSupportedError\"]);\n    }\n\n    deep = Boolean(deep);\n\n    return clone(this, undefined, deep);\n  }\n\n  get nodeValue() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._value;\n      }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        return this._data;\n      }\n      default: {\n        return null;\n      }\n    }\n  }\n\n  set nodeValue(value) {\n    if (value === null) {\n      value = \"\";\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        setAnExistingAttributeValue(this, value);\n        break;\n      }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        this.replaceData(0, this.length, value);\n        break;\n      }\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-textcontent\n  get textContent() {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE: {\n        let text = \"\";\n        for (const child of domSymbolTree.treeIterator(this)) {\n          if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n            text += child.nodeValue;\n          }\n        }\n        return text;\n      }\n\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._value;\n      }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        return this._data;\n      }\n\n      default: {\n        return null;\n      }\n    }\n  }\n  set textContent(value) {\n    if (value === null) {\n      value = \"\";\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE: {\n        // https://dom.spec.whatwg.org/#string-replace-all\n        let nodeImpl = null;\n\n        if (value !== \"\") {\n          nodeImpl = this._ownerDocument.createTextNode(value);\n        }\n\n        this._replaceAll(nodeImpl);\n        break;\n      }\n\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        setAnExistingAttributeValue(this, value);\n        break;\n      }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        this.replaceData(0, this.length, value);\n        break;\n      }\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-insertbefore\n  insertBefore(nodeImpl, childImpl) {\n    return this._preInsert(nodeImpl, childImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-appendchild\n  appendChild(nodeImpl) {\n    return this._append(nodeImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-replacechild\n  replaceChild(nodeImpl, childImpl) {\n    return this._replace(nodeImpl, childImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-node-removechild\n  removeChild(oldChildImpl) {\n    return this._preRemove(oldChildImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n  _preInsertValidity(nodeImpl, childImpl) {\n    const { nodeType, nodeName } = nodeImpl;\n    const { nodeType: parentType, nodeName: parentName } = this;\n\n    if (\n      parentType !== NODE_TYPE.DOCUMENT_NODE &&\n      parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      parentType !== NODE_TYPE.ELEMENT_NODE\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `Node can't be inserted in a ${parentName} parent.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (isHostInclusiveAncestor(nodeImpl, this)) {\n      throw DOMException.create(this._globalObject, [\n        \"The operation would yield an incorrect node tree.\",\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n      throw DOMException.create(this._globalObject, [\n        \"The child can not be found in the parent.\",\n        \"NotFoundError\"\n      ]);\n    }\n\n    if (\n      nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE &&\n      nodeType !== NODE_TYPE.ELEMENT_NODE &&\n      nodeType !== NODE_TYPE.TEXT_NODE &&\n      nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n      nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE &&\n      nodeType !== NODE_TYPE.COMMENT_NODE\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `${nodeName} node can't be inserted in parent node.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (\n      (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE) ||\n      (nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE)\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `${nodeName} node can't be inserted in ${parentName} parent.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n      const nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n      const parentChildren = domSymbolTree.childrenToArray(this);\n\n      switch (nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE: {\n          const nodeChildrenElements = nodeChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n          if (nodeChildrenElements.length > 1) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n\n          const hasNodeTextChildren = nodeChildren.some(child => child.nodeType === NODE_TYPE.TEXT_NODE);\n          if (hasNodeTextChildren) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n\n          if (\n            nodeChildrenElements.length === 1 &&\n            (\n              parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE) ||\n              (childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) ||\n              (\n                childImpl &&\n                domSymbolTree.nextSibling(childImpl) &&\n                domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n              )\n            )\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n        }\n\n        case NODE_TYPE.ELEMENT_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE) ||\n            (childImpl && childImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) ||\n            (\n              childImpl &&\n              domSymbolTree.nextSibling(childImpl) &&\n              domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n            )\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) ||\n            (\n              childImpl &&\n              domSymbolTree.previousSibling(childImpl) &&\n              domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE\n            ) ||\n            (!childImpl && parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE))\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n      }\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-pre-insert\n  _preInsert(nodeImpl, childImpl) {\n    this._preInsertValidity(nodeImpl, childImpl);\n\n    let referenceChildImpl = childImpl;\n    if (referenceChildImpl === nodeImpl) {\n      referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n    }\n\n    this._ownerDocument._adoptNode(nodeImpl);\n\n    this._insert(nodeImpl, referenceChildImpl);\n\n    return nodeImpl;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-insert\n  _insert(nodeImpl, childImpl, suppressObservers) {\n    const count = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ?\n        domSymbolTree.childrenCount(nodeImpl) :\n        1;\n\n    if (childImpl) {\n      const childIndex = domSymbolTree.index(childImpl);\n\n      for (const range of this._referencedRanges) {\n        const { _start, _end } = range;\n\n        if (_start.offset > childIndex) {\n          range._setLiveRangeStart(this, _start.offset + count);\n        }\n\n        if (_end.offset > childIndex) {\n          range._setLiveRangeEnd(this, _end.offset + count);\n        }\n      }\n    }\n\n    const nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ?\n      domSymbolTree.childrenToArray(nodeImpl) :\n      [nodeImpl];\n\n    if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      let grandChildImpl;\n      while ((grandChildImpl = domSymbolTree.firstChild(nodeImpl))) {\n        nodeImpl._remove(grandChildImpl, true);\n      }\n    }\n\n    if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      queueTreeMutationRecord(nodeImpl, [], nodesImpl, null, null);\n    }\n\n    const previousChildImpl = childImpl ?\n      domSymbolTree.previousSibling(childImpl) :\n      domSymbolTree.lastChild(this);\n\n    for (const node of nodesImpl) {\n      if (!childImpl) {\n        domSymbolTree.appendChild(this, node);\n      } else {\n        domSymbolTree.insertBefore(childImpl, node);\n      }\n\n      if (\n        (this.nodeType === NODE_TYPE.ELEMENT_NODE && this._shadowRoot !== null) &&\n        (node.nodeType === NODE_TYPE.ELEMENT_NODE || node.nodeType === NODE_TYPE.TEXT_NODE)\n      ) {\n        assignSlot(node);\n      }\n\n      this._modified();\n\n      if (node.nodeType === NODE_TYPE.TEXT_NODE ||\n          node.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n        this._childTextContentChangeSteps();\n      }\n\n      if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(nodeRoot(this))) {\n        signalSlotChange(this);\n      }\n\n      const root = nodeRoot(node);\n      if (isShadowRoot(root)) {\n        assignSlotableForTree(root);\n      }\n\n      if (this._attached && nodeImpl._attach) {\n        node._attach();\n      }\n\n      this._descendantAdded(this, node);\n\n      for (const inclusiveDescendant of shadowIncludingInclusiveDescendantsIterator(node)) {\n        if (inclusiveDescendant.isConnected) {\n          if (inclusiveDescendant._ceState === \"custom\") {\n            enqueueCECallbackReaction(inclusiveDescendant, \"connectedCallback\", []);\n          } else {\n            tryUpgradeElement(inclusiveDescendant);\n          }\n        }\n      }\n    }\n\n    if (!suppressObservers) {\n      queueTreeMutationRecord(this, nodesImpl, [], previousChildImpl, childImpl);\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-append\n  _append(nodeImpl) {\n    return this._preInsert(nodeImpl, null);\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-replace\n  _replace(nodeImpl, childImpl) {\n    const { nodeType, nodeName } = nodeImpl;\n    const { nodeType: parentType, nodeName: parentName } = this;\n\n    // Note: This section differs from the pre-insert validation algorithm.\n    if (\n      parentType !== NODE_TYPE.DOCUMENT_NODE &&\n      parentType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      parentType !== NODE_TYPE.ELEMENT_NODE\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `Node can't be inserted in a ${parentName} parent.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (isHostInclusiveAncestor(nodeImpl, this)) {\n      throw DOMException.create(this._globalObject, [\n        \"The operation would yield an incorrect node tree.\",\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (childImpl && domSymbolTree.parent(childImpl) !== this) {\n      throw DOMException.create(this._globalObject, [\n        \"The child can not be found in the parent.\",\n        \"NotFoundError\"\n      ]);\n    }\n\n    if (\n      nodeType !== NODE_TYPE.DOCUMENT_FRAGMENT_NODE &&\n      nodeType !== NODE_TYPE.DOCUMENT_TYPE_NODE &&\n      nodeType !== NODE_TYPE.ELEMENT_NODE &&\n      nodeType !== NODE_TYPE.TEXT_NODE &&\n      nodeType !== NODE_TYPE.CDATA_SECTION_NODE && // CData section extends from Text\n      nodeType !== NODE_TYPE.PROCESSING_INSTRUCTION_NODE &&\n      nodeType !== NODE_TYPE.COMMENT_NODE\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `${nodeName} node can't be inserted in parent node.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (\n      (nodeType === NODE_TYPE.TEXT_NODE && parentType === NODE_TYPE.DOCUMENT_NODE) ||\n      (nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && parentType !== NODE_TYPE.DOCUMENT_NODE)\n    ) {\n      throw DOMException.create(this._globalObject, [\n        `${nodeName} node can't be inserted in ${parentName} parent.`,\n        \"HierarchyRequestError\"\n      ]);\n    }\n\n    if (parentType === NODE_TYPE.DOCUMENT_NODE) {\n      const nodeChildren = domSymbolTree.childrenToArray(nodeImpl);\n      const parentChildren = domSymbolTree.childrenToArray(this);\n\n      switch (nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE: {\n          const nodeChildrenElements = nodeChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n          if (nodeChildrenElements.length > 1) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n\n          const hasNodeTextChildren = nodeChildren.some(child => child.nodeType === NODE_TYPE.TEXT_NODE);\n          if (hasNodeTextChildren) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n\n\n          const parentChildElements = parentChildren.filter(child => child.nodeType === NODE_TYPE.ELEMENT_NODE);\n          if (\n            nodeChildrenElements.length === 1 &&\n            (\n              (parentChildElements.length === 1 && parentChildElements[0] !== childImpl) ||\n              (\n                childImpl &&\n                domSymbolTree.nextSibling(childImpl) &&\n                domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n              )\n            )\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n        }\n\n        case NODE_TYPE.ELEMENT_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.ELEMENT_NODE && child !== childImpl) ||\n            (\n              childImpl &&\n              domSymbolTree.nextSibling(childImpl) &&\n              domSymbolTree.nextSibling(childImpl).nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE\n            )\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          if (\n            parentChildren.some(child => child.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE && child !== childImpl) ||\n            (\n              childImpl &&\n              domSymbolTree.previousSibling(childImpl) &&\n              domSymbolTree.previousSibling(childImpl).nodeType === NODE_TYPE.ELEMENT_NODE\n            )\n          ) {\n            throw DOMException.create(this._globalObject, [\n              `Invalid insertion of ${nodeName} node in ${parentName} node.`,\n              \"HierarchyRequestError\"\n            ]);\n          }\n          break;\n      }\n    }\n\n    let referenceChildImpl = domSymbolTree.nextSibling(childImpl);\n    if (referenceChildImpl === nodeImpl) {\n      referenceChildImpl = domSymbolTree.nextSibling(nodeImpl);\n    }\n\n    const previousSiblingImpl = domSymbolTree.previousSibling(childImpl);\n\n    this._ownerDocument._adoptNode(nodeImpl);\n\n    let removedNodesImpl = [];\n\n    if (domSymbolTree.parent(childImpl)) {\n      removedNodesImpl = [childImpl];\n      this._remove(childImpl, true);\n    }\n\n    const nodesImpl = nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ?\n      domSymbolTree.childrenToArray(nodeImpl) :\n      [nodeImpl];\n\n    this._insert(nodeImpl, referenceChildImpl, true);\n\n    queueTreeMutationRecord(this, nodesImpl, removedNodesImpl, previousSiblingImpl, referenceChildImpl);\n\n    return childImpl;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-replace-all\n  _replaceAll(nodeImpl) {\n    if (nodeImpl !== null) {\n      this._ownerDocument._adoptNode(nodeImpl);\n    }\n\n    const removedNodesImpl = domSymbolTree.childrenToArray(this);\n\n    let addedNodesImpl;\n    if (nodeImpl === null) {\n      addedNodesImpl = [];\n    } else if (nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      addedNodesImpl = domSymbolTree.childrenToArray(nodeImpl);\n    } else {\n      addedNodesImpl = [nodeImpl];\n    }\n\n    for (const childImpl of domSymbolTree.childrenIterator(this)) {\n      this._remove(childImpl, true);\n    }\n\n    if (nodeImpl !== null) {\n      this._insert(nodeImpl, null, true);\n    }\n\n    if (addedNodesImpl.length > 0 || removedNodesImpl.length > 0) {\n      queueTreeMutationRecord(this, addedNodesImpl, removedNodesImpl, null, null);\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-pre-remove\n  _preRemove(childImpl) {\n    if (domSymbolTree.parent(childImpl) !== this) {\n      throw DOMException.create(this._globalObject, [\n        \"The node to be removed is not a child of this node.\",\n        \"NotFoundError\"\n      ]);\n    }\n\n    this._remove(childImpl);\n\n    return childImpl;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-node-remove\n  _remove(nodeImpl, suppressObservers) {\n    const index = domSymbolTree.index(nodeImpl);\n\n    for (const descendant of domSymbolTree.treeIterator(nodeImpl)) {\n      for (const range of descendant._referencedRanges) {\n        const { _start, _end } = range;\n\n        if (_start.node === descendant) {\n          range._setLiveRangeStart(this, index);\n        }\n\n        if (_end.node === descendant) {\n          range._setLiveRangeEnd(this, index);\n        }\n      }\n    }\n\n    for (const range of this._referencedRanges) {\n      const { _start, _end } = range;\n\n      if (_start.node === this && _start.offset > index) {\n        range._setLiveRangeStart(this, _start.offset - 1);\n      }\n\n      if (_end.node === this && _end.offset > index) {\n        range._setLiveRangeEnd(this, _end.offset - 1);\n      }\n    }\n\n    if (this._ownerDocument) {\n      this._ownerDocument._runPreRemovingSteps(nodeImpl);\n    }\n\n    const oldPreviousSiblingImpl = domSymbolTree.previousSibling(nodeImpl);\n    const oldNextSiblingImpl = domSymbolTree.nextSibling(nodeImpl);\n\n    domSymbolTree.remove(nodeImpl);\n\n    if (nodeImpl._assignedSlot) {\n      assignSlotable(nodeImpl._assignedSlot);\n    }\n\n    if (isSlot(this) && this._assignedNodes.length === 0 && isShadowRoot(nodeRoot(this))) {\n      signalSlotChange(this);\n    }\n\n    let hasSlotDescendant = isSlot(nodeImpl);\n    if (!hasSlotDescendant) {\n      for (const child of domSymbolTree.treeIterator(nodeImpl)) {\n        if (isSlot(child)) {\n          hasSlotDescendant = true;\n          break;\n        }\n      }\n    }\n\n    if (hasSlotDescendant) {\n      assignSlotableForTree(nodeRoot(this));\n      assignSlotableForTree(nodeImpl);\n    }\n\n    this._modified();\n    nodeImpl._detach();\n    this._descendantRemoved(this, nodeImpl);\n\n    if (this.isConnected) {\n      if (nodeImpl._ceState === \"custom\") {\n        enqueueCECallbackReaction(nodeImpl, \"disconnectedCallback\", []);\n      }\n\n      for (const descendantImpl of shadowIncludingDescendantsIterator(nodeImpl)) {\n        if (descendantImpl._ceState === \"custom\") {\n          enqueueCECallbackReaction(descendantImpl, \"disconnectedCallback\", []);\n        }\n      }\n    }\n\n    if (!suppressObservers) {\n      queueTreeMutationRecord(this, [], [nodeImpl], oldPreviousSiblingImpl, oldNextSiblingImpl);\n    }\n\n    if (nodeImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n      this._childTextContentChangeSteps();\n    }\n  }\n}\n\nmodule.exports = {\n  implementation: NodeImpl\n};\n"]},"metadata":{},"sourceType":"script"}