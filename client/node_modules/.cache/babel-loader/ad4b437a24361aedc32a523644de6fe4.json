{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar HTTP_STATUS_CODES = require(\"http\").STATUS_CODES;\n\nvar _require = require(\"child_process\"),\n    spawnSync = _require.spawnSync;\n\nvar _require2 = require(\"whatwg-url\"),\n    URL = _require2.URL;\n\nvar whatwgEncoding = require(\"whatwg-encoding\");\n\nvar tough = require(\"tough-cookie\");\n\nvar MIMEType = require(\"whatwg-mimetype\");\n\nvar xhrUtils = require(\"./xhr-utils\");\n\nvar DOMException = require(\"domexception/webidl2js-wrapper\");\n\nvar _require3 = require(\"../helpers/document-base-url\"),\n    documentBaseURLSerialized = _require3.documentBaseURLSerialized;\n\nvar _require4 = require(\"../helpers/strings\"),\n    asciiCaseInsensitiveMatch = _require4.asciiCaseInsensitiveMatch;\n\nvar idlUtils = require(\"../generated/utils\");\n\nvar Document = require(\"../generated/Document\");\n\nvar Blob = require(\"../generated/Blob\");\n\nvar FormData = require(\"../generated/FormData\");\n\nvar XMLHttpRequestEventTargetImpl = require(\"./XMLHttpRequestEventTarget-impl\").implementation;\n\nvar XMLHttpRequestUpload = require(\"../generated/XMLHttpRequestUpload\");\n\nvar ProgressEvent = require(\"../generated/ProgressEvent\");\n\nvar _require5 = require(\"../generated/utils\"),\n    isArrayBuffer = _require5.isArrayBuffer;\n\nvar _require6 = require(\"../../browser/parser\"),\n    parseIntoDocument = _require6.parseIntoDocument;\n\nvar _require7 = require(\"../domparsing/serialization\"),\n    fragmentSerialization = _require7.fragmentSerialization;\n\nvar _require8 = require(\"../helpers/create-event-accessor\"),\n    setupForSimpleEventAccessors = _require8.setupForSimpleEventAccessors;\n\nvar _require9 = require(\"../helpers/json\"),\n    parseJSONFromBytes = _require9.parseJSONFromBytes;\n\nvar _require10 = require(\"../helpers/events\"),\n    fireAnEvent = _require10.fireAnEvent;\n\nvar _require11 = require(\"../helpers/binary-data\"),\n    copyToArrayBufferInNewRealm = _require11.copyToArrayBufferInNewRealm;\n\nvar READY_STATES = xhrUtils.READY_STATES;\nvar syncWorkerFile = require.resolve ? require.resolve(\"./xhr-sync-worker.js\") : null;\nvar tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nvar fieldValueRegexp = /^[ \\t]*(?:[\\x21-\\x7E\\x80-\\xFF](?:[ \\t][\\x21-\\x7E\\x80-\\xFF])?)*[ \\t]*$/;\nvar forbiddenRequestHeaders = new Set([\"accept-charset\", \"accept-encoding\", \"access-control-request-headers\", \"access-control-request-method\", \"connection\", \"content-length\", \"cookie\", \"cookie2\", \"date\", \"dnt\", \"expect\", \"host\", \"keep-alive\", \"origin\", \"referer\", \"te\", \"trailer\", \"transfer-encoding\", \"upgrade\", \"via\"]);\nvar forbiddenResponseHeaders = new Set([\"set-cookie\", \"set-cookie2\"]);\nvar uniqueResponseHeaders = new Set([\"content-type\", \"content-length\", \"user-agent\", \"referer\", \"host\", \"authorization\", \"proxy-authorization\", \"if-modified-since\", \"if-unmodified-since\", \"from\", \"location\", \"max-forwards\"]);\nvar corsSafeResponseHeaders = new Set([\"cache-control\", \"content-language\", \"content-length\", \"content-type\", \"expires\", \"last-modified\", \"pragma\"]);\nvar allowedRequestMethods = new Set([\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]);\nvar forbiddenRequestMethods = new Set([\"TRACK\", \"TRACE\", \"CONNECT\"]);\n\nvar XMLHttpRequestImpl = /*#__PURE__*/function (_XMLHttpRequestEventT) {\n  _inherits(XMLHttpRequestImpl, _XMLHttpRequestEventT);\n\n  var _super = _createSuper(XMLHttpRequestImpl);\n\n  function XMLHttpRequestImpl(window) {\n    var _this;\n\n    _classCallCheck(this, XMLHttpRequestImpl);\n\n    _this = _super.call(this, window); // Avoid running `_ownerDocument` getter multiple times in the constructor:\n\n    var _assertThisInitialize = _assertThisInitialized(_this),\n        _ownerDocument = _assertThisInitialize._ownerDocument;\n\n    _this.upload = XMLHttpRequestUpload.createImpl(window);\n    _this.readyState = READY_STATES.UNSENT;\n    _this.responseURL = \"\";\n    _this.status = 0;\n    _this.statusText = \"\";\n    _this.flag = {\n      synchronous: false,\n      withCredentials: false,\n      mimeType: null,\n      auth: null,\n      method: undefined,\n      responseType: \"\",\n      requestHeaders: {},\n      referrer: _ownerDocument.URL,\n      uri: \"\",\n      timeout: 0,\n      body: undefined,\n      formData: false,\n      preflight: false,\n      requestManager: _ownerDocument._requestManager,\n      strictSSL: window._resourceLoader._strictSSL,\n      proxy: window._resourceLoader._proxy,\n      cookieJar: _ownerDocument._cookieJar,\n      encoding: _ownerDocument._encoding,\n      origin: window._origin,\n      userAgent: window.navigator.userAgent\n    };\n    _this.properties = {\n      beforeSend: false,\n      send: false,\n      client: null,\n      timeoutStart: 0,\n      timeoutId: 0,\n      timeoutFn: null,\n      responseBuffer: null,\n      responseCache: null,\n      responseTextCache: null,\n      responseXMLCache: null,\n      responseHeaders: {},\n      filteredResponseHeaders: [],\n      error: \"\",\n      uploadComplete: false,\n      uploadListener: false,\n      // Signifies that we're calling abort() from xhr-utils.js because of a window shutdown.\n      // In that case the termination reason is \"fatal\", not \"end-user abort\".\n      abortError: false,\n      cookieJar: _ownerDocument._cookieJar,\n      bufferStepSize: 1 * 1024 * 1024,\n      // pre-allocate buffer increase step size. init value is 1MB\n      totalReceivedChunkSize: 0\n    };\n    return _this;\n  }\n\n  _createClass(XMLHttpRequestImpl, [{\n    key: \"responseType\",\n    get: function get() {\n      return this.flag.responseType;\n    },\n    set: function set(responseType) {\n      var flag = this.flag;\n\n      if (this.readyState === READY_STATES.LOADING || this.readyState === READY_STATES.DONE) {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n\n      if (this.readyState === READY_STATES.OPENED && flag.synchronous) {\n        throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n      }\n\n      flag.responseType = responseType;\n    }\n  }, {\n    key: \"response\",\n    get: function get() {\n      var properties = this.properties;\n\n      if (properties.responseCache) {\n        // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n        return idlUtils.tryWrapperForImpl(properties.responseCache);\n      }\n\n      var res;\n      var responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n\n      switch (this.responseType) {\n        case \"\":\n        case \"text\":\n          {\n            res = this.responseText;\n            break;\n          }\n\n        case \"arraybuffer\":\n          {\n            if (!responseBuffer) {\n              return null;\n            }\n\n            res = copyToArrayBufferInNewRealm(responseBuffer, this._globalObject);\n            break;\n          }\n\n        case \"blob\":\n          {\n            if (!responseBuffer) {\n              return null;\n            }\n\n            var contentType = finalMIMEType(this);\n            res = Blob.createImpl(this._globalObject, [[new Uint8Array(responseBuffer)], {\n              type: contentType || \"\"\n            }]);\n            break;\n          }\n\n        case \"document\":\n          {\n            res = this.responseXML;\n            break;\n          }\n\n        case \"json\":\n          {\n            if (this.readyState !== READY_STATES.DONE || !responseBuffer) {\n              res = null;\n            }\n\n            try {\n              res = parseJSONFromBytes(responseBuffer);\n            } catch (e) {\n              res = null;\n            }\n\n            break;\n          }\n      }\n\n      properties.responseCache = res; // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n\n      return idlUtils.tryWrapperForImpl(res);\n    }\n  }, {\n    key: \"responseText\",\n    get: function get() {\n      var properties = this.properties;\n\n      if (this.responseType !== \"\" && this.responseType !== \"text\") {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n\n      if (this.readyState !== READY_STATES.LOADING && this.readyState !== READY_STATES.DONE) {\n        return \"\";\n      }\n\n      if (properties.responseTextCache) {\n        return properties.responseTextCache;\n      }\n\n      var responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n\n      if (!responseBuffer) {\n        return \"\";\n      }\n\n      var fallbackEncoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n      var res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);\n      properties.responseTextCache = res;\n      return res;\n    }\n  }, {\n    key: \"responseXML\",\n    get: function get() {\n      var flag = this.flag,\n          properties = this.properties;\n\n      if (this.responseType !== \"\" && this.responseType !== \"document\") {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n\n      if (this.readyState !== READY_STATES.DONE) {\n        return null;\n      }\n\n      if (properties.responseXMLCache) {\n        return properties.responseXMLCache;\n      }\n\n      var responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n\n      if (!responseBuffer) {\n        return null;\n      }\n\n      var contentType = finalMIMEType(this);\n      var isHTML = false;\n      var isXML = false;\n      var parsed = MIMEType.parse(contentType);\n\n      if (parsed) {\n        isHTML = parsed.isHTML();\n        isXML = parsed.isXML();\n\n        if (!isXML && !isHTML) {\n          return null;\n        }\n      }\n\n      if (this.responseType === \"\" && isHTML) {\n        return null;\n      }\n\n      var encoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n      var resText = whatwgEncoding.decode(responseBuffer, encoding);\n\n      if (!resText) {\n        return null;\n      }\n\n      var res = Document.createImpl(this._globalObject, [], {\n        options: {\n          url: flag.uri,\n          lastModified: new Date(_getResponseHeader(this, \"last-modified\")),\n          parsingMode: isHTML ? \"html\" : \"xml\",\n          cookieJar: {\n            setCookieSync: function setCookieSync() {\n              return undefined;\n            },\n            getCookieStringSync: function getCookieStringSync() {\n              return \"\";\n            }\n          },\n          encoding: encoding,\n          parseOptions: this._ownerDocument._parseOptions\n        }\n      });\n\n      try {\n        parseIntoDocument(resText, res);\n      } catch (e) {\n        properties.responseXMLCache = null;\n        return null;\n      }\n\n      res.close();\n      properties.responseXMLCache = res;\n      return res;\n    }\n  }, {\n    key: \"timeout\",\n    get: function get() {\n      return this.flag.timeout;\n    },\n    set: function set(val) {\n      var flag = this.flag,\n          properties = this.properties;\n\n      if (flag.synchronous) {\n        throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n      }\n\n      flag.timeout = val;\n      clearTimeout(properties.timeoutId);\n\n      if (val > 0 && properties.timeoutFn) {\n        properties.timeoutId = setTimeout(properties.timeoutFn, Math.max(0, val - (new Date().getTime() - properties.timeoutStart)));\n      } else {\n        properties.timeoutFn = null;\n        properties.timeoutStart = 0;\n      }\n    }\n  }, {\n    key: \"withCredentials\",\n    get: function get() {\n      return this.flag.withCredentials;\n    },\n    set: function set(val) {\n      var flag = this.flag,\n          properties = this.properties;\n\n      if (!(this.readyState === READY_STATES.UNSENT || this.readyState === READY_STATES.OPENED)) {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n\n      if (properties.send) {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n\n      flag.withCredentials = val;\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      var properties = this.properties; // Terminate the request\n\n      clearTimeout(properties.timeoutId);\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n      var client = properties.client;\n\n      if (client) {\n        client.abort();\n        properties.client = null;\n      }\n\n      if (properties.abortError) {\n        // Special case that ideally shouldn't be going through the public API at all.\n        // Run the https://xhr.spec.whatwg.org/#handle-errors \"fatal\" steps.\n        this.readyState = READY_STATES.DONE;\n        properties.send = false;\n        xhrUtils.setResponseToNetworkError(this);\n        return;\n      }\n\n      if (this.readyState === READY_STATES.OPENED && properties.send || this.readyState === READY_STATES.HEADERS_RECEIVED || this.readyState === READY_STATES.LOADING) {\n        xhrUtils.requestErrorSteps(this, \"abort\");\n      }\n\n      if (this.readyState === READY_STATES.DONE) {\n        this.readyState = READY_STATES.UNSENT;\n        xhrUtils.setResponseToNetworkError(this);\n      }\n    }\n  }, {\n    key: \"getAllResponseHeaders\",\n    value: function getAllResponseHeaders() {\n      var properties = this.properties,\n          readyState = this.readyState;\n\n      if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n        return \"\";\n      }\n\n      return Object.keys(properties.responseHeaders).filter(function (key) {\n        return properties.filteredResponseHeaders.indexOf(key) === -1;\n      }).map(function (key) {\n        return [key.toLowerCase(), properties.responseHeaders[key]].join(\": \");\n      }).join(\"\\r\\n\");\n    }\n  }, {\n    key: \"getResponseHeader\",\n    value: function getResponseHeader(header) {\n      var properties = this.properties,\n          readyState = this.readyState;\n\n      if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n        return null;\n      }\n\n      var lcHeader = header.toLowerCase();\n\n      if (properties.filteredResponseHeaders.find(function (filtered) {\n        return lcHeader === filtered.toLowerCase();\n      })) {\n        return null;\n      }\n\n      return _getResponseHeader(this, lcHeader);\n    }\n  }, {\n    key: \"open\",\n    value: function open(method, uri, asynchronous, user, password) {\n      var flag = this.flag,\n          properties = this.properties,\n          _ownerDocument = this._ownerDocument;\n\n      if (!_ownerDocument) {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n\n      if (!tokenRegexp.test(method)) {\n        throw DOMException.create(this._globalObject, [\"The string did not match the expected pattern.\", \"SyntaxError\"]);\n      }\n\n      var upperCaseMethod = method.toUpperCase();\n\n      if (forbiddenRequestMethods.has(upperCaseMethod)) {\n        throw DOMException.create(this._globalObject, [\"The operation is insecure.\", \"SecurityError\"]);\n      }\n\n      var client = properties.client;\n\n      if (client && typeof client.abort === \"function\") {\n        client.abort();\n      }\n\n      if (allowedRequestMethods.has(upperCaseMethod)) {\n        method = upperCaseMethod;\n      }\n\n      if (typeof asynchronous !== \"undefined\") {\n        flag.synchronous = !asynchronous;\n      } else {\n        flag.synchronous = false;\n      }\n\n      if (flag.responseType && flag.synchronous) {\n        throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n      }\n\n      if (flag.synchronous && flag.timeout) {\n        throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n      }\n\n      flag.method = method;\n      var urlObj;\n\n      try {\n        urlObj = new URL(uri, documentBaseURLSerialized(_ownerDocument));\n      } catch (e) {\n        throw DOMException.create(this._globalObject, [\"The string did not match the expected pattern.\", \"SyntaxError\"]);\n      }\n\n      if (user || password && !urlObj.username) {\n        flag.auth = {\n          user: user,\n          pass: password\n        };\n        urlObj.username = \"\";\n        urlObj.password = \"\";\n      }\n\n      flag.uri = urlObj.href;\n      flag.requestHeaders = {};\n      flag.preflight = false;\n      properties.send = false;\n      properties.uploadListener = false;\n      properties.abortError = false;\n      this.responseURL = \"\";\n      readyStateChange(this, READY_STATES.OPENED);\n    }\n  }, {\n    key: \"overrideMimeType\",\n    value: function overrideMimeType(mime) {\n      var readyState = this.readyState;\n\n      if (readyState === READY_STATES.LOADING || readyState === READY_STATES.DONE) {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n\n      this.flag.overrideMIMEType = \"application/octet-stream\"; // Waiting for better spec: https://github.com/whatwg/xhr/issues/157\n\n      var parsed = MIMEType.parse(mime);\n\n      if (parsed) {\n        this.flag.overrideMIMEType = parsed.essence;\n        var charset = parsed.parameters.get(\"charset\");\n\n        if (charset) {\n          this.flag.overrideCharset = whatwgEncoding.labelToName(charset);\n        }\n      }\n    } // TODO: Add support for URLSearchParams and ReadableStream\n\n  }, {\n    key: \"send\",\n    value: function send(body) {\n      var _this2 = this;\n\n      var flag = this.flag,\n          properties = this.properties,\n          upload = this.upload,\n          _ownerDocument = this._ownerDocument; // Not per spec, but per tests: https://github.com/whatwg/xhr/issues/65\n\n      if (!_ownerDocument) {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n\n      if (this.readyState !== READY_STATES.OPENED || properties.send) {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n\n      properties.beforeSend = true;\n\n      try {\n        if (flag.method === \"GET\" || flag.method === \"HEAD\") {\n          body = null;\n        }\n\n        if (body !== null) {\n          var encoding = null;\n          var mimeType = null;\n\n          if (Document.isImpl(body)) {\n            encoding = \"UTF-8\";\n            mimeType = (body._parsingMode === \"html\" ? \"text/html\" : \"application/xml\") + \";charset=UTF-8\";\n            flag.body = fragmentSerialization(body, {\n              requireWellFormed: false\n            });\n          } else {\n            if (typeof body === \"string\") {\n              encoding = \"UTF-8\";\n            }\n\n            var _extractBody = extractBody(body),\n                buffer = _extractBody.buffer,\n                formData = _extractBody.formData,\n                contentType = _extractBody.contentType;\n\n            mimeType = contentType;\n            flag.body = buffer || formData;\n            flag.formData = Boolean(formData);\n          }\n\n          var existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, \"content-type\");\n\n          if (mimeType !== null && existingContentType === null) {\n            flag.requestHeaders[\"Content-Type\"] = mimeType;\n          } else if (existingContentType !== null && encoding !== null) {\n            // Waiting for better spec: https://github.com/whatwg/xhr/issues/188. This seems like a good guess at what\n            // the spec will be, in the meantime.\n            var parsed = MIMEType.parse(existingContentType);\n\n            if (parsed) {\n              var charset = parsed.parameters.get(\"charset\");\n\n              if (charset && !asciiCaseInsensitiveMatch(charset, encoding) && encoding !== null) {\n                parsed.parameters.set(\"charset\", encoding);\n                xhrUtils.updateRequestHeader(flag.requestHeaders, \"content-type\", parsed.toString());\n              }\n            }\n          }\n        }\n      } finally {\n        if (properties.beforeSend) {\n          properties.beforeSend = false;\n        } else {\n          throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n        }\n      }\n\n      if (Object.keys(upload._eventListeners).length > 0) {\n        properties.uploadListener = true;\n      } // request doesn't like zero-length bodies\n\n\n      if (flag.body && flag.body.byteLength === 0) {\n        flag.body = null;\n      }\n\n      if (flag.synchronous) {\n        var flagStr = JSON.stringify(flag, function (k, v) {\n          if (this === flag && k === \"requestManager\") {\n            return null;\n          }\n\n          if (this === flag && k === \"pool\" && v) {\n            return {\n              maxSockets: v.maxSockets\n            };\n          }\n\n          return v;\n        });\n        var res = spawnSync(process.execPath, [syncWorkerFile], {\n          input: flagStr,\n          maxBuffer: Infinity\n        });\n\n        if (res.status !== 0) {\n          throw new Error(res.stderr.toString());\n        }\n\n        if (res.error) {\n          if (typeof res.error === \"string\") {\n            res.error = new Error(res.error);\n          }\n\n          throw res.error;\n        }\n\n        var response = JSON.parse(res.stdout.toString());\n        var resProp = response.properties;\n\n        if (resProp.responseBuffer && resProp.responseBuffer.data) {\n          resProp.responseBuffer = Buffer.from(resProp.responseBuffer.data);\n        }\n\n        if (resProp.cookieJar) {\n          resProp.cookieJar = tough.CookieJar.deserializeSync(resProp.cookieJar, _ownerDocument._cookieJar.store);\n        }\n\n        this.readyState = READY_STATES.LOADING;\n        this.status = response.status;\n        this.statusText = response.statusText;\n        this.responseURL = response.responseURL;\n        Object.assign(this.properties, response.properties);\n\n        if (resProp.error) {\n          xhrUtils.dispatchError(this);\n          throw DOMException.create(this._globalObject, [resProp.error, \"NetworkError\"]);\n        } else {\n          var responseBuffer = properties.responseBuffer;\n          var contentLength = _getResponseHeader(this, \"content-length\") || \"0\";\n          var bufferLength = parseInt(contentLength) || responseBuffer.length;\n          var progressObj = {\n            lengthComputable: false\n          };\n\n          if (bufferLength !== 0) {\n            progressObj.total = bufferLength;\n            progressObj.loaded = bufferLength;\n            progressObj.lengthComputable = true;\n          }\n\n          fireAnEvent(\"progress\", this, ProgressEvent, progressObj);\n          readyStateChange(this, READY_STATES.DONE);\n          fireAnEvent(\"load\", this, ProgressEvent, progressObj);\n          fireAnEvent(\"loadend\", this, ProgressEvent, progressObj);\n        }\n      } else {\n        properties.send = true;\n        fireAnEvent(\"loadstart\", this, ProgressEvent);\n        var client = xhrUtils.createClient(this);\n        properties.client = client; // For new client, reset totalReceivedChunkSize and bufferStepSize\n\n        properties.totalReceivedChunkSize = 0;\n        properties.bufferStepSize = 1 * 1024 * 1024;\n        properties.origin = flag.origin;\n        client.on(\"error\", function (err) {\n          client.removeAllListeners();\n          properties.error = err;\n          xhrUtils.dispatchError(_this2);\n        });\n        client.on(\"response\", function (res, url) {\n          return receiveResponse(_this2, res, url);\n        });\n        client.on(\"redirect\", function (response, requestHeaders, currentURL) {\n          var destUrlObj = new URL(requestHeaders.Referer);\n          var urlObj = new URL(currentURL);\n\n          if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {\n            properties.origin = \"null\";\n          }\n\n          requestHeaders.Origin = properties.origin;\n\n          if (flag.origin !== destUrlObj.origin && destUrlObj.protocol !== \"data:\") {\n            if (!xhrUtils.validCORSHeaders(_this2, response, flag, properties, flag.origin)) {\n              return;\n            }\n\n            if (urlObj.username || urlObj.password) {\n              properties.error = \"Userinfo forbidden in cors redirect\";\n              xhrUtils.dispatchError(_this2);\n            }\n          }\n        });\n\n        if (body !== null && body !== \"\") {\n          properties.uploadComplete = false;\n          setDispatchProgressEvents(this);\n        } else {\n          properties.uploadComplete = true;\n        }\n\n        if (this.timeout > 0) {\n          properties.timeoutStart = new Date().getTime();\n\n          properties.timeoutFn = function () {\n            client.abort();\n\n            if (!(_this2.readyState === READY_STATES.UNSENT || _this2.readyState === READY_STATES.OPENED && !properties.send || _this2.readyState === READY_STATES.DONE)) {\n              properties.send = false;\n              var stateChanged = false;\n\n              if (!properties.uploadComplete) {\n                fireAnEvent(\"progress\", upload, ProgressEvent);\n                readyStateChange(_this2, READY_STATES.DONE);\n                fireAnEvent(\"timeout\", upload, ProgressEvent);\n                fireAnEvent(\"loadend\", upload, ProgressEvent);\n                stateChanged = true;\n              }\n\n              fireAnEvent(\"progress\", _this2, ProgressEvent);\n\n              if (!stateChanged) {\n                readyStateChange(_this2, READY_STATES.DONE);\n              }\n\n              fireAnEvent(\"timeout\", _this2, ProgressEvent);\n              fireAnEvent(\"loadend\", _this2, ProgressEvent);\n            }\n\n            _this2.readyState = READY_STATES.UNSENT;\n          };\n\n          properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);\n        }\n      }\n    }\n  }, {\n    key: \"setRequestHeader\",\n    value: function setRequestHeader(header, value) {\n      var flag = this.flag,\n          properties = this.properties;\n\n      if (this.readyState !== READY_STATES.OPENED || properties.send) {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n\n      value = normalizeHeaderValue(value);\n\n      if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {\n        throw DOMException.create(this._globalObject, [\"The string did not match the expected pattern.\", \"SyntaxError\"]);\n      }\n\n      var lcHeader = header.toLowerCase();\n\n      if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith(\"sec-\") || lcHeader.startsWith(\"proxy-\")) {\n        return;\n      }\n\n      var keys = Object.keys(flag.requestHeaders);\n      var n = keys.length;\n\n      while (n--) {\n        var key = keys[n];\n\n        if (key.toLowerCase() === lcHeader) {\n          flag.requestHeaders[key] += \", \" + value;\n          return;\n        }\n      }\n\n      flag.requestHeaders[header] = value;\n    }\n  }]);\n\n  return XMLHttpRequestImpl;\n}(XMLHttpRequestEventTargetImpl);\n\nsetupForSimpleEventAccessors(XMLHttpRequestImpl.prototype, [\"readystatechange\"]);\n\nfunction readyStateChange(xhr, readyState) {\n  if (xhr.readyState === readyState) {\n    return;\n  }\n\n  xhr.readyState = readyState;\n  fireAnEvent(\"readystatechange\", xhr);\n}\n\nfunction receiveResponse(xhr, response, currentURL) {\n  var flag = xhr.flag,\n      properties = xhr.properties;\n  var rawHeaders = response.rawHeaders,\n      statusCode = response.statusCode;\n  var byteOffset = 0;\n  var headers = {};\n  var filteredResponseHeaders = [];\n  var headerMap = {};\n  var n = Number(rawHeaders.length);\n\n  for (var i = 0; i < n; i += 2) {\n    var k = rawHeaders[i];\n    var kl = k.toLowerCase();\n    var v = rawHeaders[i + 1];\n\n    if (uniqueResponseHeaders.has(kl)) {\n      if (headerMap[kl] !== undefined) {\n        delete headers[headerMap[kl]];\n      }\n\n      headers[k] = v;\n    } else if (headerMap[kl] !== undefined) {\n      headers[headerMap[kl]] += \", \" + v;\n    } else {\n      headers[k] = v;\n    }\n\n    headerMap[kl] = k;\n  }\n\n  var destUrlObj = new URL(currentURL);\n\n  if (properties.origin !== destUrlObj.origin && destUrlObj.protocol !== \"data:\") {\n    if (!xhrUtils.validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n      return;\n    }\n\n    var acehStr = response.headers[\"access-control-expose-headers\"];\n    var aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(xhrUtils.headerListSeparatorRegexp) : []);\n\n    for (var header in headers) {\n      var lcHeader = header.toLowerCase();\n\n      if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {\n        filteredResponseHeaders.push(header);\n      }\n    }\n  }\n\n  for (var _header in headers) {\n    var _lcHeader = _header.toLowerCase();\n\n    if (forbiddenResponseHeaders.has(_lcHeader)) {\n      filteredResponseHeaders.push(_header);\n    }\n  }\n\n  xhr.responseURL = destUrlObj.href;\n  xhr.status = statusCode;\n  xhr.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || \"\";\n  properties.responseHeaders = headers;\n  properties.filteredResponseHeaders = filteredResponseHeaders;\n  var contentLength = _getResponseHeader(xhr, \"content-length\") || \"0\";\n  var bufferLength = parseInt(contentLength) || 0;\n  var progressObj = {\n    lengthComputable: false\n  };\n  var lastProgressReported;\n\n  if (bufferLength !== 0) {\n    progressObj.total = bufferLength;\n    progressObj.loaded = 0;\n    progressObj.lengthComputable = true;\n  } // pre-allocate buffer.\n\n\n  properties.responseBuffer = Buffer.alloc(properties.bufferStepSize);\n  properties.responseCache = null;\n  properties.responseTextCache = null;\n  properties.responseXMLCache = null;\n  readyStateChange(xhr, READY_STATES.HEADERS_RECEIVED);\n\n  if (!properties.client) {\n    // The request was aborted in reaction to the readystatechange event.\n    return;\n  } // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the\n  // Content-Length).\n\n\n  response.on(\"data\", function (chunk) {\n    byteOffset += chunk.length;\n    progressObj.loaded = byteOffset;\n  });\n  properties.client.on(\"data\", function (chunk) {\n    properties.totalReceivedChunkSize += chunk.length;\n\n    if (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n      properties.bufferStepSize *= 2;\n\n      while (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n        properties.bufferStepSize *= 2;\n      }\n\n      var tmpBuf = Buffer.alloc(properties.bufferStepSize);\n      properties.responseBuffer.copy(tmpBuf, 0, 0, properties.responseBuffer.length);\n      properties.responseBuffer = tmpBuf;\n    }\n\n    chunk.copy(properties.responseBuffer, properties.totalReceivedChunkSize - chunk.length, 0, chunk.length);\n    properties.responseCache = null;\n    properties.responseTextCache = null;\n    properties.responseXMLCache = null;\n\n    if (xhr.readyState === READY_STATES.HEADERS_RECEIVED) {\n      xhr.readyState = READY_STATES.LOADING;\n    }\n\n    fireAnEvent(\"readystatechange\", xhr);\n\n    if (progressObj.total !== progressObj.loaded || properties.totalReceivedChunkSize === byteOffset) {\n      if (lastProgressReported !== progressObj.loaded) {\n        // This is a necessary check in the gzip case where we can be getting new data from the client, as it\n        // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.\n        lastProgressReported = progressObj.loaded;\n        fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n      }\n    }\n  });\n  properties.client.on(\"end\", function () {\n    clearTimeout(properties.timeoutId);\n    properties.timeoutFn = null;\n    properties.timeoutStart = 0;\n    properties.client = null;\n\n    if (lastProgressReported !== progressObj.loaded) {\n      // https://github.com/whatwg/xhr/issues/318\n      fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n    }\n\n    readyStateChange(xhr, READY_STATES.DONE);\n    fireAnEvent(\"load\", xhr, ProgressEvent, progressObj);\n    fireAnEvent(\"loadend\", xhr, ProgressEvent, progressObj);\n  });\n}\n\nfunction setDispatchProgressEvents(xhr) {\n  var properties = xhr.properties,\n      upload = xhr.upload;\n  var client = properties.client;\n  var total = 0;\n  var lengthComputable = false;\n  var length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, \"content-length\"));\n\n  if (length) {\n    total = length;\n    lengthComputable = true;\n  }\n\n  var initProgress = {\n    lengthComputable: lengthComputable,\n    total: total,\n    loaded: 0\n  };\n\n  if (properties.uploadListener) {\n    fireAnEvent(\"loadstart\", upload, ProgressEvent, initProgress);\n  }\n\n  client.on(\"request\", function (req) {\n    req.on(\"response\", function () {\n      properties.uploadComplete = true;\n\n      if (!properties.uploadListener) {\n        return;\n      }\n\n      var progress = {\n        lengthComputable: lengthComputable,\n        total: total,\n        loaded: total\n      };\n      fireAnEvent(\"progress\", upload, ProgressEvent, progress);\n      fireAnEvent(\"load\", upload, ProgressEvent, progress);\n      fireAnEvent(\"loadend\", upload, ProgressEvent, progress);\n    });\n  });\n}\n\nfunction finalMIMEType(xhr) {\n  var flag = xhr.flag;\n  return flag.overrideMIMEType || _getResponseHeader(xhr, \"content-type\");\n}\n\nfunction finalCharset(xhr) {\n  var flag = xhr.flag;\n\n  if (flag.overrideCharset) {\n    return flag.overrideCharset;\n  }\n\n  var parsedContentType = MIMEType.parse(_getResponseHeader(xhr, \"content-type\"));\n\n  if (parsedContentType) {\n    return whatwgEncoding.labelToName(parsedContentType.parameters.get(\"charset\"));\n  }\n\n  return null;\n}\n\nfunction _getResponseHeader(xhr, lcHeader) {\n  var properties = xhr.properties;\n  var keys = Object.keys(properties.responseHeaders);\n  var n = keys.length;\n\n  while (n--) {\n    var key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      return properties.responseHeaders[key];\n    }\n  }\n\n  return null;\n}\n\nfunction normalizeHeaderValue(value) {\n  return value.replace(/^[\\x09\\x0A\\x0D\\x20]+/, \"\").replace(/[\\x09\\x0A\\x0D\\x20]+$/, \"\");\n}\n\nfunction extractBody(bodyInit) {\n  // https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n  // except we represent the body as a Node.js Buffer instead,\n  // or a special case for FormData since we want request to handle that. Probably it would be\n  // cleaner (and allow a future without request) if we did the form encoding ourself.\n  if (Blob.isImpl(bodyInit)) {\n    return {\n      buffer: bodyInit._buffer,\n      contentType: bodyInit.type === \"\" ? null : bodyInit.type\n    };\n  } else if (isArrayBuffer(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit),\n      contentType: null\n    };\n  } else if (ArrayBuffer.isView(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength),\n      contentType: null\n    };\n  } else if (FormData.isImpl(bodyInit)) {\n    var formData = [];\n\n    var _iterator = _createForOfIteratorHelper(bodyInit._entries),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var entry = _step.value;\n        var val = void 0;\n\n        if (Blob.isImpl(entry.value)) {\n          var blob = entry.value;\n          val = {\n            name: entry.name,\n            value: blob._buffer,\n            options: {\n              filename: blob.name,\n              contentType: blob.type,\n              knownLength: blob.size\n            }\n          };\n        } else {\n          val = entry;\n        }\n\n        formData.push(val);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return {\n      formData: formData\n    };\n  } // Must be a string\n\n\n  return {\n    buffer: Buffer.from(bodyInit, \"utf-8\"),\n    contentType: \"text/plain;charset=UTF-8\"\n  };\n}\n\nexports.implementation = XMLHttpRequestImpl;","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/node_modules/jsdom/lib/jsdom/living/xhr/XMLHttpRequest-impl.js"],"names":["HTTP_STATUS_CODES","require","STATUS_CODES","spawnSync","URL","whatwgEncoding","tough","MIMEType","xhrUtils","DOMException","documentBaseURLSerialized","asciiCaseInsensitiveMatch","idlUtils","Document","Blob","FormData","XMLHttpRequestEventTargetImpl","implementation","XMLHttpRequestUpload","ProgressEvent","isArrayBuffer","parseIntoDocument","fragmentSerialization","setupForSimpleEventAccessors","parseJSONFromBytes","fireAnEvent","copyToArrayBufferInNewRealm","READY_STATES","syncWorkerFile","resolve","tokenRegexp","fieldValueRegexp","forbiddenRequestHeaders","Set","forbiddenResponseHeaders","uniqueResponseHeaders","corsSafeResponseHeaders","allowedRequestMethods","forbiddenRequestMethods","XMLHttpRequestImpl","window","_ownerDocument","upload","createImpl","readyState","UNSENT","responseURL","status","statusText","flag","synchronous","withCredentials","mimeType","auth","method","undefined","responseType","requestHeaders","referrer","uri","timeout","body","formData","preflight","requestManager","_requestManager","strictSSL","_resourceLoader","_strictSSL","proxy","_proxy","cookieJar","_cookieJar","encoding","_encoding","origin","_origin","userAgent","navigator","properties","beforeSend","send","client","timeoutStart","timeoutId","timeoutFn","responseBuffer","responseCache","responseTextCache","responseXMLCache","responseHeaders","filteredResponseHeaders","error","uploadComplete","uploadListener","abortError","bufferStepSize","totalReceivedChunkSize","LOADING","DONE","create","_globalObject","OPENED","tryWrapperForImpl","res","slice","responseText","contentType","finalMIMEType","Uint8Array","type","responseXML","e","fallbackEncoding","finalCharset","getBOMEncoding","decode","isHTML","isXML","parsed","parse","resText","options","url","lastModified","Date","getResponseHeader","parsingMode","setCookieSync","getCookieStringSync","parseOptions","_parseOptions","close","val","clearTimeout","setTimeout","Math","max","getTime","abort","setResponseToNetworkError","HEADERS_RECEIVED","requestErrorSteps","Object","keys","filter","key","indexOf","map","toLowerCase","join","header","lcHeader","find","filtered","asynchronous","user","password","test","upperCaseMethod","toUpperCase","has","urlObj","username","pass","href","readyStateChange","mime","overrideMIMEType","essence","charset","parameters","get","overrideCharset","labelToName","isImpl","_parsingMode","requireWellFormed","extractBody","buffer","Boolean","existingContentType","getRequestHeader","set","updateRequestHeader","toString","_eventListeners","length","byteLength","flagStr","JSON","stringify","k","v","maxSockets","process","execPath","input","maxBuffer","Infinity","Error","stderr","response","stdout","resProp","data","Buffer","from","CookieJar","deserializeSync","store","assign","dispatchError","contentLength","bufferLength","parseInt","progressObj","lengthComputable","total","loaded","createClient","on","err","removeAllListeners","receiveResponse","currentURL","destUrlObj","Referer","Origin","protocol","validCORSHeaders","setDispatchProgressEvents","stateChanged","value","normalizeHeaderValue","startsWith","n","prototype","xhr","rawHeaders","statusCode","byteOffset","headers","headerMap","Number","i","kl","acehStr","aceh","trim","split","headerListSeparatorRegexp","push","statusMessage","lastProgressReported","alloc","chunk","tmpBuf","copy","initProgress","req","progress","parsedContentType","replace","bodyInit","_buffer","ArrayBuffer","isView","_entries","entry","blob","name","filename","knownLength","size","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst HTTP_STATUS_CODES = require(\"http\").STATUS_CODES;\nconst { spawnSync } = require(\"child_process\");\nconst { URL } = require(\"whatwg-url\");\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst tough = require(\"tough-cookie\");\nconst MIMEType = require(\"whatwg-mimetype\");\n\nconst xhrUtils = require(\"./xhr-utils\");\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\nconst { documentBaseURLSerialized } = require(\"../helpers/document-base-url\");\nconst { asciiCaseInsensitiveMatch } = require(\"../helpers/strings\");\nconst idlUtils = require(\"../generated/utils\");\nconst Document = require(\"../generated/Document\");\nconst Blob = require(\"../generated/Blob\");\nconst FormData = require(\"../generated/FormData\");\nconst XMLHttpRequestEventTargetImpl = require(\"./XMLHttpRequestEventTarget-impl\").implementation;\nconst XMLHttpRequestUpload = require(\"../generated/XMLHttpRequestUpload\");\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\nconst { isArrayBuffer } = require(\"../generated/utils\");\nconst { parseIntoDocument } = require(\"../../browser/parser\");\nconst { fragmentSerialization } = require(\"../domparsing/serialization\");\nconst { setupForSimpleEventAccessors } = require(\"../helpers/create-event-accessor\");\nconst { parseJSONFromBytes } = require(\"../helpers/json\");\nconst { fireAnEvent } = require(\"../helpers/events\");\nconst { copyToArrayBufferInNewRealm } = require(\"../helpers/binary-data\");\n\nconst { READY_STATES } = xhrUtils;\n\nconst syncWorkerFile = require.resolve ? require.resolve(\"./xhr-sync-worker.js\") : null;\n\nconst tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nconst fieldValueRegexp = /^[ \\t]*(?:[\\x21-\\x7E\\x80-\\xFF](?:[ \\t][\\x21-\\x7E\\x80-\\xFF])?)*[ \\t]*$/;\n\nconst forbiddenRequestHeaders = new Set([\n  \"accept-charset\",\n  \"accept-encoding\",\n  \"access-control-request-headers\",\n  \"access-control-request-method\",\n  \"connection\",\n  \"content-length\",\n  \"cookie\",\n  \"cookie2\",\n  \"date\",\n  \"dnt\",\n  \"expect\",\n  \"host\",\n  \"keep-alive\",\n  \"origin\",\n  \"referer\",\n  \"te\",\n  \"trailer\",\n  \"transfer-encoding\",\n  \"upgrade\",\n  \"via\"\n]);\nconst forbiddenResponseHeaders = new Set([\n  \"set-cookie\",\n  \"set-cookie2\"\n]);\nconst uniqueResponseHeaders = new Set([\n  \"content-type\",\n  \"content-length\",\n  \"user-agent\",\n  \"referer\",\n  \"host\",\n  \"authorization\",\n  \"proxy-authorization\",\n  \"if-modified-since\",\n  \"if-unmodified-since\",\n  \"from\",\n  \"location\",\n  \"max-forwards\"\n]);\nconst corsSafeResponseHeaders = new Set([\n  \"cache-control\",\n  \"content-language\",\n  \"content-length\",\n  \"content-type\",\n  \"expires\",\n  \"last-modified\",\n  \"pragma\"\n]);\n\nconst allowedRequestMethods = new Set([\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]);\nconst forbiddenRequestMethods = new Set([\"TRACK\", \"TRACE\", \"CONNECT\"]);\n\nclass XMLHttpRequestImpl extends XMLHttpRequestEventTargetImpl {\n  constructor(window) {\n    super(window);\n\n    // Avoid running `_ownerDocument` getter multiple times in the constructor:\n    const { _ownerDocument } = this;\n\n    this.upload = XMLHttpRequestUpload.createImpl(window);\n\n    this.readyState = READY_STATES.UNSENT;\n    this.responseURL = \"\";\n    this.status = 0;\n    this.statusText = \"\";\n\n    this.flag = {\n      synchronous: false,\n      withCredentials: false,\n      mimeType: null,\n      auth: null,\n      method: undefined,\n      responseType: \"\",\n      requestHeaders: {},\n      referrer: _ownerDocument.URL,\n      uri: \"\",\n      timeout: 0,\n      body: undefined,\n      formData: false,\n      preflight: false,\n      requestManager: _ownerDocument._requestManager,\n      strictSSL: window._resourceLoader._strictSSL,\n      proxy: window._resourceLoader._proxy,\n      cookieJar: _ownerDocument._cookieJar,\n      encoding: _ownerDocument._encoding,\n      origin: window._origin,\n      userAgent: window.navigator.userAgent\n    };\n\n    this.properties = {\n      beforeSend: false,\n      send: false,\n      client: null,\n\n      timeoutStart: 0,\n      timeoutId: 0,\n      timeoutFn: null,\n\n      responseBuffer: null,\n      responseCache: null,\n      responseTextCache: null,\n      responseXMLCache: null,\n\n      responseHeaders: {},\n      filteredResponseHeaders: [],\n\n      error: \"\",\n      uploadComplete: false,\n      uploadListener: false,\n\n      // Signifies that we're calling abort() from xhr-utils.js because of a window shutdown.\n      // In that case the termination reason is \"fatal\", not \"end-user abort\".\n      abortError: false,\n\n      cookieJar: _ownerDocument._cookieJar,\n      bufferStepSize: 1 * 1024 * 1024, // pre-allocate buffer increase step size. init value is 1MB\n      totalReceivedChunkSize: 0\n    };\n  }\n\n  get responseType() {\n    return this.flag.responseType;\n  }\n  set responseType(responseType) {\n    const { flag } = this;\n    if (this.readyState === READY_STATES.LOADING || this.readyState === READY_STATES.DONE) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState === READY_STATES.OPENED && flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    flag.responseType = responseType;\n  }\n\n  get response() {\n    const { properties } = this;\n    if (properties.responseCache) {\n      // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n      return idlUtils.tryWrapperForImpl(properties.responseCache);\n    }\n    let res;\n\n    const responseBuffer = properties.responseBuffer ?\n      properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) :\n      null;\n\n    switch (this.responseType) {\n      case \"\":\n      case \"text\": {\n        res = this.responseText;\n        break;\n      }\n      case \"arraybuffer\": {\n        if (!responseBuffer) {\n          return null;\n        }\n        res = copyToArrayBufferInNewRealm(responseBuffer, this._globalObject);\n        break;\n      }\n      case \"blob\": {\n        if (!responseBuffer) {\n          return null;\n        }\n        const contentType = finalMIMEType(this);\n        res = Blob.createImpl(this._globalObject, [\n          [new Uint8Array(responseBuffer)],\n          { type: contentType || \"\" }\n        ]);\n        break;\n      }\n      case \"document\": {\n        res = this.responseXML;\n        break;\n      }\n      case \"json\": {\n        if (this.readyState !== READY_STATES.DONE || !responseBuffer) {\n          res = null;\n        }\n\n        try {\n          res = parseJSONFromBytes(responseBuffer);\n        } catch (e) {\n          res = null;\n        }\n        break;\n      }\n    }\n    properties.responseCache = res;\n    // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n    return idlUtils.tryWrapperForImpl(res);\n  }\n  get responseText() {\n    const { properties } = this;\n    if (this.responseType !== \"\" && this.responseType !== \"text\") {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState !== READY_STATES.LOADING && this.readyState !== READY_STATES.DONE) {\n      return \"\";\n    }\n    if (properties.responseTextCache) {\n      return properties.responseTextCache;\n    }\n    const responseBuffer = properties.responseBuffer ?\n      properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) :\n      null;\n\n    if (!responseBuffer) {\n      return \"\";\n    }\n\n    const fallbackEncoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n    const res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);\n\n    properties.responseTextCache = res;\n    return res;\n  }\n  get responseXML() {\n    const { flag, properties } = this;\n    if (this.responseType !== \"\" && this.responseType !== \"document\") {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState !== READY_STATES.DONE) {\n      return null;\n    }\n    if (properties.responseXMLCache) {\n      return properties.responseXMLCache;\n    }\n    const responseBuffer = properties.responseBuffer ?\n      properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) :\n      null;\n\n    if (!responseBuffer) {\n      return null;\n    }\n\n    const contentType = finalMIMEType(this);\n    let isHTML = false;\n    let isXML = false;\n    const parsed = MIMEType.parse(contentType);\n    if (parsed) {\n      isHTML = parsed.isHTML();\n      isXML = parsed.isXML();\n      if (!isXML && !isHTML) {\n        return null;\n      }\n    }\n\n    if (this.responseType === \"\" && isHTML) {\n      return null;\n    }\n\n    const encoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n    const resText = whatwgEncoding.decode(responseBuffer, encoding);\n\n    if (!resText) {\n      return null;\n    }\n    const res = Document.createImpl(this._globalObject, [], {\n      options: {\n        url: flag.uri,\n        lastModified: new Date(getResponseHeader(this, \"last-modified\")),\n        parsingMode: isHTML ? \"html\" : \"xml\",\n        cookieJar: { setCookieSync: () => undefined, getCookieStringSync: () => \"\" },\n        encoding,\n        parseOptions: this._ownerDocument._parseOptions\n      }\n    });\n    try {\n      parseIntoDocument(resText, res);\n    } catch (e) {\n      properties.responseXMLCache = null;\n      return null;\n    }\n    res.close();\n    properties.responseXMLCache = res;\n    return res;\n  }\n\n  get timeout() {\n    return this.flag.timeout;\n  }\n  set timeout(val) {\n    const { flag, properties } = this;\n    if (flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    flag.timeout = val;\n    clearTimeout(properties.timeoutId);\n    if (val > 0 && properties.timeoutFn) {\n      properties.timeoutId = setTimeout(\n        properties.timeoutFn,\n        Math.max(0, val - ((new Date()).getTime() - properties.timeoutStart))\n      );\n    } else {\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n    }\n  }\n\n  get withCredentials() {\n    return this.flag.withCredentials;\n  }\n  set withCredentials(val) {\n    const { flag, properties } = this;\n    if (!(this.readyState === READY_STATES.UNSENT || this.readyState === READY_STATES.OPENED)) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    flag.withCredentials = val;\n  }\n\n  abort() {\n    const { properties } = this;\n    // Terminate the request\n    clearTimeout(properties.timeoutId);\n    properties.timeoutFn = null;\n    properties.timeoutStart = 0;\n\n    const { client } = properties;\n    if (client) {\n      client.abort();\n      properties.client = null;\n    }\n\n    if (properties.abortError) {\n      // Special case that ideally shouldn't be going through the public API at all.\n      // Run the https://xhr.spec.whatwg.org/#handle-errors \"fatal\" steps.\n      this.readyState = READY_STATES.DONE;\n      properties.send = false;\n      xhrUtils.setResponseToNetworkError(this);\n      return;\n    }\n\n    if ((this.readyState === READY_STATES.OPENED && properties.send) ||\n        this.readyState === READY_STATES.HEADERS_RECEIVED ||\n        this.readyState === READY_STATES.LOADING) {\n      xhrUtils.requestErrorSteps(this, \"abort\");\n    }\n\n    if (this.readyState === READY_STATES.DONE) {\n      this.readyState = READY_STATES.UNSENT;\n\n      xhrUtils.setResponseToNetworkError(this);\n    }\n  }\n  getAllResponseHeaders() {\n    const { properties, readyState } = this;\n    if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n      return \"\";\n    }\n    return Object.keys(properties.responseHeaders)\n      .filter(key => properties.filteredResponseHeaders.indexOf(key) === -1)\n      .map(key => [key.toLowerCase(), properties.responseHeaders[key]].join(\": \"))\n      .join(\"\\r\\n\");\n  }\n\n  getResponseHeader(header) {\n    const { properties, readyState } = this;\n    if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n      return null;\n    }\n    const lcHeader = header.toLowerCase();\n    if (properties.filteredResponseHeaders.find(filtered => lcHeader === filtered.toLowerCase())) {\n      return null;\n    }\n    return getResponseHeader(this, lcHeader);\n  }\n\n  open(method, uri, asynchronous, user, password) {\n    const { flag, properties, _ownerDocument } = this;\n    if (!_ownerDocument) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (!tokenRegexp.test(method)) {\n      throw DOMException.create(this._globalObject, [\n        \"The string did not match the expected pattern.\",\n        \"SyntaxError\"\n      ]);\n    }\n    const upperCaseMethod = method.toUpperCase();\n    if (forbiddenRequestMethods.has(upperCaseMethod)) {\n      throw DOMException.create(this._globalObject, [\"The operation is insecure.\", \"SecurityError\"]);\n    }\n\n    const { client } = properties;\n    if (client && typeof client.abort === \"function\") {\n      client.abort();\n    }\n\n    if (allowedRequestMethods.has(upperCaseMethod)) {\n      method = upperCaseMethod;\n    }\n    if (typeof asynchronous !== \"undefined\") {\n      flag.synchronous = !asynchronous;\n    } else {\n      flag.synchronous = false;\n    }\n    if (flag.responseType && flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    if (flag.synchronous && flag.timeout) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    flag.method = method;\n\n    let urlObj;\n    try {\n      urlObj = new URL(uri, documentBaseURLSerialized(_ownerDocument));\n    } catch (e) {\n      throw DOMException.create(this._globalObject, [\n        \"The string did not match the expected pattern.\",\n        \"SyntaxError\"\n      ]);\n    }\n\n    if (user || (password && !urlObj.username)) {\n      flag.auth = {\n        user,\n        pass: password\n      };\n      urlObj.username = \"\";\n      urlObj.password = \"\";\n    }\n\n    flag.uri = urlObj.href;\n    flag.requestHeaders = {};\n    flag.preflight = false;\n\n    properties.send = false;\n    properties.uploadListener = false;\n    properties.abortError = false;\n    this.responseURL = \"\";\n    readyStateChange(this, READY_STATES.OPENED);\n  }\n\n  overrideMimeType(mime) {\n    const { readyState } = this;\n    if (readyState === READY_STATES.LOADING || readyState === READY_STATES.DONE) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    this.flag.overrideMIMEType = \"application/octet-stream\";\n\n    // Waiting for better spec: https://github.com/whatwg/xhr/issues/157\n    const parsed = MIMEType.parse(mime);\n    if (parsed) {\n      this.flag.overrideMIMEType = parsed.essence;\n\n      const charset = parsed.parameters.get(\"charset\");\n      if (charset) {\n        this.flag.overrideCharset = whatwgEncoding.labelToName(charset);\n      }\n    }\n  }\n\n  // TODO: Add support for URLSearchParams and ReadableStream\n  send(body) {\n    const { flag, properties, upload, _ownerDocument } = this;\n    // Not per spec, but per tests: https://github.com/whatwg/xhr/issues/65\n    if (!_ownerDocument) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (this.readyState !== READY_STATES.OPENED || properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    properties.beforeSend = true;\n\n    try {\n      if (flag.method === \"GET\" || flag.method === \"HEAD\") {\n        body = null;\n      }\n\n      if (body !== null) {\n        let encoding = null;\n        let mimeType = null;\n\n        if (Document.isImpl(body)) {\n          encoding = \"UTF-8\";\n          mimeType = (body._parsingMode === \"html\" ? \"text/html\" : \"application/xml\") + \";charset=UTF-8\";\n          flag.body = fragmentSerialization(body, { requireWellFormed: false });\n        } else {\n          if (typeof body === \"string\") {\n            encoding = \"UTF-8\";\n          }\n          const { buffer, formData, contentType } = extractBody(body);\n          mimeType = contentType;\n          flag.body = buffer || formData;\n          flag.formData = Boolean(formData);\n        }\n\n        const existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, \"content-type\");\n        if (mimeType !== null && existingContentType === null) {\n          flag.requestHeaders[\"Content-Type\"] = mimeType;\n        } else if (existingContentType !== null && encoding !== null) {\n          // Waiting for better spec: https://github.com/whatwg/xhr/issues/188. This seems like a good guess at what\n          // the spec will be, in the meantime.\n          const parsed = MIMEType.parse(existingContentType);\n          if (parsed) {\n            const charset = parsed.parameters.get(\"charset\");\n            if (charset && !asciiCaseInsensitiveMatch(charset, encoding) && encoding !== null) {\n              parsed.parameters.set(\"charset\", encoding);\n              xhrUtils.updateRequestHeader(flag.requestHeaders, \"content-type\", parsed.toString());\n            }\n          }\n        }\n      }\n    } finally {\n      if (properties.beforeSend) {\n        properties.beforeSend = false;\n      } else {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n    }\n\n    if (Object.keys(upload._eventListeners).length > 0) {\n      properties.uploadListener = true;\n    }\n\n    // request doesn't like zero-length bodies\n    if (flag.body && flag.body.byteLength === 0) {\n      flag.body = null;\n    }\n\n    if (flag.synchronous) {\n      const flagStr = JSON.stringify(flag, function (k, v) {\n        if (this === flag && k === \"requestManager\") {\n          return null;\n        }\n        if (this === flag && k === \"pool\" && v) {\n          return { maxSockets: v.maxSockets };\n        }\n        return v;\n      });\n      const res = spawnSync(\n        process.execPath,\n        [syncWorkerFile],\n        { input: flagStr, maxBuffer: Infinity }\n      );\n      if (res.status !== 0) {\n        throw new Error(res.stderr.toString());\n      }\n      if (res.error) {\n        if (typeof res.error === \"string\") {\n          res.error = new Error(res.error);\n        }\n        throw res.error;\n      }\n\n      const response = JSON.parse(res.stdout.toString());\n      const resProp = response.properties;\n      if (resProp.responseBuffer && resProp.responseBuffer.data) {\n        resProp.responseBuffer = Buffer.from(resProp.responseBuffer.data);\n      }\n      if (resProp.cookieJar) {\n        resProp.cookieJar = tough.CookieJar.deserializeSync(\n          resProp.cookieJar,\n          _ownerDocument._cookieJar.store\n        );\n      }\n\n      this.readyState = READY_STATES.LOADING;\n      this.status = response.status;\n      this.statusText = response.statusText;\n      this.responseURL = response.responseURL;\n      Object.assign(this.properties, response.properties);\n\n      if (resProp.error) {\n        xhrUtils.dispatchError(this);\n        throw DOMException.create(this._globalObject, [resProp.error, \"NetworkError\"]);\n      } else {\n        const { responseBuffer } = properties;\n        const contentLength = getResponseHeader(this, \"content-length\") || \"0\";\n        const bufferLength = parseInt(contentLength) || responseBuffer.length;\n        const progressObj = { lengthComputable: false };\n        if (bufferLength !== 0) {\n          progressObj.total = bufferLength;\n          progressObj.loaded = bufferLength;\n          progressObj.lengthComputable = true;\n        }\n        fireAnEvent(\"progress\", this, ProgressEvent, progressObj);\n        readyStateChange(this, READY_STATES.DONE);\n        fireAnEvent(\"load\", this, ProgressEvent, progressObj);\n        fireAnEvent(\"loadend\", this, ProgressEvent, progressObj);\n      }\n    } else {\n      properties.send = true;\n\n      fireAnEvent(\"loadstart\", this, ProgressEvent);\n\n      const client = xhrUtils.createClient(this);\n\n      properties.client = client;\n      // For new client, reset totalReceivedChunkSize and bufferStepSize\n      properties.totalReceivedChunkSize = 0;\n      properties.bufferStepSize = 1 * 1024 * 1024;\n\n      properties.origin = flag.origin;\n\n      client.on(\"error\", err => {\n        client.removeAllListeners();\n        properties.error = err;\n        xhrUtils.dispatchError(this);\n      });\n\n      client.on(\"response\", (res, url) => receiveResponse(this, res, url));\n\n      client.on(\"redirect\", (response, requestHeaders, currentURL) => {\n        const destUrlObj = new URL(requestHeaders.Referer);\n        const urlObj = new URL(currentURL);\n\n        if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {\n          properties.origin = \"null\";\n        }\n\n        requestHeaders.Origin = properties.origin;\n\n        if (flag.origin !== destUrlObj.origin &&\n            destUrlObj.protocol !== \"data:\") {\n          if (!xhrUtils.validCORSHeaders(this, response, flag, properties, flag.origin)) {\n            return;\n          }\n          if (urlObj.username || urlObj.password) {\n            properties.error = \"Userinfo forbidden in cors redirect\";\n            xhrUtils.dispatchError(this);\n          }\n        }\n      });\n      if (body !== null && body !== \"\") {\n        properties.uploadComplete = false;\n        setDispatchProgressEvents(this);\n      } else {\n        properties.uploadComplete = true;\n      }\n      if (this.timeout > 0) {\n        properties.timeoutStart = (new Date()).getTime();\n        properties.timeoutFn = () => {\n          client.abort();\n          if (!(this.readyState === READY_STATES.UNSENT ||\n              (this.readyState === READY_STATES.OPENED && !properties.send) ||\n              this.readyState === READY_STATES.DONE)) {\n            properties.send = false;\n            let stateChanged = false;\n            if (!properties.uploadComplete) {\n              fireAnEvent(\"progress\", upload, ProgressEvent);\n              readyStateChange(this, READY_STATES.DONE);\n              fireAnEvent(\"timeout\", upload, ProgressEvent);\n              fireAnEvent(\"loadend\", upload, ProgressEvent);\n              stateChanged = true;\n            }\n            fireAnEvent(\"progress\", this, ProgressEvent);\n            if (!stateChanged) {\n              readyStateChange(this, READY_STATES.DONE);\n            }\n            fireAnEvent(\"timeout\", this, ProgressEvent);\n            fireAnEvent(\"loadend\", this, ProgressEvent);\n          }\n          this.readyState = READY_STATES.UNSENT;\n        };\n        properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);\n      }\n    }\n  }\n\n  setRequestHeader(header, value) {\n    const { flag, properties } = this;\n\n    if (this.readyState !== READY_STATES.OPENED || properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    value = normalizeHeaderValue(value);\n\n    if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {\n      throw DOMException.create(this._globalObject, [\n        \"The string did not match the expected pattern.\",\n        \"SyntaxError\"\n      ]);\n    }\n\n    const lcHeader = header.toLowerCase();\n\n    if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith(\"sec-\") || lcHeader.startsWith(\"proxy-\")) {\n      return;\n    }\n\n    const keys = Object.keys(flag.requestHeaders);\n    let n = keys.length;\n    while (n--) {\n      const key = keys[n];\n      if (key.toLowerCase() === lcHeader) {\n        flag.requestHeaders[key] += \", \" + value;\n        return;\n      }\n    }\n    flag.requestHeaders[header] = value;\n  }\n}\n\nsetupForSimpleEventAccessors(XMLHttpRequestImpl.prototype, [\"readystatechange\"]);\n\nfunction readyStateChange(xhr, readyState) {\n  if (xhr.readyState === readyState) {\n    return;\n  }\n\n  xhr.readyState = readyState;\n\n  fireAnEvent(\"readystatechange\", xhr);\n}\n\nfunction receiveResponse(xhr, response, currentURL) {\n  const { flag, properties } = xhr;\n  const { rawHeaders, statusCode } = response;\n\n  let byteOffset = 0;\n\n  const headers = {};\n  const filteredResponseHeaders = [];\n  const headerMap = {};\n  const n = Number(rawHeaders.length);\n  for (let i = 0; i < n; i += 2) {\n    const k = rawHeaders[i];\n    const kl = k.toLowerCase();\n    const v = rawHeaders[i + 1];\n    if (uniqueResponseHeaders.has(kl)) {\n      if (headerMap[kl] !== undefined) {\n        delete headers[headerMap[kl]];\n      }\n      headers[k] = v;\n    } else if (headerMap[kl] !== undefined) {\n      headers[headerMap[kl]] += \", \" + v;\n    } else {\n      headers[k] = v;\n    }\n    headerMap[kl] = k;\n  }\n\n  const destUrlObj = new URL(currentURL);\n  if (properties.origin !== destUrlObj.origin &&\n      destUrlObj.protocol !== \"data:\") {\n    if (!xhrUtils.validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n      return;\n    }\n    const acehStr = response.headers[\"access-control-expose-headers\"];\n    const aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(xhrUtils.headerListSeparatorRegexp) : []);\n    for (const header in headers) {\n      const lcHeader = header.toLowerCase();\n      if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {\n        filteredResponseHeaders.push(header);\n      }\n    }\n  }\n\n  for (const header in headers) {\n    const lcHeader = header.toLowerCase();\n    if (forbiddenResponseHeaders.has(lcHeader)) {\n      filteredResponseHeaders.push(header);\n    }\n  }\n\n  xhr.responseURL = destUrlObj.href;\n\n  xhr.status = statusCode;\n  xhr.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || \"\";\n\n  properties.responseHeaders = headers;\n  properties.filteredResponseHeaders = filteredResponseHeaders;\n\n  const contentLength = getResponseHeader(xhr, \"content-length\") || \"0\";\n  const bufferLength = parseInt(contentLength) || 0;\n  const progressObj = { lengthComputable: false };\n  let lastProgressReported;\n  if (bufferLength !== 0) {\n    progressObj.total = bufferLength;\n    progressObj.loaded = 0;\n    progressObj.lengthComputable = true;\n  }\n  // pre-allocate buffer.\n  properties.responseBuffer = Buffer.alloc(properties.bufferStepSize);\n  properties.responseCache = null;\n  properties.responseTextCache = null;\n  properties.responseXMLCache = null;\n  readyStateChange(xhr, READY_STATES.HEADERS_RECEIVED);\n\n  if (!properties.client) {\n    // The request was aborted in reaction to the readystatechange event.\n    return;\n  }\n\n  // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the\n  // Content-Length).\n  response.on(\"data\", chunk => {\n    byteOffset += chunk.length;\n    progressObj.loaded = byteOffset;\n  });\n\n  properties.client.on(\"data\", chunk => {\n    properties.totalReceivedChunkSize += chunk.length;\n    if (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n      properties.bufferStepSize *= 2;\n      while (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n        properties.bufferStepSize *= 2;\n      }\n      const tmpBuf = Buffer.alloc(properties.bufferStepSize);\n      properties.responseBuffer.copy(tmpBuf, 0, 0, properties.responseBuffer.length);\n      properties.responseBuffer = tmpBuf;\n    }\n    chunk.copy(properties.responseBuffer, properties.totalReceivedChunkSize - chunk.length, 0, chunk.length);\n    properties.responseCache = null;\n    properties.responseTextCache = null;\n    properties.responseXMLCache = null;\n\n    if (xhr.readyState === READY_STATES.HEADERS_RECEIVED) {\n      xhr.readyState = READY_STATES.LOADING;\n    }\n    fireAnEvent(\"readystatechange\", xhr);\n\n    if (progressObj.total !== progressObj.loaded || properties.totalReceivedChunkSize === byteOffset) {\n      if (lastProgressReported !== progressObj.loaded) {\n        // This is a necessary check in the gzip case where we can be getting new data from the client, as it\n        // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.\n        lastProgressReported = progressObj.loaded;\n        fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n      }\n    }\n  });\n  properties.client.on(\"end\", () => {\n    clearTimeout(properties.timeoutId);\n    properties.timeoutFn = null;\n    properties.timeoutStart = 0;\n    properties.client = null;\n    if (lastProgressReported !== progressObj.loaded) {\n      // https://github.com/whatwg/xhr/issues/318\n      fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n    }\n    readyStateChange(xhr, READY_STATES.DONE);\n    fireAnEvent(\"load\", xhr, ProgressEvent, progressObj);\n    fireAnEvent(\"loadend\", xhr, ProgressEvent, progressObj);\n  });\n}\n\nfunction setDispatchProgressEvents(xhr) {\n  const { properties, upload } = xhr;\n  const { client } = properties;\n\n  let total = 0;\n  let lengthComputable = false;\n  const length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, \"content-length\"));\n  if (length) {\n    total = length;\n    lengthComputable = true;\n  }\n  const initProgress = {\n    lengthComputable,\n    total,\n    loaded: 0\n  };\n\n  if (properties.uploadListener) {\n    fireAnEvent(\"loadstart\", upload, ProgressEvent, initProgress);\n  }\n\n  client.on(\"request\", req => {\n    req.on(\"response\", () => {\n      properties.uploadComplete = true;\n\n      if (!properties.uploadListener) {\n        return;\n      }\n\n      const progress = {\n        lengthComputable,\n        total,\n        loaded: total\n      };\n      fireAnEvent(\"progress\", upload, ProgressEvent, progress);\n      fireAnEvent(\"load\", upload, ProgressEvent, progress);\n      fireAnEvent(\"loadend\", upload, ProgressEvent, progress);\n    });\n  });\n}\n\nfunction finalMIMEType(xhr) {\n  const { flag } = xhr;\n  return flag.overrideMIMEType || getResponseHeader(xhr, \"content-type\");\n}\n\nfunction finalCharset(xhr) {\n  const { flag } = xhr;\n  if (flag.overrideCharset) {\n    return flag.overrideCharset;\n  }\n  const parsedContentType = MIMEType.parse(getResponseHeader(xhr, \"content-type\"));\n  if (parsedContentType) {\n    return whatwgEncoding.labelToName(parsedContentType.parameters.get(\"charset\"));\n  }\n  return null;\n}\n\nfunction getResponseHeader(xhr, lcHeader) {\n  const { properties } = xhr;\n  const keys = Object.keys(properties.responseHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      return properties.responseHeaders[key];\n    }\n  }\n  return null;\n}\n\nfunction normalizeHeaderValue(value) {\n  return value.replace(/^[\\x09\\x0A\\x0D\\x20]+/, \"\").replace(/[\\x09\\x0A\\x0D\\x20]+$/, \"\");\n}\n\nfunction extractBody(bodyInit) {\n  // https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n  // except we represent the body as a Node.js Buffer instead,\n  // or a special case for FormData since we want request to handle that. Probably it would be\n  // cleaner (and allow a future without request) if we did the form encoding ourself.\n\n  if (Blob.isImpl(bodyInit)) {\n    return {\n      buffer: bodyInit._buffer,\n      contentType: bodyInit.type === \"\" ? null : bodyInit.type\n    };\n  } else if (isArrayBuffer(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit),\n      contentType: null\n    };\n  } else if (ArrayBuffer.isView(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength),\n      contentType: null\n    };\n  } else if (FormData.isImpl(bodyInit)) {\n    const formData = [];\n    for (const entry of bodyInit._entries) {\n      let val;\n      if (Blob.isImpl(entry.value)) {\n        const blob = entry.value;\n        val = {\n          name: entry.name,\n          value: blob._buffer,\n          options: {\n            filename: blob.name,\n            contentType: blob.type,\n            knownLength: blob.size\n          }\n        };\n      } else {\n        val = entry;\n      }\n\n      formData.push(val);\n    }\n\n    return { formData };\n  }\n\n  // Must be a string\n  return {\n    buffer: Buffer.from(bodyInit, \"utf-8\"),\n    contentType: \"text/plain;charset=UTF-8\"\n  };\n}\n\nexports.implementation = XMLHttpRequestImpl;\n"]},"metadata":{},"sourceType":"script"}