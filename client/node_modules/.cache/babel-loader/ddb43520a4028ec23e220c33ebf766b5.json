{"ast":null,"code":"var _classCallCheck = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\n/** @ignore */\nvar scramjet = require(\".\");\n/** @ignore */\n\n\nvar SPLIT_LINE = /\\r\\n?|\\n/g;\n/**\n * A stream of string objects for further transformation on top of DataStream.\n *\n * Example:\n *\n * ```js\n * StringStream.from(async () => (await fetch('https://example.com/data/article.txt')).text())\n *     .lines()\n *     .append(\"\\r\\n\")\n *     .pipe(fs.createWriteStream('./path/to/file.txt'))\n * ```\n * @extends DataStream\n * @memberof module:scramjet.\n * @scope public\n */\n\nvar StringStream = /*#__PURE__*/function (_scramjet$DataStream) {\n  \"use strict\";\n\n  _inherits(StringStream, _scramjet$DataStream);\n\n  var _super = _createSuper(StringStream);\n\n  /**\n   * Constructs the stream with the given encoding\n   *\n   * @param  {string} [encoding=\"utf-8\"] the encoding to use\n   * @param  {DataStreamOptions} [options={}] the encoding to use\n   * @return {StringStream}  the created data stream\n   *\n   * @test test/methods/string-stream-constructor.js\n   */\n  function StringStream(encoding, options) {\n    var _this;\n\n    _classCallCheck(this, StringStream);\n\n    _this = _super.call(this, typeof encoding === \"string\" ? options : encoding);\n    _this.buffer = \"\";\n    _this.encoding = typeof encoding === \"string\" ? encoding : \"utf8\";\n    return _this;\n  }\n  /**\n   * @callback ShiftStringCallback\n   * @memberof module:scramjet~\n   * @param {string|any} shifted Shifted chars\n   */\n\n  /**\n   * Shifts given length of chars from the original stream\n   *\n   * Works the same way as {@see DataStream.shift}, but in this case extracts\n   * the given number of characters.\n   *\n   * @chainable\n   * @alias module:scramjet.StringStream#pop\n   * @alias module:scramjet.StringStream#shift\n   * @param {number} bytes The number of characters to shift.\n   * @param {ShiftStringCallback} func Function that receives a string of shifted chars.\n   *\n   * @test test/methods/string-stream-shift.js\n   */\n\n\n  _createClass(StringStream, [{\n    key: \"shift\",\n    value: function shift(bytes, func) {\n      var _this2 = this;\n\n      var ret = \"\";\n\n      var str = this.tap()._selfInstance({\n        referrer: this\n      });\n\n      var offs = 0;\n\n      var chunkHandler = function chunkHandler(chunk) {\n        var length = Math.min(bytes - offs, chunk.length);\n        chunk.substr(0, length);\n        offs += length;\n\n        if (length >= bytes) {\n          unHook().then(function () {\n            str.write(chunk.slice(length));\n\n            _this2.pipe(str);\n          });\n        }\n      };\n\n      var endHandler = function endHandler() {\n        if (ret.length < bytes) {\n          unHook();\n        }\n\n        str.end.apply(str, arguments);\n      };\n\n      var errorHandler = str.emit.bind(str, \"error\");\n\n      var unHook = function unHook() {\n        _this2.removeListener(\"data\", chunkHandler);\n\n        _this2.removeListener(\"end\", endHandler);\n\n        _this2.removeListener(\"error\", errorHandler);\n\n        return Promise.resolve(ret).then(func);\n      };\n\n      this.on(\"data\", chunkHandler);\n      this.on(\"end\", endHandler);\n      this.on(\"error\", errorHandler);\n      return str;\n    }\n    /**\n     * A handy split by line regex to quickly get a line-by-line stream\n     */\n\n  }, {\n    key: \"split\",\n    value:\n    /**\n     * Splits the string stream by the specified RegExp or string\n     *\n     * @chainable\n     * @param  {RegExp|string} splitter What to split by\n     *\n     * @test test/methods/string-stream-split.js\n     */\n    function split(splitter) {\n      if (splitter instanceof RegExp || typeof splitter === \"string\") {\n        return this.tap().pipe(this._selfInstance({\n          transform: function transform(chunk, encoding, callback) {\n            this.buffer += chunk.toString(this.encoding);\n            var newChunks = this.buffer.split(splitter);\n\n            while (newChunks.length > 1) {\n              this.push(newChunks.shift());\n            }\n\n            this.buffer = newChunks[0];\n            callback();\n          },\n          flush: function flush(callback) {\n            this.push(this.buffer);\n            this.buffer = \"\";\n            callback();\n          },\n          referrer: this\n        }));\n      } else if (splitter instanceof Function) {\n        return this.tap().pipe(new this.constructor({\n          transform: splitter,\n          referrer: this\n        }));\n      }\n    }\n    /**\n     * Finds matches in the string stream and streams the match results\n     *\n     * @chainable\n     * @param  {RegExp} matcher A function that will be called for every\n     *                             stream chunk.\n     *\n     * @test test/methods/string-stream-match.js\n     */\n\n  }, {\n    key: \"match\",\n    value: function match(matcher) {\n      if (matcher instanceof RegExp) {\n        var replaceRegex = matcher.source.search(/\\((?!\\?)/g) > -1 ? new RegExp(\"[\\\\s\\\\S]*?\" + matcher.source, (matcher.ignoreCase ? \"i\" : \"\") + (matcher.multiline ? \"m\" : \"\") + (matcher.unicode ? \"u\" : \"\") + \"g\") : new RegExp(\"[\\\\s\\\\S]*?(\" + matcher.source + \")\", (matcher.ignoreCase ? \"i\" : \"\") + (matcher.multiline ? \"m\" : \"\") + (matcher.unicode ? \"u\" : \"\") + \"g\");\n        return this.tap().pipe(this._selfInstance({\n          transform: function transform(chunk, encoding, callback) {\n            var _this3 = this;\n\n            this.buffer = (this.buffer || \"\") + chunk.toString(\"utf-8\");\n            this.buffer = this.buffer.replace(replaceRegex, function () {\n              for (var _len = arguments.length, match = new Array(_len), _key = 0; _key < _len; _key++) {\n                match[_key] = arguments[_key];\n              }\n\n              _this3.push(match.slice(1, match.length - 2).join(\"\"));\n\n              return \"\";\n            });\n            callback();\n          },\n          referrer: this\n        }));\n      }\n\n      throw new Error(\"Matcher must be a RegExp!\");\n    }\n    /**\n     * Transforms the StringStream to BufferStream\n     *\n     * Creates a buffer stream from the given string stream. Still it returns a\n     * DataStream derivative and isn't the typical node.js stream so you can do\n     * all your transforms when you like.\n     *\n     * @meta.noReadme\n     * @chainable\n     * @return {BufferStream}  The converted stream.\n     *\n     * @test test/methods/string-stream-tobufferstream.js\n     */\n\n  }, {\n    key: \"toBufferStream\",\n    value: function toBufferStream() {\n      var _this4 = this;\n\n      return this.tap().map(function (str) {\n        return Buffer.from(str, _this4.encoding);\n      }, new scramjet.BufferStream({\n        referrer: this\n      }));\n    }\n  }, {\n    key: \"toStringStream\",\n    value: function toStringStream(encoding) {\n      if (encoding) return this.tap().pipe(this._selfInstance(encoding, {\n        referrer: this\n      }));else return this;\n    }\n    /**\n     * @callback ParseCallback\n     * @memberof module:scramjet~\n     * @param {string} chunk the transformed chunk\n     * @return {Promise<any>|any}  the promise should be resolved with the parsed object\n     */\n\n    /**\n      * Parses every string to object\n      *\n      * The method MUST parse EVERY string into a single object, so the string\n      * stream here should already be split.\n      *\n      * @chainable\n      * @param  {ParseCallback} parser The transform function\n      * @param {function(new:DataStream)} [StreamClass] the output stream class to return\n      * @return {DataStream}  The parsed objects stream.\n      *\n      * @test test/methods/string-stream-parse.js\n      */\n\n  }, {\n    key: \"parse\",\n    value: function parse(parser) {\n      var StreamClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scramjet.DataStream;\n      return this.tap().map(parser, StreamClass);\n    }\n    /**\n     * Alias for {@link StringStream#parse}\n     * @memberof module:scramjet.StringStream#\n     * @method toDataStream\n     */\n\n    /**\n      * @meta.noReadme\n      * @ignore\n      */\n\n  }, {\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      this.push(chunk.toString(this.encoding));\n      return callback();\n    }\n    /**\n     * Creates a StringStream and writes a specific string.\n     *\n     * @param  {string} stream   the string to push the your stream\n     * @param  {string} encoding optional encoding\n     * @return {StringStream}          new StringStream.\n     */\n\n  }], [{\n    key: \"SPLIT_LINE\",\n    get: function get() {\n      return SPLIT_LINE;\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(stream, encoding) {\n      var st = new this(encoding || \"utf-8\");\n      st.end(stream);\n      return st;\n    }\n    /**\n     * Creates a pipeline of streams and returns a scramjet stream.\n     *\n     * @see DataStream.pipeline\n     * @static\n     * @param {Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|string|Readable} readable the initial readable argument that is streamable by scramjet.from\n     * @param {AsyncFunction|Function|Transform} transforms Transform functions (as in {@link DataStream..use}) or Transform streams (any number of these as consecutive arguments)\n     *\n     * @returns {StringStream} a new StringStream instance of the resulting pipeline\n     */\n\n  }, {\n    key: \"pipeline\",\n    value: function pipeline() {\n      var _scramjet$DataStream$;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return (_scramjet$DataStream$ = scramjet.DataStream.pipeline).call.apply(_scramjet$DataStream$, [this].concat(args));\n    }\n    /**\n     * Create StringStream from anything.\n     *\n     * @see DataStream.from\n     * @see module:scramjet.from\n     *\n     * @param {string|Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|Readable} source argument to be turned into new stream\n     * @param {DataStreamOptions|Writable} [options={}]\n     * @return {StringStream}          new StringStream.\n     */\n\n  }, {\n    key: \"from\",\n    value: function from(source, options) {\n      try {\n        var _scramjet$DataStream$2;\n\n        for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n          args[_key3 - 2] = arguments[_key3];\n        }\n\n        return (_scramjet$DataStream$2 = scramjet.DataStream.from).call.apply(_scramjet$DataStream$2, [this, source, options].concat(args));\n      } catch (e) {\n        if (typeof source === \"string\") {\n          return this.fromString(source);\n        }\n\n        throw e;\n      }\n    }\n  }]);\n\n  return StringStream;\n}(scramjet.DataStream);\n/**\n * @ignore\n */\n\n\nStringStream.prototype.pop = StringStream.prototype.shift;\nmodule.exports = StringStream;","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/client/node_modules/scramjet-core/lib/string-stream.js"],"names":["scramjet","require","SPLIT_LINE","StringStream","encoding","options","buffer","bytes","func","ret","str","tap","_selfInstance","referrer","offs","chunkHandler","chunk","length","Math","min","substr","unHook","then","write","slice","pipe","endHandler","end","errorHandler","emit","bind","removeListener","Promise","resolve","on","splitter","RegExp","transform","callback","toString","newChunks","split","push","shift","flush","Function","constructor","matcher","replaceRegex","source","search","ignoreCase","multiline","unicode","replace","match","join","Error","map","Buffer","from","BufferStream","parser","StreamClass","DataStream","stream","st","args","pipeline","call","e","fromString","prototype","pop","module","exports"],"mappings":"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","sourcesContent":["/** @ignore */\nconst scramjet = require(\".\");\n\n/** @ignore */\nconst SPLIT_LINE = /\\r\\n?|\\n/g;\n\n/**\n * A stream of string objects for further transformation on top of DataStream.\n *\n * Example:\n *\n * ```js\n * StringStream.from(async () => (await fetch('https://example.com/data/article.txt')).text())\n *     .lines()\n *     .append(\"\\r\\n\")\n *     .pipe(fs.createWriteStream('./path/to/file.txt'))\n * ```\n * @extends DataStream\n * @memberof module:scramjet.\n * @scope public\n */\nclass StringStream extends scramjet.DataStream {\n\n    /**\n     * Constructs the stream with the given encoding\n     *\n     * @param  {string} [encoding=\"utf-8\"] the encoding to use\n     * @param  {DataStreamOptions} [options={}] the encoding to use\n     * @return {StringStream}  the created data stream\n     *\n     * @test test/methods/string-stream-constructor.js\n     */\n    constructor(encoding, options) {\n        super(typeof encoding === \"string\" ? options : encoding);\n\n        this.buffer = \"\";\n        this.encoding = typeof encoding === \"string\" ? encoding : \"utf8\";\n    }\n\n    /**\n     * @callback ShiftStringCallback\n     * @memberof module:scramjet~\n     * @param {string|any} shifted Shifted chars\n     */\n\n    /**\n     * Shifts given length of chars from the original stream\n     *\n     * Works the same way as {@see DataStream.shift}, but in this case extracts\n     * the given number of characters.\n     *\n     * @chainable\n     * @alias module:scramjet.StringStream#pop\n     * @alias module:scramjet.StringStream#shift\n     * @param {number} bytes The number of characters to shift.\n     * @param {ShiftStringCallback} func Function that receives a string of shifted chars.\n     *\n     * @test test/methods/string-stream-shift.js\n     */\n    shift(bytes, func) {\n        const ret = \"\";\n        const str = this.tap()._selfInstance({\n            referrer: this\n        });\n        let offs = 0;\n\n        const chunkHandler = (chunk) => {\n            const length = Math.min(bytes - offs, chunk.length);\n            chunk.substr(0, length);\n            offs += length;\n            if (length >= bytes) {\n                unHook()\n                    .then(\n                        () => {\n                            str.write(chunk.slice(length));\n                            this.pipe(str);\n                        }\n                    );\n            }\n        };\n\n        const endHandler = (...args) => {\n            if (ret.length < bytes) {\n                unHook();\n            }\n            str.end(...args);\n        };\n\n        const errorHandler = str.emit.bind(str, \"error\");\n\n        const unHook = () => {\n            this.removeListener(\"data\", chunkHandler);\n            this.removeListener(\"end\", endHandler);\n            this.removeListener(\"error\", errorHandler);\n            return Promise.resolve(ret)\n                .then(func);\n        };\n\n\n        this.on(\"data\", chunkHandler);\n        this.on(\"end\", endHandler);\n        this.on(\"error\", errorHandler);\n\n        return str;\n    }\n\n    /**\n     * A handy split by line regex to quickly get a line-by-line stream\n     */\n    static get SPLIT_LINE() {\n        return SPLIT_LINE;\n    }\n\n    /**\n     * Splits the string stream by the specified RegExp or string\n     *\n     * @chainable\n     * @param  {RegExp|string} splitter What to split by\n     *\n     * @test test/methods/string-stream-split.js\n     */\n    split(splitter) {\n        if (splitter instanceof RegExp || typeof splitter === \"string\") {\n            return this.tap().pipe(this._selfInstance({\n                transform(chunk, encoding, callback) {\n                    this.buffer += chunk.toString(this.encoding);\n                    const newChunks = this.buffer.split(splitter);\n                    while(newChunks.length > 1) {\n                        this.push(newChunks.shift());\n                    }\n                    this.buffer = newChunks[0];\n                    callback();\n                },\n                flush(callback) {\n                    this.push(this.buffer);\n                    this.buffer = \"\";\n                    callback();\n                },\n                referrer: this\n            }));\n        } else if (splitter instanceof Function) {\n            return this.tap().pipe(new (this.constructor)({\n                transform: splitter,\n                referrer: this\n            }));\n        }\n    }\n\n    /**\n     * Finds matches in the string stream and streams the match results\n     *\n     * @chainable\n     * @param  {RegExp} matcher A function that will be called for every\n     *                             stream chunk.\n     *\n     * @test test/methods/string-stream-match.js\n     */\n    match(matcher) {\n        if (matcher instanceof RegExp) {\n            const replaceRegex = (matcher.source.search(/\\((?!\\?)/g) > -1) ?\n                new RegExp(\"[\\\\s\\\\S]*?\" + matcher.source, (matcher.ignoreCase ? \"i\" : \"\") + (matcher.multiline ? \"m\" : \"\") + (matcher.unicode ? \"u\" : \"\") + \"g\") :\n                new RegExp(\"[\\\\s\\\\S]*?(\" + matcher.source + \")\", (matcher.ignoreCase ? \"i\" : \"\") + (matcher.multiline ? \"m\" : \"\") + (matcher.unicode ? \"u\" : \"\") + \"g\")\n                ;\n\n            return this.tap().pipe(this._selfInstance({\n                transform(chunk, encoding, callback) {\n                    this.buffer = (this.buffer || \"\") + chunk.toString(\"utf-8\");\n                    this.buffer = this.buffer.replace(replaceRegex, (...match) => {\n                        this.push(match.slice(1, match.length - 2).join(\"\"));\n                        return \"\";\n                    });\n\n                    callback();\n                },\n                referrer: this\n            }));\n\n        }\n        throw new Error(\"Matcher must be a RegExp!\");\n    }\n\n    /**\n     * Transforms the StringStream to BufferStream\n     *\n     * Creates a buffer stream from the given string stream. Still it returns a\n     * DataStream derivative and isn't the typical node.js stream so you can do\n     * all your transforms when you like.\n     *\n     * @meta.noReadme\n     * @chainable\n     * @return {BufferStream}  The converted stream.\n     *\n     * @test test/methods/string-stream-tobufferstream.js\n     */\n    toBufferStream() {\n        return this.tap().map(\n            (str) => Buffer.from(str, this.encoding),\n            new scramjet.BufferStream({\n                referrer: this\n            })\n        );\n    }\n\n    toStringStream(encoding) {\n        if (encoding)\n            return this.tap().pipe(this._selfInstance(encoding, {\n                referrer: this\n            }));\n        else\n            return this;\n    }\n\n    /**\n     * @callback ParseCallback\n     * @memberof module:scramjet~\n     * @param {string} chunk the transformed chunk\n     * @return {Promise<any>|any}  the promise should be resolved with the parsed object\n     */\n\n    /**\n      * Parses every string to object\n      *\n      * The method MUST parse EVERY string into a single object, so the string\n      * stream here should already be split.\n      *\n      * @chainable\n      * @param  {ParseCallback} parser The transform function\n      * @param {function(new:DataStream)} [StreamClass] the output stream class to return\n      * @return {DataStream}  The parsed objects stream.\n      *\n      * @test test/methods/string-stream-parse.js\n      */\n    parse(parser, StreamClass = scramjet.DataStream) {\n        return this.tap().map(parser, StreamClass);\n    }\n\n    /**\n     * Alias for {@link StringStream#parse}\n     * @memberof module:scramjet.StringStream#\n     * @method toDataStream\n     */\n\n    /**\n      * @meta.noReadme\n      * @ignore\n      */\n    _transform(chunk, encoding, callback) {\n        this.push(chunk.toString(this.encoding));\n        return callback();\n    }\n\n    /**\n     * Creates a StringStream and writes a specific string.\n     *\n     * @param  {string} stream   the string to push the your stream\n     * @param  {string} encoding optional encoding\n     * @return {StringStream}          new StringStream.\n     */\n    static fromString(stream, encoding) {\n        const st =  new this(encoding || \"utf-8\");\n        st.end(stream);\n        return st;\n    }\n\n    /**\n     * Creates a pipeline of streams and returns a scramjet stream.\n     *\n     * @see DataStream.pipeline\n     * @static\n     * @param {Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|string|Readable} readable the initial readable argument that is streamable by scramjet.from\n     * @param {AsyncFunction|Function|Transform} transforms Transform functions (as in {@link DataStream..use}) or Transform streams (any number of these as consecutive arguments)\n     *\n     * @returns {StringStream} a new StringStream instance of the resulting pipeline\n     */\n    static pipeline(...args) {\n        return scramjet.DataStream.pipeline.call(this, ...args);\n    }\n\n    /**\n     * Create StringStream from anything.\n     *\n     * @see DataStream.from\n     * @see module:scramjet.from\n     *\n     * @param {string|Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|Readable} source argument to be turned into new stream\n     * @param {DataStreamOptions|Writable} [options={}]\n     * @return {StringStream}          new StringStream.\n     */\n    static from(source, options, ...args) {\n        try {\n            return scramjet.DataStream.from.call(this, source, options, ...args);\n        } catch(e) {\n            if (typeof source === \"string\") {\n                return this.fromString(source);\n            }\n            throw e;\n        }\n    }\n\n}\n\n/**\n * @ignore\n */\nStringStream.prototype.pop = StringStream.prototype.shift;\n\nmodule.exports = StringStream;\n"]},"metadata":{},"sourceType":"script"}