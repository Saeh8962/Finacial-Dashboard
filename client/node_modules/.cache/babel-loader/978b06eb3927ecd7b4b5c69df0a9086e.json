{"ast":null,"code":"var _toConsumableArray = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require(\"./\"),\n    DataStream = _require.DataStream;\n\nvar _require2 = require(\"child_process\"),\n    spawn = _require2.spawn;\n\nvar path = require(\"path\");\n\nvar platform = require(\"os\").platform();\n/** @ignore */\n\n\nvar getCalleeDirname = require(\"scramjet-core/lib/util/utils\").getCalleeDirname;\n\nmodule.exports = {\n  /**\n   * Splits the string stream by the specified regexp or string\n   *\n   * @chainable\n   * @memberof module:scramjet.StringStream#\n   * @param  {string|RegExp} [eol=/\\r?\\n/] End of line string or regex\n   *\n   * @test test/methods/string-stream-split.js\n   */\n  lines: function lines() {\n    var eol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /\\r?\\n/;\n    return this.split(eol);\n  },\n\n  /**\n   * Parses each entry as JSON.\n   * Ignores empty lines\n   *\n   * @chainable\n   * @memberof module:scramjet.StringStream#\n   * @param {Boolean} [perLine=true] instructs to split per line\n   * @return {DataStream}  stream of parsed items\n   */\n  JSONParse: function JSONParse() {\n    var perLine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var str = this;\n\n    if (perLine) {\n      str = str.lines();\n    }\n\n    return str.filter(function (a) {\n      return a !== \"\";\n    }).parse(JSON.parse);\n  },\n\n  /**\n   * Parses CSV to DataString using 'papaparse' module.\n   *\n   * @chainable\n   * @memberof module:scramjet.StringStream#\n   * @param {object} [options={}] options for the papaparse.parse method.\n   * @return {DataStream}  stream of parsed items\n   * @test test/methods/data-stream-separate.js\n   */\n  CSVParse: function CSVParse() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var out = new DataStream();\n\n    require(\"papaparse\").parse(this, Object.assign(options, {\n      chunk: function () {\n        var _chunk = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref, parser) {\n          var data, errors;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  data = _ref.data, errors = _ref.errors;\n\n                  if (!errors.length) {\n                    _context.next = 3;\n                    break;\n                  }\n\n                  return _context.abrupt(\"return\", out.raise(Object.assign(new Error(), errors[0])));\n\n                case 3:\n                  if (out.write(data)) {\n                    _context.next = 8;\n                    break;\n                  }\n\n                  parser.pause();\n                  _context.next = 7;\n                  return out.whenDrained();\n\n                case 7:\n                  parser.resume();\n\n                case 8:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        function chunk(_x, _x2) {\n          return _chunk.apply(this, arguments);\n        }\n\n        return chunk;\n      }(),\n      complete: function complete() {\n        out.end();\n      },\n      error: function error(e) {\n        out.emit(\"error\", e);\n      }\n    }));\n\n    return out.flatten();\n  },\n\n  /**\n   * Appends given argument to all the items.\n   *\n   * @chainable\n   * @memberof module:scramjet.StringStream#\n   * @param {ThenFunction|string} param the argument to append. If function passed then it will be called and resolved and the resolution will be appended.\n   *\n   * @test test/methods/string-stream-append.js\n   */\n  append: function append(param) {\n    return typeof param === \"function\" ? this.map(function (item) {\n      return Promise.resolve(item).then(param).then(function (result) {\n        return item + result;\n      });\n    }) : this.map(function (item) {\n      return item + param;\n    });\n  },\n\n  /**\n   * Prepends given argument to all the items.\n   *\n   * @chainable\n   * @memberof module:scramjet.StringStream#\n   * @param {ThenFunction|string} param the argument to prepend. If function passed then it will be called and resolved\n   *                              and the resolution will be prepended.\n   *\n   * @test test/methods/string-stream-prepend.js\n   */\n  prepend: function prepend(param) {\n    return typeof param === \"function\" ? this.map(function (item) {\n      return Promise.resolve(item).then(param).then(function (result) {\n        return result + item;\n      });\n    }) : this.map(function (item) {\n      return param + item;\n    });\n  },\n\n  /**\n   * @typedef {object} ExecOptions\n   * @memberof module:scramjet~\n   * @property {number} [stream=1] (bitwise) the output stdio number to push out (defaults to stdout = 1)\n   * @property {string[]} [interpreter=[]] defaults to nothing, except on windows where \"cmd.exe /c\" will be spawned by default\n   * @extends child_process.SpawnOptions\n   */\n\n  /**\n   * Executes a given sub-process with arguments and pipes the current stream into it while returning the output as another DataStream.\n   *\n   * Pipes the current stream into the sub-processes stdin.\n   * The data is serialized and deserialized as JSON lines by default. You\n   * can provide your own alternative methods in the ExecOptions object.\n   *\n   * Note: if you're piping both stderr and stdout (options.stream=3) keep in mind that chunks may get mixed up!\n   *\n   * @param {string} command command to execute\n   * @memberof module:scramjet.StringStream#\n   * @param {ExecOptions|any} [options={}] options to be passed to `spawn` and defining serialization.\n   * @param {string[]} ...args additional arguments (will overwrite to SpawnOptions args even if not given)\n   *\n   * @test test/methods/string-stream-exec.js\n   */\n  exec: function exec(command, options) {\n    var shell = process.env.SHELL ? [process.env.SHELL] : platform === \"win32\" ? [\"cmd.exe\", \"/c\"] : [];\n\n    var _ref2 = options || {},\n        _ref2$stream = _ref2.stream,\n        stream = _ref2$stream === void 0 ? 1 : _ref2$stream,\n        _ref2$interpreter = _ref2.interpreter,\n        interpreter = _ref2$interpreter === void 0 ? shell : _ref2$interpreter;\n\n    var out = this.tap()._selfInstance({\n      referrer: this\n    });\n\n    var spawnOptions = Object.assign({}, options);\n    spawnOptions.stdio = [\"pipe\", \"pipe\", \"pipe\"];\n    var resolvedCommand = path.resolve(getCalleeDirname(1), command);\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    var actualArgs = interpreter && interpreter.length ? [].concat(_toConsumableArray(interpreter.slice(1)), [resolvedCommand], args) : args;\n    var actualCmd = interpreter && interpreter.length ? interpreter[0] : resolvedCommand;\n    var end = 1;\n\n    var ended = function ended() {\n      return end-- || out.end();\n    };\n\n    var proc = spawn(actualCmd, actualArgs, spawnOptions);\n    this.catch(function (e) {\n      return proc.kill(e.signal);\n    });\n    proc.on(\"error\", function (e) {\n      ended();\n      return out.raise(e);\n    });\n    proc.on(\"exit\", /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(exitCode) {\n        var error;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(exitCode > 0)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                error = Object.assign(new Error(\"Non-zero exitcode (\".concat(exitCode, \") returned from command \\\"\").concat(resolvedCommand, \"\\\"\")), {\n                  exitCode: exitCode\n                });\n                _context2.next = 4;\n                return out.raise(error);\n\n              case 4:\n                ended();\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x3) {\n        return _ref3.apply(this, arguments);\n      };\n    }());\n    this.pipe(proc.stdin);\n    proc.stdin.on(\"error\", /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(e) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (e.code === \"EPIPE\") {\n                  _context3.next = 3;\n                  break;\n                }\n\n                _context3.next = 3;\n                return out.raise(e);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      return function (_x4) {\n        return _ref4.apply(this, arguments);\n      };\n    }());\n    if (stream & 1) proc.stdout.on(\"end\", function () {\n      return ended();\n    }).pipe(out, {\n      end: false\n    });\n    if (stream & 2) proc.stderr.on(\"end\", function () {\n      return ended();\n    }).pipe(out, {\n      end: false\n    });\n    return out;\n  }\n};","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/client/node_modules/scramjet/lib/string-stream.js"],"names":["require","DataStream","spawn","path","platform","getCalleeDirname","module","exports","lines","eol","split","JSONParse","perLine","str","filter","a","parse","JSON","CSVParse","options","out","Object","assign","chunk","parser","data","errors","length","raise","Error","write","pause","whenDrained","resume","complete","end","error","e","emit","flatten","append","param","map","item","Promise","resolve","then","result","prepend","exec","command","shell","process","env","SHELL","stream","interpreter","tap","_selfInstance","referrer","spawnOptions","stdio","resolvedCommand","args","actualArgs","slice","actualCmd","ended","proc","catch","kill","signal","on","exitCode","pipe","stdin","code","stdout","stderr"],"mappings":";;;;;;AAAA,eAAqBA,OAAO,CAAC,IAAD,CAA5B;AAAA,IAAOC,UAAP,YAAOA,UAAP;;AACA,gBAAgBD,OAAO,CAAC,eAAD,CAAvB;AAAA,IAAOE,KAAP,aAAOA,KAAP;;AACA,IAAMC,IAAI,GAAGH,OAAO,CAAC,MAAD,CAApB;;AAEA,IAAMI,QAAQ,GAAGJ,OAAO,CAAC,IAAD,CAAP,CAAcI,QAAd,EAAjB;AAEA;;;AACA,IAAMC,gBAAgB,GAAGL,OAAO,CAAC,8BAAD,CAAP,CAAwCK,gBAAjE;;AAEAC,MAAM,CAACC,OAAP,GAAiB;AAEb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,KAXa,mBAWQ;AAAA,QAAfC,GAAe,uEAAT,OAAS;AACjB,WAAO,KAAKC,KAAL,CAAWD,GAAX,CAAP;AACH,GAbY;;AAeb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIE,EAAAA,SAxBa,uBAwBa;AAAA,QAAhBC,OAAgB,uEAAN,IAAM;AACtB,QAAIC,GAAG,GAAG,IAAV;;AACA,QAAID,OAAJ,EAAa;AACTC,MAAAA,GAAG,GAAGA,GAAG,CAACL,KAAJ,EAAN;AACH;;AAED,WAAOK,GAAG,CAACC,MAAJ,CAAW,UAAAC,CAAC;AAAA,aAAIA,CAAC,KAAK,EAAV;AAAA,KAAZ,EAA0BC,KAA1B,CAAgCC,IAAI,CAACD,KAArC,CAAP;AACH,GA/BY;;AAiCb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIE,EAAAA,QA1Ca,sBA0CU;AAAA,QAAdC,OAAc,uEAAJ,EAAI;AACnB,QAAMC,GAAG,GAAG,IAAInB,UAAJ,EAAZ;;AACAD,IAAAA,OAAO,CAAC,WAAD,CAAP,CAAqBgB,KAArB,CAA2B,IAA3B,EAAiCK,MAAM,CAACC,MAAP,CAAcH,OAAd,EAAuB;AACpDI,MAAAA,KAAK;AAAA,8EAAE,uBAAuBC,MAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAQC,kBAAAA,IAAR,QAAQA,IAAR,EAAcC,MAAd,QAAcA,MAAd;;AAAA,uBACCA,MAAM,CAACC,MADR;AAAA;AAAA;AAAA;;AAAA,mDAEQP,GAAG,CAACQ,KAAJ,CAAUP,MAAM,CAACC,MAAP,CAAc,IAAIO,KAAJ,EAAd,EAA2BH,MAAM,CAAC,CAAD,CAAjC,CAAV,CAFR;;AAAA;AAAA,sBAKEN,GAAG,CAACU,KAAJ,CAAUL,IAAV,CALF;AAAA;AAAA;AAAA;;AAMCD,kBAAAA,MAAM,CAACO,KAAP;AAND;AAAA,yBAOOX,GAAG,CAACY,WAAJ,EAPP;;AAAA;AAQCR,kBAAAA,MAAM,CAACS,MAAP;;AARD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,SAD+C;AAYpDC,MAAAA,QAAQ,EAAE,oBAAM;AACZd,QAAAA,GAAG,CAACe,GAAJ;AACH,OAdmD;AAepDC,MAAAA,KAAK,EAAE,eAACC,CAAD,EAAO;AACVjB,QAAAA,GAAG,CAACkB,IAAJ,CAAS,OAAT,EAAkBD,CAAlB;AACH;AAjBmD,KAAvB,CAAjC;;AAoBA,WAAOjB,GAAG,CAACmB,OAAJ,EAAP;AACH,GAjEY;;AAmEb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,MA5Ea,kBA4ENC,KA5EM,EA4EC;AACV,WAAO,OAAOA,KAAP,KAAiB,UAAjB,GAA8B,KAAKC,GAAL,CAAS,UAAAC,IAAI;AAAA,aAAIC,OAAO,CAACC,OAAR,CAAgBF,IAAhB,EAAsBG,IAAtB,CAA2BL,KAA3B,EAAkCK,IAAlC,CAAuC,UAACC,MAAD;AAAA,eAAYJ,IAAI,GAAGI,MAAnB;AAAA,OAAvC,CAAJ;AAAA,KAAb,CAA9B,GAAoH,KAAKL,GAAL,CAAS,UAAAC,IAAI;AAAA,aAAIA,IAAI,GAAGF,KAAX;AAAA,KAAb,CAA3H;AACH,GA9EY;;AAgFb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIO,EAAAA,OA1Fa,mBA0FLP,KA1FK,EA0FE;AACX,WAAO,OAAOA,KAAP,KAAiB,UAAjB,GAA8B,KAAKC,GAAL,CAAS,UAAAC,IAAI;AAAA,aAAIC,OAAO,CAACC,OAAR,CAAgBF,IAAhB,EAAsBG,IAAtB,CAA2BL,KAA3B,EAAkCK,IAAlC,CAAuC,UAACC,MAAD;AAAA,eAAYA,MAAM,GAAGJ,IAArB;AAAA,OAAvC,CAAJ;AAAA,KAAb,CAA9B,GAAoH,KAAKD,GAAL,CAAS,UAAAC,IAAI;AAAA,aAAIF,KAAK,GAAGE,IAAZ;AAAA,KAAb,CAA3H;AACH,GA5FY;;AA8Fb;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIM,EAAAA,IAtHa,gBAsHRC,OAtHQ,EAsHC/B,OAtHD,EAsHmB;AAC5B,QAAMgC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,KAAZ,GAAoB,CAACF,OAAO,CAACC,GAAR,CAAYC,KAAb,CAApB,GAA0ClD,QAAQ,KAAK,OAAb,GAAuB,CAAC,SAAD,EAAW,IAAX,CAAvB,GAA0C,EAAlG;;AACA,gBAA6Ce,OAAO,IAAI,EAAxD;AAAA,6BAAQoC,MAAR;AAAA,QAAQA,MAAR,6BAAiB,CAAjB;AAAA,kCAAoBC,WAApB;AAAA,QAAoBA,WAApB,kCAAkCL,KAAlC;;AAEA,QAAM/B,GAAG,GAAG,KAAKqC,GAAL,GAAWC,aAAX,CAAyB;AAACC,MAAAA,QAAQ,EAAE;AAAX,KAAzB,CAAZ;;AAEA,QAAMC,YAAY,GAAGvC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,OAAlB,CAArB;AACAyC,IAAAA,YAAY,CAACC,KAAb,GAAqB,CAAC,MAAD,EAAS,MAAT,EAAiB,MAAjB,CAArB;AAEA,QAAMC,eAAe,GAAG3D,IAAI,CAAC0C,OAAL,CAAaxC,gBAAgB,CAAC,CAAD,CAA7B,EAAkC6C,OAAlC,CAAxB;;AAT4B,sCAANa,IAAM;AAANA,MAAAA,IAAM;AAAA;;AAW5B,QAAMC,UAAU,GAAGR,WAAW,IAAIA,WAAW,CAAC7B,MAA3B,gCAAwC6B,WAAW,CAACS,KAAZ,CAAkB,CAAlB,CAAxC,IAA8DH,eAA9D,GAAkFC,IAAlF,IAA0FA,IAA7G;AACA,QAAMG,SAAS,GAAGV,WAAW,IAAIA,WAAW,CAAC7B,MAA3B,GAAoC6B,WAAW,CAAC,CAAD,CAA/C,GAAqDM,eAAvE;AAEA,QAAI3B,GAAG,GAAG,CAAV;;AACA,QAAMgC,KAAK,GAAG,SAARA,KAAQ;AAAA,aAAMhC,GAAG,MAAMf,GAAG,CAACe,GAAJ,EAAf;AAAA,KAAd;;AAEA,QAAMiC,IAAI,GAAGlE,KAAK,CAACgE,SAAD,EAAYF,UAAZ,EAAwBJ,YAAxB,CAAlB;AACA,SAAKS,KAAL,CAAW,UAAAhC,CAAC;AAAA,aAAI+B,IAAI,CAACE,IAAL,CAAUjC,CAAC,CAACkC,MAAZ,CAAJ;AAAA,KAAZ;AACAH,IAAAA,IAAI,CAACI,EAAL,CAAQ,OAAR,EAAiB,UAAAnC,CAAC,EAAI;AAClB8B,MAAAA,KAAK;AACL,aAAO/C,GAAG,CAACQ,KAAJ,CAAUS,CAAV,CAAP;AACH,KAHD;AAIA+B,IAAAA,IAAI,CAACI,EAAL,CAAQ,MAAR;AAAA,2EAAgB,kBAAMC,QAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACRA,QAAQ,GAAG,CADH;AAAA;AAAA;AAAA;;AAEFrC,gBAAAA,KAFE,GAEMf,MAAM,CAACC,MAAP,CAAc,IAAIO,KAAJ,8BAAgC4C,QAAhC,uCAAoEX,eAApE,QAAd,EAAuG;AAACW,kBAAAA,QAAQ,EAARA;AAAD,iBAAvG,CAFN;AAAA;AAAA,uBAGFrD,GAAG,CAACQ,KAAJ,CAAUQ,KAAV,CAHE;;AAAA;AAMZ+B,gBAAAA,KAAK;;AANO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAhB;;AAAA;AAAA;AAAA;AAAA;AASA,SAAKO,IAAL,CAAUN,IAAI,CAACO,KAAf;AACAP,IAAAA,IAAI,CAACO,KAAL,CAAWH,EAAX,CAAc,OAAd;AAAA,2EAAuB,kBAAMnC,CAAN;AAAA;AAAA;AAAA;AAAA;AAAA,oBACbA,CAAC,CAACuC,IAAF,KAAW,OADE;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAETxD,GAAG,CAACQ,KAAJ,CAAUS,CAAV,CAFS;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAvB;;AAAA;AAAA;AAAA;AAAA;AAMA,QAAIkB,MAAM,GAAG,CAAb,EAAgBa,IAAI,CAACS,MAAL,CAAYL,EAAZ,CAAe,KAAf,EAAsB;AAAA,aAAML,KAAK,EAAX;AAAA,KAAtB,EAAqCO,IAArC,CAA0CtD,GAA1C,EAA+C;AAACe,MAAAA,GAAG,EAAE;AAAN,KAA/C;AAChB,QAAIoB,MAAM,GAAG,CAAb,EAAgBa,IAAI,CAACU,MAAL,CAAYN,EAAZ,CAAe,KAAf,EAAsB;AAAA,aAAML,KAAK,EAAX;AAAA,KAAtB,EAAqCO,IAArC,CAA0CtD,GAA1C,EAA+C;AAACe,MAAAA,GAAG,EAAE;AAAN,KAA/C;AAEhB,WAAOf,GAAP;AAEH;AAlKY,CAAjB","sourcesContent":["const {DataStream} = require(\"./\");\nconst {spawn} = require(\"child_process\");\nconst path = require(\"path\");\n\nconst platform = require(\"os\").platform();\n\n/** @ignore */\nconst getCalleeDirname = require(\"scramjet-core/lib/util/utils\").getCalleeDirname;\n\nmodule.exports = {\n\n    /**\n     * Splits the string stream by the specified regexp or string\n     *\n     * @chainable\n     * @memberof module:scramjet.StringStream#\n     * @param  {string|RegExp} [eol=/\\r?\\n/] End of line string or regex\n     *\n     * @test test/methods/string-stream-split.js\n     */\n    lines(eol = /\\r?\\n/) {\n        return this.split(eol);\n    },\n\n    /**\n     * Parses each entry as JSON.\n     * Ignores empty lines\n     *\n     * @chainable\n     * @memberof module:scramjet.StringStream#\n     * @param {Boolean} [perLine=true] instructs to split per line\n     * @return {DataStream}  stream of parsed items\n     */\n    JSONParse(perLine = true) {\n        let str = this;\n        if (perLine) {\n            str = str.lines();\n        }\n\n        return str.filter(a => a !== \"\").parse(JSON.parse);\n    },\n\n    /**\n     * Parses CSV to DataString using 'papaparse' module.\n     *\n     * @chainable\n     * @memberof module:scramjet.StringStream#\n     * @param {object} [options={}] options for the papaparse.parse method.\n     * @return {DataStream}  stream of parsed items\n     * @test test/methods/data-stream-separate.js\n     */\n    CSVParse(options = {}) {\n        const out = new DataStream();\n        require(\"papaparse\").parse(this, Object.assign(options, {\n            chunk: async ({data, errors}, parser) => {\n                if (errors.length) {\n                    return out.raise(Object.assign(new Error(), errors[0]));\n                }\n\n                if (!out.write(data)) {\n                    parser.pause();\n                    await out.whenDrained();\n                    parser.resume();\n                }\n            },\n            complete: () => {\n                out.end();\n            },\n            error: (e) => {\n                out.emit(\"error\", e);\n            }\n        }));\n\n        return out.flatten();\n    },\n\n    /**\n     * Appends given argument to all the items.\n     *\n     * @chainable\n     * @memberof module:scramjet.StringStream#\n     * @param {ThenFunction|string} param the argument to append. If function passed then it will be called and resolved and the resolution will be appended.\n     *\n     * @test test/methods/string-stream-append.js\n     */\n    append(param) {\n        return typeof param === \"function\" ? this.map(item => Promise.resolve(item).then(param).then((result) => item + result)) : this.map(item => item + param);\n    },\n\n    /**\n     * Prepends given argument to all the items.\n     *\n     * @chainable\n     * @memberof module:scramjet.StringStream#\n     * @param {ThenFunction|string} param the argument to prepend. If function passed then it will be called and resolved\n     *                              and the resolution will be prepended.\n     *\n     * @test test/methods/string-stream-prepend.js\n     */\n    prepend(param) {\n        return typeof param === \"function\" ? this.map(item => Promise.resolve(item).then(param).then((result) => result + item)) : this.map(item => param + item);\n    },\n\n    /**\n     * @typedef {object} ExecOptions\n     * @memberof module:scramjet~\n     * @property {number} [stream=1] (bitwise) the output stdio number to push out (defaults to stdout = 1)\n     * @property {string[]} [interpreter=[]] defaults to nothing, except on windows where \"cmd.exe /c\" will be spawned by default\n     * @extends child_process.SpawnOptions\n     */\n\n    /**\n     * Executes a given sub-process with arguments and pipes the current stream into it while returning the output as another DataStream.\n     *\n     * Pipes the current stream into the sub-processes stdin.\n     * The data is serialized and deserialized as JSON lines by default. You\n     * can provide your own alternative methods in the ExecOptions object.\n     *\n     * Note: if you're piping both stderr and stdout (options.stream=3) keep in mind that chunks may get mixed up!\n     *\n     * @param {string} command command to execute\n     * @memberof module:scramjet.StringStream#\n     * @param {ExecOptions|any} [options={}] options to be passed to `spawn` and defining serialization.\n     * @param {string[]} ...args additional arguments (will overwrite to SpawnOptions args even if not given)\n     *\n     * @test test/methods/string-stream-exec.js\n     */\n    exec(command, options, ...args) {\n        const shell = process.env.SHELL ? [process.env.SHELL] : platform === \"win32\" ? [\"cmd.exe\",\"/c\"] : [];\n        const { stream = 1, interpreter = shell } = (options || {});\n\n        const out = this.tap()._selfInstance({referrer: this});\n\n        const spawnOptions = Object.assign({}, options);\n        spawnOptions.stdio = [\"pipe\", \"pipe\", \"pipe\"];\n\n        const resolvedCommand = path.resolve(getCalleeDirname(1), command);\n\n        const actualArgs = interpreter && interpreter.length ? [...interpreter.slice(1), resolvedCommand, ...args] : args;\n        const actualCmd = interpreter && interpreter.length ? interpreter[0] : resolvedCommand;\n\n        let end = 1;\n        const ended = () => end-- || out.end();\n\n        const proc = spawn(actualCmd, actualArgs, spawnOptions);\n        this.catch(e => proc.kill(e.signal));\n        proc.on(\"error\", e => {\n            ended();\n            return out.raise(e);\n        });\n        proc.on(\"exit\", async exitCode => {\n            if (exitCode > 0) {\n                const error = Object.assign(new Error(`Non-zero exitcode (${exitCode}) returned from command \"${resolvedCommand}\"`), {exitCode});\n                await out.raise(error);\n            }\n\n            ended();\n        });\n\n        this.pipe(proc.stdin);\n        proc.stdin.on(\"error\", async e => {\n            if (!(e.code === \"EPIPE\")) {\n                await out.raise(e);\n            }\n            // ignore EPIPE after end\n        });\n        if (stream & 1) proc.stdout.on(\"end\", () => ended()).pipe(out, {end: false});\n        if (stream & 2) proc.stderr.on(\"end\", () => ended()).pipe(out, {end: false});\n\n        return out;\n\n    }\n\n};\n"]},"metadata":{},"sourceType":"script"}