{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar packageInfo = require('../../package.json');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar net = require('net');\n\nvar tls = require('tls');\n\nvar os = require('os');\n\nvar crypto = require('crypto');\n\nvar DataStream = require('./data-stream');\n\nvar PassThrough = require('stream').PassThrough;\n\nvar shared = require('../shared'); // default timeout values in ms\n\n\nvar CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established\n\nvar SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client\n\nvar GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved\n\n/**\n * Generates a SMTP connection object\n *\n * Optional options object takes the following possible properties:\n *\n *  * **port** - is the port to connect to (defaults to 587 or 465)\n *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')\n *  * **secure** - use SSL\n *  * **ignoreTLS** - ignore server support for STARTTLS\n *  * **requireTLS** - forces the client to use STARTTLS\n *  * **name** - the name of the client server\n *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)\n *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)\n *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish\n *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)\n *  * **lmtp** - if true, uses LMTP instead of SMTP protocol\n *  * **logger** - bunyan compatible logger interface\n *  * **debug** - if true pass SMTP traffic to the logger\n *  * **tls** - options for createCredentials\n *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)\n *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls\n *\n * @constructor\n * @namespace SMTP Client module\n * @param {Object} [options] Option properties\n */\n\nvar SMTPConnection = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(SMTPConnection, _EventEmitter);\n\n  var _super = _createSuper(SMTPConnection);\n\n  function SMTPConnection(options) {\n    var _this;\n\n    _classCallCheck(this, SMTPConnection);\n\n    _this = _super.call(this, options);\n    _this.id = crypto.randomBytes(8).toString('base64').replace(/\\W/g, '');\n    _this.stage = 'init';\n    _this.options = options || {};\n    _this.secureConnection = !!_this.options.secure;\n    _this.alreadySecured = !!_this.options.secured;\n    _this.port = Number(_this.options.port) || (_this.secureConnection ? 465 : 587);\n    _this.host = _this.options.host || 'localhost';\n\n    if (typeof _this.options.secure === 'undefined' && _this.port === 465) {\n      // if secure option is not set but port is 465, then default to secure\n      _this.secureConnection = true;\n    }\n\n    _this.name = _this.options.name || _this._getHostname();\n    _this.logger = shared.getLogger(_this.options, {\n      component: _this.options.component || 'smtp-connection',\n      sid: _this.id\n    });\n    /**\n     * Expose version nr, just for the reference\n     * @type {String}\n     */\n\n    _this.version = packageInfo.version;\n    /**\n     * If true, then the user is authenticated\n     * @type {Boolean}\n     */\n\n    _this.authenticated = false;\n    /**\n     * If set to true, this instance is no longer active\n     * @private\n     */\n\n    _this.destroyed = false;\n    /**\n     * Defines if the current connection is secure or not. If not,\n     * STARTTLS can be used if available\n     * @private\n     */\n\n    _this.secure = !!_this.secureConnection;\n    /**\n     * Store incomplete messages coming from the server\n     * @private\n     */\n\n    _this._remainder = '';\n    /**\n     * Unprocessed responses from the server\n     * @type {Array}\n     */\n\n    _this._responseQueue = [];\n    _this.lastServerResponse = false;\n    /**\n     * The socket connecting to the server\n     * @publick\n     */\n\n    _this._socket = false;\n    /**\n     * Lists supported auth mechanisms\n     * @private\n     */\n\n    _this._supportedAuth = [];\n    /**\n     * Includes current envelope (from, to)\n     * @private\n     */\n\n    _this._envelope = false;\n    /**\n     * Lists supported extensions\n     * @private\n     */\n\n    _this._supportedExtensions = [];\n    /**\n     * Defines the maximum allowed size for a single message\n     * @private\n     */\n\n    _this._maxAllowedSize = 0;\n    /**\n     * Function queue to run if a data chunk comes from the server\n     * @private\n     */\n\n    _this._responseActions = [];\n    _this._recipientQueue = [];\n    /**\n     * Timeout variable for waiting the greeting\n     * @private\n     */\n\n    _this._greetingTimeout = false;\n    /**\n     * Timeout variable for waiting the connection to start\n     * @private\n     */\n\n    _this._connectionTimeout = false;\n    /**\n     * If the socket is deemed already closed\n     * @private\n     */\n\n    _this._destroyed = false;\n    /**\n     * If the socket is already being closed\n     * @private\n     */\n\n    _this._closing = false;\n    return _this;\n  }\n  /**\n   * Creates a connection to a SMTP server and sets up connection\n   * listener\n   */\n\n\n  _createClass(SMTPConnection, [{\n    key: \"connect\",\n    value: function connect(connectCallback) {\n      var _this2 = this;\n\n      if (typeof connectCallback === 'function') {\n        this.once('connect', function () {\n          _this2.logger.debug({\n            tnx: 'smtp'\n          }, 'SMTP handshake finished');\n\n          connectCallback();\n        });\n\n        var isDestroyedMessage = this._isDestroyedMessage('connect');\n\n        if (isDestroyedMessage) {\n          return connectCallback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'CONN'));\n        }\n      }\n\n      var opts = {\n        port: this.port,\n        host: this.host\n      };\n\n      if (this.options.localAddress) {\n        opts.localAddress = this.options.localAddress;\n      }\n\n      if (this.options.connection) {\n        // connection is already opened\n        this._socket = this.options.connection;\n\n        if (this.secureConnection && !this.alreadySecured) {\n          setImmediate(function () {\n            return _this2._upgradeConnection(function (err) {\n              if (err) {\n                _this2._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');\n\n                return;\n              }\n\n              _this2._onConnect();\n            });\n          });\n        } else {\n          setImmediate(function () {\n            return _this2._onConnect();\n          });\n        }\n      } else if (this.options.socket) {\n        // socket object is set up but not yet connected\n        this._socket = this.options.socket;\n\n        try {\n          this._socket.connect(this.port, this.host, function () {\n            _this2._socket.setKeepAlive(true);\n\n            _this2._onConnect();\n          });\n        } catch (E) {\n          return setImmediate(function () {\n            return _this2._onError(E, 'ECONNECTION', false, 'CONN');\n          });\n        }\n      } else if (this.secureConnection) {\n        // connect using tls\n        if (this.options.tls) {\n          Object.keys(this.options.tls).forEach(function (key) {\n            opts[key] = _this2.options.tls[key];\n          });\n        }\n\n        try {\n          this._socket = tls.connect(this.port, this.host, opts, function () {\n            _this2._socket.setKeepAlive(true);\n\n            _this2._onConnect();\n          });\n        } catch (E) {\n          return setImmediate(function () {\n            return _this2._onError(E, 'ECONNECTION', false, 'CONN');\n          });\n        }\n      } else {\n        // connect using plaintext\n        try {\n          this._socket = net.connect(opts, function () {\n            _this2._socket.setKeepAlive(true);\n\n            _this2._onConnect();\n          });\n        } catch (E) {\n          return setImmediate(function () {\n            return _this2._onError(E, 'ECONNECTION', false, 'CONN');\n          });\n        }\n      }\n\n      this._connectionTimeout = setTimeout(function () {\n        _this2._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');\n      }, this.options.connectionTimeout || CONNECTION_TIMEOUT);\n\n      this._socket.on('error', function (err) {\n        _this2._onError(err, 'ECONNECTION', false, 'CONN');\n      });\n    }\n    /**\n     * Sends QUIT\n     */\n\n  }, {\n    key: \"quit\",\n    value: function quit() {\n      this._sendCommand('QUIT');\n\n      this._responseActions.push(this.close);\n    }\n    /**\n     * Closes the connection to the server\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      clearTimeout(this._connectionTimeout);\n      clearTimeout(this._greetingTimeout);\n      this._responseActions = []; // allow to run this function only once\n\n      if (this._closing) {\n        return;\n      }\n\n      this._closing = true;\n      var closeMethod = 'end';\n\n      if (this.stage === 'init') {\n        // Close the socket immediately when connection timed out\n        closeMethod = 'destroy';\n      }\n\n      this.logger.debug({\n        tnx: 'smtp'\n      }, 'Closing connection to the server using \"%s\"', closeMethod);\n      var socket = this._socket && this._socket.socket || this._socket;\n\n      if (socket && !socket.destroyed) {\n        try {\n          this._socket[closeMethod]();\n        } catch (E) {// just ignore\n        }\n      }\n\n      this._destroy();\n    }\n    /**\n     * Authenticate user\n     */\n\n  }, {\n    key: \"login\",\n    value: function login(authData, callback) {\n      var _this3 = this;\n\n      var isDestroyedMessage = this._isDestroyedMessage('login');\n\n      if (isDestroyedMessage) {\n        return callback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n      }\n\n      this._auth = authData || {}; // Select SASL authentication method\n\n      this._authMethod = (this._auth.method || '').toString().trim().toUpperCase() || false;\n\n      if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {\n        this._authMethod = 'XOAUTH2';\n      } else if (!this._authMethod || this._authMethod === 'XOAUTH2' && !this._auth.oauth2) {\n        // use first supported\n        this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();\n      }\n\n      if (this._authMethod !== 'XOAUTH2' && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {\n        if (this._auth.user && this._auth.pass) {\n          this._auth.credentials = {\n            user: this._auth.user,\n            pass: this._auth.pass\n          };\n        } else {\n          return callback(this._formatError('Missing credentials for \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n        }\n      }\n\n      switch (this._authMethod) {\n        case 'XOAUTH2':\n          this._handleXOauth2Token(false, callback);\n\n          return;\n\n        case 'LOGIN':\n          this._responseActions.push(function (str) {\n            _this3._actionAUTH_LOGIN_USER(str, callback);\n          });\n\n          this._sendCommand('AUTH LOGIN');\n\n          return;\n\n        case 'PLAIN':\n          this._responseActions.push(function (str) {\n            _this3._actionAUTHComplete(str, callback);\n          });\n\n          this._sendCommand('AUTH PLAIN ' + Buffer.from( //this._auth.user+'\\u0000'+\n          \"\\0\" + // skip authorization identity as it causes problems with some servers\n          this._auth.credentials.user + \"\\0\" + this._auth.credentials.pass, 'utf-8').toString('base64'));\n\n          return;\n\n        case 'CRAM-MD5':\n          this._responseActions.push(function (str) {\n            _this3._actionAUTH_CRAM_MD5(str, callback);\n          });\n\n          this._sendCommand('AUTH CRAM-MD5');\n\n          return;\n      }\n\n      return callback(this._formatError('Unknown authentication method \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n    }\n    /**\n     * Sends a message\n     *\n     * @param {Object} envelope Envelope object, {from: addr, to: [addr]}\n     * @param {Object} message String, Buffer or a Stream\n     * @param {Function} callback Callback to return once sending is completed\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(envelope, message, done) {\n      var _this4 = this;\n\n      if (!message) {\n        return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));\n      }\n\n      var isDestroyedMessage = this._isDestroyedMessage('send message');\n\n      if (isDestroyedMessage) {\n        return done(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n      } // reject larger messages than allowed\n\n\n      if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {\n        return setImmediate(function () {\n          done(_this4._formatError('Message size larger than allowed ' + _this4._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));\n        });\n      } // ensure that callback is only called once\n\n\n      var returned = false;\n\n      var callback = function callback() {\n        if (returned) {\n          return;\n        }\n\n        returned = true;\n        done.apply(void 0, arguments);\n      };\n\n      if (typeof message.on === 'function') {\n        message.on('error', function (err) {\n          return callback(_this4._formatError(err, 'ESTREAM', false, 'API'));\n        });\n      }\n\n      var startTime = Date.now();\n\n      this._setEnvelope(envelope, function (err, info) {\n        if (err) {\n          return callback(err);\n        }\n\n        var envelopeTime = Date.now();\n\n        var stream = _this4._createSendStream(function (err, str) {\n          if (err) {\n            return callback(err);\n          }\n\n          info.envelopeTime = envelopeTime - startTime;\n          info.messageTime = Date.now() - envelopeTime;\n          info.messageSize = stream.outByteCount;\n          info.response = str;\n          return callback(null, info);\n        });\n\n        if (typeof message.pipe === 'function') {\n          message.pipe(stream);\n        } else {\n          stream.write(message);\n          stream.end();\n        }\n      });\n    }\n    /**\n     * Resets connection state\n     *\n     * @param {Function} callback Callback to return once connection is reset\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset(callback) {\n      var _this5 = this;\n\n      this._sendCommand('RSET');\n\n      this._responseActions.push(function (str) {\n        if (str.charAt(0) !== '2') {\n          return callback(_this5._formatError('Could not reset session state. response=' + str, 'EPROTOCOL', str, 'RSET'));\n        }\n\n        _this5._envelope = false;\n        return callback(null, true);\n      });\n    }\n    /**\n     * Connection listener that is run when the connection to\n     * the server is opened\n     *\n     * @event\n     */\n\n  }, {\n    key: \"_onConnect\",\n    value: function _onConnect() {\n      var _this6 = this;\n\n      clearTimeout(this._connectionTimeout);\n      this.logger.info({\n        tnx: 'network',\n        localAddress: this._socket.localAddress,\n        localPort: this._socket.localPort,\n        remoteAddress: this._socket.remoteAddress,\n        remotePort: this._socket.remotePort\n      }, '%s established to %s:%s', this.secure ? 'Secure connection' : 'Connection', this._socket.remoteAddress, this._socket.remotePort);\n\n      if (this._destroyed) {\n        // Connection was established after we already had canceled it\n        this.close();\n        return;\n      }\n\n      this.stage = 'connected'; // clear existing listeners for the socket\n\n      this._socket.removeAllListeners('data');\n\n      this._socket.removeAllListeners('timeout');\n\n      this._socket.removeAllListeners('close');\n\n      this._socket.removeAllListeners('end');\n\n      this._socket.on('data', function (chunk) {\n        return _this6._onData(chunk);\n      });\n\n      this._socket.once('close', function (errored) {\n        return _this6._onClose(errored);\n      });\n\n      this._socket.once('end', function () {\n        return _this6._onEnd();\n      });\n\n      this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);\n\n      this._socket.on('timeout', function () {\n        return _this6._onTimeout();\n      });\n\n      this._greetingTimeout = setTimeout(function () {\n        // if still waiting for greeting, give up\n        if (_this6._socket && !_this6._destroyed && _this6._responseActions[0] === _this6._actionGreeting) {\n          _this6._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');\n        }\n      }, this.options.greetingTimeout || GREETING_TIMEOUT);\n\n      this._responseActions.push(this._actionGreeting); // we have a 'data' listener set up so resume socket if it was paused\n\n\n      this._socket.resume();\n    }\n    /**\n     * 'data' listener for data coming from the server\n     *\n     * @event\n     * @param {Buffer} chunk Data chunk coming from the server\n     */\n\n  }, {\n    key: \"_onData\",\n    value: function _onData(chunk) {\n      if (this._destroyed || !chunk || !chunk.length) {\n        return;\n      }\n\n      var data = (chunk || '').toString('binary');\n      var lines = (this._remainder + data).split(/\\r?\\n/);\n      var lastline;\n      this._remainder = lines.pop();\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        if (this._responseQueue.length) {\n          lastline = this._responseQueue[this._responseQueue.length - 1];\n\n          if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n            this._responseQueue[this._responseQueue.length - 1] += '\\n' + lines[i];\n            continue;\n          }\n        }\n\n        this._responseQueue.push(lines[i]);\n      }\n\n      this._processResponse();\n    }\n    /**\n     * 'error' listener for the socket\n     *\n     * @event\n     * @param {Error} err Error object\n     * @param {String} type Error name\n     */\n\n  }, {\n    key: \"_onError\",\n    value: function _onError(err, type, data, command) {\n      clearTimeout(this._connectionTimeout);\n      clearTimeout(this._greetingTimeout);\n\n      if (this._destroyed) {\n        // just ignore, already closed\n        // this might happen when a socket is canceled because of reached timeout\n        // but the socket timeout error itself receives only after\n        return;\n      }\n\n      err = this._formatError(err, type, data, command);\n      this.logger.error(data, err.message);\n      this.emit('error', err);\n      this.close();\n    }\n  }, {\n    key: \"_formatError\",\n    value: function _formatError(message, type, response, command) {\n      var err;\n\n      if (/Error\\]$/i.test(Object.prototype.toString.call(message))) {\n        err = message;\n      } else {\n        err = new Error(message);\n      }\n\n      if (type && type !== 'Error') {\n        err.code = type;\n      }\n\n      if (response) {\n        err.response = response;\n        err.message += ': ' + response;\n      }\n\n      var responseCode = typeof response === 'string' && Number((response.match(/^\\d+/) || [])[0]) || false;\n\n      if (responseCode) {\n        err.responseCode = responseCode;\n      }\n\n      if (command) {\n        err.command = command;\n      }\n\n      return err;\n    }\n    /**\n     * 'close' listener for the socket\n     *\n     * @event\n     */\n\n  }, {\n    key: \"_onClose\",\n    value: function _onClose() {\n      this.logger.info({\n        tnx: 'network'\n      }, 'Connection closed');\n\n      if (this.upgrading && !this._destroyed) {\n        return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', false, 'CONN');\n      } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {\n        return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', false, 'CONN');\n      }\n\n      this._destroy();\n    }\n    /**\n     * 'end' listener for the socket\n     *\n     * @event\n     */\n\n  }, {\n    key: \"_onEnd\",\n    value: function _onEnd() {\n      this._destroy();\n    }\n    /**\n     * 'timeout' listener for the socket\n     *\n     * @event\n     */\n\n  }, {\n    key: \"_onTimeout\",\n    value: function _onTimeout() {\n      return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');\n    }\n    /**\n     * Destroys the client, emits 'end'\n     */\n\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      if (this._destroyed) {\n        return;\n      }\n\n      this._destroyed = true;\n      this.emit('end');\n    }\n    /**\n     * Upgrades the connection to TLS\n     *\n     * @param {Function} callback Callback function to run when the connection\n     *        has been secured\n     */\n\n  }, {\n    key: \"_upgradeConnection\",\n    value: function _upgradeConnection(callback) {\n      var _this7 = this;\n\n      // do not remove all listeners or it breaks node v0.10 as there's\n      // apparently a 'finish' event set that would be cleared as well\n      // we can safely keep 'error', 'end', 'close' etc. events\n      this._socket.removeAllListeners('data'); // incoming data is going to be gibberish from this point onwards\n\n\n      this._socket.removeAllListeners('timeout'); // timeout will be re-set for the new socket object\n\n\n      var socketPlain = this._socket;\n      var opts = {\n        socket: this._socket,\n        host: this.host\n      };\n      Object.keys(this.options.tls || {}).forEach(function (key) {\n        opts[key] = _this7.options.tls[key];\n      });\n      this.upgrading = true;\n      this._socket = tls.connect(opts, function () {\n        _this7.secure = true;\n        _this7.upgrading = false;\n\n        _this7._socket.on('data', function (chunk) {\n          return _this7._onData(chunk);\n        });\n\n        socketPlain.removeAllListeners('close');\n        socketPlain.removeAllListeners('end');\n        return callback(null, true);\n      });\n\n      this._socket.on('error', function (err) {\n        return _this7._onError(err, 'ESOCKET', false, 'CONN');\n      });\n\n      this._socket.once('close', function (errored) {\n        return _this7._onClose(errored);\n      });\n\n      this._socket.once('end', function () {\n        return _this7._onEnd();\n      });\n\n      this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.\n\n\n      this._socket.on('timeout', function () {\n        return _this7._onTimeout();\n      }); // resume in case the socket was paused\n\n\n      socketPlain.resume();\n    }\n    /**\n     * Processes queued responses from the server\n     *\n     * @param {Boolean} force If true, ignores _processing flag\n     */\n\n  }, {\n    key: \"_processResponse\",\n    value: function _processResponse() {\n      var _this8 = this;\n\n      if (!this._responseQueue.length) {\n        return false;\n      }\n\n      var str = this.lastServerResponse = (this._responseQueue.shift() || '').toString();\n\n      if (/^\\d+-/.test(str.split('\\n').pop())) {\n        // keep waiting for the final part of multiline response\n        return;\n      }\n\n      if (this.options.debug || this.options.transactionLog) {\n        this.logger.debug({\n          tnx: 'server'\n        }, str.replace(/\\r?\\n$/, ''));\n      }\n\n      if (!str.trim()) {\n        // skip unexpected empty lines\n        setImmediate(function () {\n          return _this8._processResponse(true);\n        });\n      }\n\n      var action = this._responseActions.shift();\n\n      if (typeof action === 'function') {\n        action.call(this, str);\n        setImmediate(function () {\n          return _this8._processResponse(true);\n        });\n      } else {\n        return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');\n      }\n    }\n    /**\n     * Send a command to the server, append \\r\\n\n     *\n     * @param {String} str String to be sent to the server\n     */\n\n  }, {\n    key: \"_sendCommand\",\n    value: function _sendCommand(str) {\n      if (this._destroyed) {\n        // Connection already closed, can't send any more data\n        return;\n      }\n\n      if (this._socket.destroyed) {\n        return this.close();\n      }\n\n      if (this.options.debug || this.options.transactionLog) {\n        this.logger.debug({\n          tnx: 'client'\n        }, (str || '').toString().replace(/\\r?\\n$/, ''));\n      }\n\n      this._socket.write(Buffer.from(str + '\\r\\n', 'utf-8'));\n    }\n    /**\n     * Initiates a new message by submitting envelope data, starting with\n     * MAIL FROM: command\n     *\n     * @param {Object} envelope Envelope object in the form of\n     *        {from:'...', to:['...']}\n     *        or\n     *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}\n     */\n\n  }, {\n    key: \"_setEnvelope\",\n    value: function _setEnvelope(envelope, callback) {\n      var _this9 = this;\n\n      var args = [];\n      var useSmtpUtf8 = false;\n      this._envelope = envelope || {};\n      this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || '').toString().trim();\n      this._envelope.to = [].concat(this._envelope.to || []).map(function (to) {\n        return (to && to.address || to || '').toString().trim();\n      });\n\n      if (!this._envelope.to.length) {\n        return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));\n      }\n\n      if (this._envelope.from && /[\\r\\n<>]/.test(this._envelope.from)) {\n        return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));\n      } // check if the sender address uses only ASCII characters,\n      // otherwise require usage of SMTPUTF8 extension\n\n\n      if (/[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n        useSmtpUtf8 = true;\n      }\n\n      for (var i = 0, len = this._envelope.to.length; i < len; i++) {\n        if (!this._envelope.to[i] || /[\\r\\n<>]/.test(this._envelope.to[i])) {\n          return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));\n        } // check if the recipients addresses use only ASCII characters,\n        // otherwise require usage of SMTPUTF8 extension\n\n\n        if (/[\\x80-\\uFFFF]/.test(this._envelope.to[i])) {\n          useSmtpUtf8 = true;\n        }\n      } // clone the recipients array for latter manipulation\n\n\n      this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));\n      this._envelope.rejected = [];\n      this._envelope.rejectedErrors = [];\n      this._envelope.accepted = [];\n\n      if (this._envelope.dsn) {\n        try {\n          this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);\n        } catch (err) {\n          return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));\n        }\n      }\n\n      this._responseActions.push(function (str) {\n        _this9._actionMAIL(str, callback);\n      }); // If the server supports SMTPUTF8 and the envelope includes an internationalized\n      // email address then append SMTPUTF8 keyword to the MAIL FROM command\n\n\n      if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {\n        args.push('SMTPUTF8');\n        this._usingSmtpUtf8 = true;\n      } // If the server supports 8BITMIME and the message might contain non-ascii bytes\n      // then append the 8BITMIME keyword to the MAIL FROM command\n\n\n      if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {\n        args.push('BODY=8BITMIME');\n        this._using8BitMime = true;\n      }\n\n      if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {\n        args.push('SIZE=' + this._envelope.size);\n      } // If the server supports DSN and the envelope includes an DSN prop\n      // then append DSN params to the MAIL FROM command\n\n\n      if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n        if (this._envelope.dsn.ret) {\n          args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));\n        }\n\n        if (this._envelope.dsn.envid) {\n          args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));\n        }\n      }\n\n      this._sendCommand('MAIL FROM:<' + this._envelope.from + '>' + (args.length ? ' ' + args.join(' ') : ''));\n    }\n  }, {\n    key: \"_setDsnEnvelope\",\n    value: function _setDsnEnvelope(params) {\n      var ret = (params.ret || params.return || '').toString().toUpperCase() || null;\n\n      if (ret) {\n        switch (ret) {\n          case 'HDRS':\n          case 'HEADERS':\n            ret = 'HDRS';\n            break;\n\n          case 'FULL':\n          case 'BODY':\n            ret = 'FULL';\n            break;\n        }\n      }\n\n      if (ret && !['FULL', 'HDRS'].includes(ret)) {\n        throw new Error('ret: ' + JSON.stringify(ret));\n      }\n\n      var envid = (params.envid || params.id || '').toString() || null;\n      var notify = params.notify || null;\n\n      if (notify) {\n        if (typeof notify === 'string') {\n          notify = notify.split(',');\n        }\n\n        notify = notify.map(function (n) {\n          return n.trim().toUpperCase();\n        });\n        var validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];\n        var invaliNotify = notify.filter(function (n) {\n          return !validNotify.includes(n);\n        });\n\n        if (invaliNotify.length || notify.length > 1 && notify.includes('NEVER')) {\n          throw new Error('notify: ' + JSON.stringify(notify.join(',')));\n        }\n\n        notify = notify.join(',');\n      }\n\n      var orcpt = (params.orcpt || params.recipient || '').toString() || null;\n\n      if (orcpt && orcpt.indexOf(';') < 0) {\n        orcpt = 'rfc822;' + orcpt;\n      }\n\n      return {\n        ret: ret,\n        envid: envid,\n        notify: notify,\n        orcpt: orcpt\n      };\n    }\n  }, {\n    key: \"_getDsnRcptToArgs\",\n    value: function _getDsnRcptToArgs() {\n      var args = []; // If the server supports DSN and the envelope includes an DSN prop\n      // then append DSN params to the RCPT TO command\n\n      if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n        if (this._envelope.dsn.notify) {\n          args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));\n        }\n\n        if (this._envelope.dsn.orcpt) {\n          args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));\n        }\n      }\n\n      return args.length ? ' ' + args.join(' ') : '';\n    }\n  }, {\n    key: \"_createSendStream\",\n    value: function _createSendStream(callback) {\n      var _this10 = this;\n\n      var dataStream = new DataStream();\n      var logStream;\n\n      if (this.options.lmtp) {\n        this._envelope.accepted.forEach(function (recipient, i) {\n          var final = i === _this10._envelope.accepted.length - 1;\n\n          _this10._responseActions.push(function (str) {\n            _this10._actionLMTPStream(recipient, final, str, callback);\n          });\n        });\n      } else {\n        this._responseActions.push(function (str) {\n          _this10._actionSMTPStream(str, callback);\n        });\n      }\n\n      dataStream.pipe(this._socket, {\n        end: false\n      });\n\n      if (this.options.debug) {\n        logStream = new PassThrough();\n        logStream.on('readable', function () {\n          var chunk;\n\n          while (chunk = logStream.read()) {\n            _this10.logger.debug({\n              tnx: 'message'\n            }, chunk.toString('binary').replace(/\\r?\\n$/, ''));\n          }\n        });\n        dataStream.pipe(logStream);\n      }\n\n      dataStream.once('end', function () {\n        _this10.logger.info({\n          tnx: 'message',\n          inByteCount: dataStream.inByteCount,\n          outByteCount: dataStream.outByteCount\n        }, '<%s bytes encoded mime message (source size %s bytes)>', dataStream.outByteCount, dataStream.inByteCount);\n      });\n      return dataStream;\n    }\n    /** ACTIONS **/\n\n    /**\n     * Will be run after the connection is created and the server sends\n     * a greeting. If the incoming message starts with 220 initiate\n     * SMTP session by sending EHLO command\n     *\n     * @param {String} str Message from the server\n     */\n\n  }, {\n    key: \"_actionGreeting\",\n    value: function _actionGreeting(str) {\n      clearTimeout(this._greetingTimeout);\n\n      if (str.substr(0, 3) !== '220') {\n        this._onError(new Error('Invalid greeting. response=' + str), 'EPROTOCOL', str, 'CONN');\n\n        return;\n      }\n\n      if (this.options.lmtp) {\n        this._responseActions.push(this._actionLHLO);\n\n        this._sendCommand('LHLO ' + this.name);\n      } else {\n        this._responseActions.push(this._actionEHLO);\n\n        this._sendCommand('EHLO ' + this.name);\n      }\n    }\n    /**\n     * Handles server response for LHLO command. If it yielded in\n     * error, emit 'error', otherwise treat this as an EHLO response\n     *\n     * @param {String} str Message from the server\n     */\n\n  }, {\n    key: \"_actionLHLO\",\n    value: function _actionLHLO(str) {\n      if (str.charAt(0) !== '2') {\n        this._onError(new Error('Invalid LHLO. response=' + str), 'EPROTOCOL', str, 'LHLO');\n\n        return;\n      }\n\n      this._actionEHLO(str);\n    }\n    /**\n     * Handles server response for EHLO command. If it yielded in\n     * error, try HELO instead, otherwise initiate TLS negotiation\n     * if STARTTLS is supported by the server or move into the\n     * authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n\n  }, {\n    key: \"_actionEHLO\",\n    value: function _actionEHLO(str) {\n      var match;\n\n      if (str.substr(0, 3) === '421') {\n        this._onError(new Error('Server terminates connection. response=' + str), 'ECONNECTION', str, 'EHLO');\n\n        return;\n      }\n\n      if (str.charAt(0) !== '2') {\n        if (this.options.requireTLS) {\n          this._onError(new Error('EHLO failed but HELO does not support required STARTTLS. response=' + str), 'ECONNECTION', str, 'EHLO');\n\n          return;\n        } // Try HELO instead\n\n\n        this._responseActions.push(this._actionHELO);\n\n        this._sendCommand('HELO ' + this.name);\n\n        return;\n      } // Detect if the server supports STARTTLS\n\n\n      if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\\b/im.test(str) || this.options.requireTLS)) {\n        this._sendCommand('STARTTLS');\n\n        this._responseActions.push(this._actionSTARTTLS);\n\n        return;\n      } // Detect if the server supports SMTPUTF8\n\n\n      if (/[ -]SMTPUTF8\\b/im.test(str)) {\n        this._supportedExtensions.push('SMTPUTF8');\n      } // Detect if the server supports DSN\n\n\n      if (/[ -]DSN\\b/im.test(str)) {\n        this._supportedExtensions.push('DSN');\n      } // Detect if the server supports 8BITMIME\n\n\n      if (/[ -]8BITMIME\\b/im.test(str)) {\n        this._supportedExtensions.push('8BITMIME');\n      } // Detect if the server supports PIPELINING\n\n\n      if (/[ -]PIPELINING\\b/im.test(str)) {\n        this._supportedExtensions.push('PIPELINING');\n      } // Detect if the server supports PLAIN auth\n\n\n      if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)PLAIN/i.test(str)) {\n        this._supportedAuth.push('PLAIN');\n      } // Detect if the server supports LOGIN auth\n\n\n      if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)LOGIN/i.test(str)) {\n        this._supportedAuth.push('LOGIN');\n      } // Detect if the server supports CRAM-MD5 auth\n\n\n      if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)CRAM-MD5/i.test(str)) {\n        this._supportedAuth.push('CRAM-MD5');\n      } // Detect if the server supports XOAUTH2 auth\n\n\n      if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)XOAUTH2/i.test(str)) {\n        this._supportedAuth.push('XOAUTH2');\n      } // Detect if the server supports SIZE extensions (and the max allowed size)\n\n\n      if (match = str.match(/[ -]SIZE(?:[ \\t]+(\\d+))?/im)) {\n        this._supportedExtensions.push('SIZE');\n\n        this._maxAllowedSize = Number(match[1]) || 0;\n      }\n\n      this.emit('connect');\n    }\n    /**\n     * Handles server response for HELO command. If it yielded in\n     * error, emit 'error', otherwise move into the authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n\n  }, {\n    key: \"_actionHELO\",\n    value: function _actionHELO(str) {\n      if (str.charAt(0) !== '2') {\n        this._onError(new Error('Invalid HELO. response=' + str), 'EPROTOCOL', str, 'HELO');\n\n        return;\n      }\n\n      this.emit('connect');\n    }\n    /**\n     * Handles server response for STARTTLS command. If there's an error\n     * try HELO instead, otherwise initiate TLS upgrade. If the upgrade\n     * succeedes restart the EHLO\n     *\n     * @param {String} str Message from the server\n     */\n\n  }, {\n    key: \"_actionSTARTTLS\",\n    value: function _actionSTARTTLS(str) {\n      var _this11 = this;\n\n      if (str.charAt(0) !== '2') {\n        if (this.options.opportunisticTLS) {\n          this.logger.info({\n            tnx: 'smtp'\n          }, 'Failed STARTTLS upgrade, continuing unencrypted');\n          return this.emit('connect');\n        }\n\n        this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');\n\n        return;\n      }\n\n      this._upgradeConnection(function (err, secured) {\n        if (err) {\n          _this11._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');\n\n          return;\n        }\n\n        _this11.logger.info({\n          tnx: 'smtp'\n        }, 'Connection upgraded with STARTTLS');\n\n        if (secured) {\n          // restart session\n          if (_this11.options.lmtp) {\n            _this11._responseActions.push(_this11._actionLHLO);\n\n            _this11._sendCommand('LHLO ' + _this11.name);\n          } else {\n            _this11._responseActions.push(_this11._actionEHLO);\n\n            _this11._sendCommand('EHLO ' + _this11.name);\n          }\n        } else {\n          _this11.emit('connect');\n        }\n      });\n    }\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as\n     * response needs to be base64 encoded username. We do not need\n     * exact match but settle with 334 response in general as some\n     * hosts invalidly use a longer message than VXNlcm5hbWU6\n     *\n     * @param {String} str Message from the server\n     */\n\n  }, {\n    key: \"_actionAUTH_LOGIN_USER\",\n    value: function _actionAUTH_LOGIN_USER(str, callback) {\n      var _this12 = this;\n\n      if (!/^334[ -]/.test(str)) {\n        // expecting '334 VXNlcm5hbWU6'\n        callback(this._formatError('Invalid login sequence while waiting for \"334 VXNlcm5hbWU6\"', 'EAUTH', str, 'AUTH LOGIN'));\n        return;\n      }\n\n      this._responseActions.push(function (str) {\n        _this12._actionAUTH_LOGIN_PASS(str, callback);\n      });\n\n      this._sendCommand(Buffer.from(this._auth.credentials.user + '', 'utf-8').toString('base64'));\n    }\n    /**\n     * Handle the response for AUTH CRAM-MD5 command. We are expecting\n     * '334 <challenge string>'. Data to be sent as response needs to be\n     * base64 decoded challenge string, MD5 hashed using the password as\n     * a HMAC key, prefixed by the username and a space, and finally all\n     * base64 encoded again.\n     *\n     * @param {String} str Message from the server\n     */\n\n  }, {\n    key: \"_actionAUTH_CRAM_MD5\",\n    value: function _actionAUTH_CRAM_MD5(str, callback) {\n      var _this13 = this;\n\n      var challengeMatch = str.match(/^334\\s+(.+)$/);\n      var challengeString = '';\n\n      if (!challengeMatch) {\n        return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));\n      } else {\n        challengeString = challengeMatch[1];\n      } // Decode from base64\n\n\n      var base64decoded = Buffer.from(challengeString, 'base64').toString('ascii'),\n          hmac_md5 = crypto.createHmac('md5', this._auth.credentials.pass);\n      hmac_md5.update(base64decoded);\n      var hex_hmac = hmac_md5.digest('hex');\n      var prepended = this._auth.credentials.user + ' ' + hex_hmac;\n\n      this._responseActions.push(function (str) {\n        _this13._actionAUTH_CRAM_MD5_PASS(str, callback);\n      });\n\n      this._sendCommand(Buffer.from(prepended).toString('base64'));\n    }\n    /**\n     * Handles the response to CRAM-MD5 authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n\n  }, {\n    key: \"_actionAUTH_CRAM_MD5_PASS\",\n    value: function _actionAUTH_CRAM_MD5_PASS(str, callback) {\n      if (!str.match(/^235\\s+/)) {\n        return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH CRAM-MD5'));\n      }\n\n      this.logger.info({\n        tnx: 'smtp',\n        username: this._auth.user,\n        action: 'authenticated',\n        method: this._authMethod\n      }, 'User %s authenticated', JSON.stringify(this._auth.user));\n      this.authenticated = true;\n      callback(null, true);\n    }\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as\n     * response needs to be base64 encoded password.\n     *\n     * @param {String} str Message from the server\n     */\n\n  }, {\n    key: \"_actionAUTH_LOGIN_PASS\",\n    value: function _actionAUTH_LOGIN_PASS(str, callback) {\n      var _this14 = this;\n\n      if (!/^334[ -]/.test(str)) {\n        // expecting '334 UGFzc3dvcmQ6'\n        return callback(this._formatError('Invalid login sequence while waiting for \"334 UGFzc3dvcmQ6\"', 'EAUTH', str, 'AUTH LOGIN'));\n      }\n\n      this._responseActions.push(function (str) {\n        _this14._actionAUTHComplete(str, callback);\n      });\n\n      this._sendCommand(Buffer.from(this._auth.credentials.pass + '', 'utf-8').toString('base64'));\n    }\n    /**\n     * Handles the response for authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n\n  }, {\n    key: \"_actionAUTHComplete\",\n    value: function _actionAUTHComplete(str, isRetry, callback) {\n      var _this15 = this;\n\n      if (!callback && typeof isRetry === 'function') {\n        callback = isRetry;\n        isRetry = false;\n      }\n\n      if (str.substr(0, 3) === '334') {\n        this._responseActions.push(function (str) {\n          if (isRetry || _this15._authMethod !== 'XOAUTH2') {\n            _this15._actionAUTHComplete(str, true, callback);\n          } else {\n            // fetch a new OAuth2 access token\n            setImmediate(function () {\n              return _this15._handleXOauth2Token(true, callback);\n            });\n          }\n        });\n\n        this._sendCommand('');\n\n        return;\n      }\n\n      if (str.charAt(0) !== '2') {\n        this.logger.info({\n          tnx: 'smtp',\n          username: this._auth.user,\n          action: 'authfail',\n          method: this._authMethod\n        }, 'User %s failed to authenticate', JSON.stringify(this._auth.user));\n        return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));\n      }\n\n      this.logger.info({\n        tnx: 'smtp',\n        username: this._auth.user,\n        action: 'authenticated',\n        method: this._authMethod\n      }, 'User %s authenticated', JSON.stringify(this._auth.user));\n      this.authenticated = true;\n      callback(null, true);\n    }\n    /**\n     * Handle response for a MAIL FROM: command\n     *\n     * @param {String} str Message from the server\n     */\n\n  }, {\n    key: \"_actionMAIL\",\n    value: function _actionMAIL(str, callback) {\n      var _this16 = this;\n\n      var message, curRecipient;\n\n      if (Number(str.charAt(0)) !== 2) {\n        if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n          message = 'Internationalized mailbox name not allowed';\n        } else {\n          message = 'Mail command failed';\n        }\n\n        return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));\n      }\n\n      if (!this._envelope.rcptQueue.length) {\n        return callback(this._formatError('Can\\x27t send mail - no recipients defined', 'EENVELOPE', false, 'API'));\n      } else {\n        this._recipientQueue = [];\n\n        if (this._supportedExtensions.includes('PIPELINING')) {\n          while (this._envelope.rcptQueue.length) {\n            curRecipient = this._envelope.rcptQueue.shift();\n\n            this._recipientQueue.push(curRecipient);\n\n            this._responseActions.push(function (str) {\n              _this16._actionRCPT(str, callback);\n            });\n\n            this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n          }\n        } else {\n          curRecipient = this._envelope.rcptQueue.shift();\n\n          this._recipientQueue.push(curRecipient);\n\n          this._responseActions.push(function (str) {\n            _this16._actionRCPT(str, callback);\n          });\n\n          this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n        }\n      }\n    }\n    /**\n     * Handle response for a RCPT TO: command\n     *\n     * @param {String} str Message from the server\n     */\n\n  }, {\n    key: \"_actionRCPT\",\n    value: function _actionRCPT(str, callback) {\n      var _this17 = this;\n\n      var message,\n          err,\n          curRecipient = this._recipientQueue.shift();\n\n      if (Number(str.charAt(0)) !== 2) {\n        // this is a soft error\n        if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\\x80-\\uFFFF]/.test(curRecipient)) {\n          message = 'Internationalized mailbox name not allowed';\n        } else {\n          message = 'Recipient command failed';\n        }\n\n        this._envelope.rejected.push(curRecipient); // store error for the failed recipient\n\n\n        err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');\n        err.recipient = curRecipient;\n\n        this._envelope.rejectedErrors.push(err);\n      } else {\n        this._envelope.accepted.push(curRecipient);\n      }\n\n      if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {\n        if (this._envelope.rejected.length < this._envelope.to.length) {\n          this._responseActions.push(function (str) {\n            _this17._actionDATA(str, callback);\n          });\n\n          this._sendCommand('DATA');\n        } else {\n          err = this._formatError('Can\\x27t send mail - all recipients were rejected', 'EENVELOPE', str, 'RCPT TO');\n          err.rejected = this._envelope.rejected;\n          err.rejectedErrors = this._envelope.rejectedErrors;\n          return callback(err);\n        }\n      } else if (this._envelope.rcptQueue.length) {\n        curRecipient = this._envelope.rcptQueue.shift();\n\n        this._recipientQueue.push(curRecipient);\n\n        this._responseActions.push(function (str) {\n          _this17._actionRCPT(str, callback);\n        });\n\n        this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n      }\n    }\n    /**\n     * Handle response for a DATA command\n     *\n     * @param {String} str Message from the server\n     */\n\n  }, {\n    key: \"_actionDATA\",\n    value: function _actionDATA(str, callback) {\n      // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24\n      // some servers might use 250 instead, so lets check for 2 or 3 as the first digit\n      if (!/^[23]/.test(str)) {\n        return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));\n      }\n\n      var response = {\n        accepted: this._envelope.accepted,\n        rejected: this._envelope.rejected\n      };\n\n      if (this._envelope.rejectedErrors.length) {\n        response.rejectedErrors = this._envelope.rejectedErrors;\n      }\n\n      callback(null, response);\n    }\n    /**\n     * Handle response for a DATA stream when using SMTP\n     * We expect a single response that defines if the sending succeeded or failed\n     *\n     * @param {String} str Message from the server\n     */\n\n  }, {\n    key: \"_actionSMTPStream\",\n    value: function _actionSMTPStream(str, callback) {\n      if (Number(str.charAt(0)) !== 2) {\n        // Message failed\n        return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));\n      } else {\n        // Message sent succesfully\n        return callback(null, str);\n      }\n    }\n    /**\n     * Handle response for a DATA stream\n     * We expect a separate response for every recipient. All recipients can either\n     * succeed or fail separately\n     *\n     * @param {String} recipient The recipient this response applies to\n     * @param {Boolean} final Is this the final recipient?\n     * @param {String} str Message from the server\n     */\n\n  }, {\n    key: \"_actionLMTPStream\",\n    value: function _actionLMTPStream(recipient, final, str, callback) {\n      var err;\n\n      if (Number(str.charAt(0)) !== 2) {\n        // Message failed\n        err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');\n        err.recipient = recipient;\n\n        this._envelope.rejected.push(recipient);\n\n        this._envelope.rejectedErrors.push(err);\n\n        for (var i = 0, len = this._envelope.accepted.length; i < len; i++) {\n          if (this._envelope.accepted[i] === recipient) {\n            this._envelope.accepted.splice(i, 1);\n          }\n        }\n      }\n\n      if (final) {\n        return callback(null, str);\n      }\n    }\n  }, {\n    key: \"_handleXOauth2Token\",\n    value: function _handleXOauth2Token(isRetry, callback) {\n      var _this18 = this;\n\n      this._auth.oauth2.getToken(isRetry, function (err, accessToken) {\n        if (err) {\n          _this18.logger.info({\n            tnx: 'smtp',\n            username: _this18._auth.user,\n            action: 'authfail',\n            method: _this18._authMethod\n          }, 'User %s failed to authenticate', JSON.stringify(_this18._auth.user));\n\n          return callback(_this18._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));\n        }\n\n        _this18._responseActions.push(function (str) {\n          _this18._actionAUTHComplete(str, isRetry, callback);\n        });\n\n        _this18._sendCommand('AUTH XOAUTH2 ' + _this18._auth.oauth2.buildXOAuth2Token(accessToken));\n      });\n    }\n    /**\n     *\n     * @param {string} command\n     * @private\n     */\n\n  }, {\n    key: \"_isDestroyedMessage\",\n    value: function _isDestroyedMessage(command) {\n      if (this._destroyed) {\n        return 'Cannot ' + command + ' - smtp connection is already destroyed.';\n      }\n\n      if (this._socket) {\n        if (this._socket.destroyed) {\n          return 'Cannot ' + command + ' - smtp connection socket is already destroyed.';\n        }\n\n        if (!this._socket.writable) {\n          return 'Cannot ' + command + ' - smtp connection socket is already half-closed.';\n        }\n      }\n    }\n  }, {\n    key: \"_getHostname\",\n    value: function _getHostname() {\n      // defaul hostname is machine hostname or [IP]\n      var defaultHostname = os.hostname() || ''; // ignore if not FQDN\n\n      if (defaultHostname.indexOf('.') < 0) {\n        defaultHostname = '[127.0.0.1]';\n      } // IP should be enclosed in []\n\n\n      if (defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) {\n        defaultHostname = '[' + defaultHostname + ']';\n      }\n\n      return defaultHostname;\n    }\n  }]);\n\n  return SMTPConnection;\n}(EventEmitter);\n\nmodule.exports = SMTPConnection;","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/node_modules/nodemailer/lib/smtp-connection/index.js"],"names":["packageInfo","require","EventEmitter","net","tls","os","crypto","DataStream","PassThrough","shared","CONNECTION_TIMEOUT","SOCKET_TIMEOUT","GREETING_TIMEOUT","SMTPConnection","options","id","randomBytes","toString","replace","stage","secureConnection","secure","alreadySecured","secured","port","Number","host","name","_getHostname","logger","getLogger","component","sid","version","authenticated","destroyed","_remainder","_responseQueue","lastServerResponse","_socket","_supportedAuth","_envelope","_supportedExtensions","_maxAllowedSize","_responseActions","_recipientQueue","_greetingTimeout","_connectionTimeout","_destroyed","_closing","connectCallback","once","debug","tnx","isDestroyedMessage","_isDestroyedMessage","_formatError","opts","localAddress","connection","setImmediate","_upgradeConnection","err","_onError","Error","message","_onConnect","socket","connect","setKeepAlive","E","Object","keys","forEach","key","setTimeout","connectionTimeout","on","_sendCommand","push","close","clearTimeout","closeMethod","_destroy","authData","callback","_auth","_authMethod","method","trim","toUpperCase","oauth2","credentials","user","pass","_handleXOauth2Token","str","_actionAUTH_LOGIN_USER","_actionAUTHComplete","Buffer","from","_actionAUTH_CRAM_MD5","envelope","done","size","returned","arguments","startTime","Date","now","_setEnvelope","info","envelopeTime","stream","_createSendStream","messageTime","messageSize","outByteCount","response","pipe","write","end","charAt","localPort","remoteAddress","remotePort","removeAllListeners","chunk","_onData","errored","_onClose","_onEnd","socketTimeout","_onTimeout","_actionGreeting","greetingTimeout","resume","length","data","lines","split","lastline","pop","i","len","test","_processResponse","type","command","error","emit","prototype","call","code","responseCode","match","upgrading","includes","socketPlain","shift","transactionLog","action","args","useSmtpUtf8","address","to","concat","map","JSON","stringify","rcptQueue","parse","rejected","rejectedErrors","accepted","dsn","_setDsnEnvelope","_actionMAIL","_usingSmtpUtf8","use8BitMime","_using8BitMime","ret","encodeXText","envid","join","params","return","notify","n","validNotify","invaliNotify","filter","orcpt","recipient","indexOf","dataStream","logStream","lmtp","final","_actionLMTPStream","_actionSMTPStream","read","inByteCount","substr","_actionLHLO","_actionEHLO","requireTLS","_actionHELO","ignoreTLS","_actionSTARTTLS","opportunisticTLS","_actionAUTH_LOGIN_PASS","challengeMatch","challengeString","base64decoded","hmac_md5","createHmac","update","hex_hmac","digest","prepended","_actionAUTH_CRAM_MD5_PASS","username","isRetry","curRecipient","_actionRCPT","_getDsnRcptToArgs","_actionDATA","splice","getToken","accessToken","buildXOAuth2Token","writable","defaultHostname","hostname","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst packageInfo = require('../../package.json');\nconst EventEmitter = require('events').EventEmitter;\nconst net = require('net');\nconst tls = require('tls');\nconst os = require('os');\nconst crypto = require('crypto');\nconst DataStream = require('./data-stream');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\n\n// default timeout values in ms\nconst CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established\nconst SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client\nconst GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved\n\n/**\n * Generates a SMTP connection object\n *\n * Optional options object takes the following possible properties:\n *\n *  * **port** - is the port to connect to (defaults to 587 or 465)\n *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')\n *  * **secure** - use SSL\n *  * **ignoreTLS** - ignore server support for STARTTLS\n *  * **requireTLS** - forces the client to use STARTTLS\n *  * **name** - the name of the client server\n *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)\n *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)\n *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish\n *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)\n *  * **lmtp** - if true, uses LMTP instead of SMTP protocol\n *  * **logger** - bunyan compatible logger interface\n *  * **debug** - if true pass SMTP traffic to the logger\n *  * **tls** - options for createCredentials\n *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)\n *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls\n *\n * @constructor\n * @namespace SMTP Client module\n * @param {Object} [options] Option properties\n */\nclass SMTPConnection extends EventEmitter {\n    constructor(options) {\n        super(options);\n\n        this.id = crypto\n            .randomBytes(8)\n            .toString('base64')\n            .replace(/\\W/g, '');\n        this.stage = 'init';\n\n        this.options = options || {};\n\n        this.secureConnection = !!this.options.secure;\n        this.alreadySecured = !!this.options.secured;\n\n        this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);\n        this.host = this.options.host || 'localhost';\n\n        if (typeof this.options.secure === 'undefined' && this.port === 465) {\n            // if secure option is not set but port is 465, then default to secure\n            this.secureConnection = true;\n        }\n\n        this.name = this.options.name || this._getHostname();\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-connection',\n            sid: this.id\n        });\n\n        /**\n         * Expose version nr, just for the reference\n         * @type {String}\n         */\n        this.version = packageInfo.version;\n\n        /**\n         * If true, then the user is authenticated\n         * @type {Boolean}\n         */\n        this.authenticated = false;\n\n        /**\n         * If set to true, this instance is no longer active\n         * @private\n         */\n        this.destroyed = false;\n\n        /**\n         * Defines if the current connection is secure or not. If not,\n         * STARTTLS can be used if available\n         * @private\n         */\n        this.secure = !!this.secureConnection;\n\n        /**\n         * Store incomplete messages coming from the server\n         * @private\n         */\n        this._remainder = '';\n\n        /**\n         * Unprocessed responses from the server\n         * @type {Array}\n         */\n        this._responseQueue = [];\n\n        this.lastServerResponse = false;\n\n        /**\n         * The socket connecting to the server\n         * @publick\n         */\n        this._socket = false;\n\n        /**\n         * Lists supported auth mechanisms\n         * @private\n         */\n        this._supportedAuth = [];\n\n        /**\n         * Includes current envelope (from, to)\n         * @private\n         */\n        this._envelope = false;\n\n        /**\n         * Lists supported extensions\n         * @private\n         */\n        this._supportedExtensions = [];\n\n        /**\n         * Defines the maximum allowed size for a single message\n         * @private\n         */\n        this._maxAllowedSize = 0;\n\n        /**\n         * Function queue to run if a data chunk comes from the server\n         * @private\n         */\n        this._responseActions = [];\n        this._recipientQueue = [];\n\n        /**\n         * Timeout variable for waiting the greeting\n         * @private\n         */\n        this._greetingTimeout = false;\n\n        /**\n         * Timeout variable for waiting the connection to start\n         * @private\n         */\n        this._connectionTimeout = false;\n\n        /**\n         * If the socket is deemed already closed\n         * @private\n         */\n        this._destroyed = false;\n\n        /**\n         * If the socket is already being closed\n         * @private\n         */\n        this._closing = false;\n    }\n\n    /**\n     * Creates a connection to a SMTP server and sets up connection\n     * listener\n     */\n    connect(connectCallback) {\n        if (typeof connectCallback === 'function') {\n            this.once('connect', () => {\n                this.logger.debug(\n                    {\n                        tnx: 'smtp'\n                    },\n                    'SMTP handshake finished'\n                );\n                connectCallback();\n            });\n\n            const isDestroyedMessage = this._isDestroyedMessage('connect');\n            if (isDestroyedMessage) {\n                return connectCallback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'CONN'));\n            }\n        }\n\n        let opts = {\n            port: this.port,\n            host: this.host\n        };\n\n        if (this.options.localAddress) {\n            opts.localAddress = this.options.localAddress;\n        }\n\n        if (this.options.connection) {\n            // connection is already opened\n            this._socket = this.options.connection;\n            if (this.secureConnection && !this.alreadySecured) {\n                setImmediate(() =>\n                    this._upgradeConnection(err => {\n                        if (err) {\n                            this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');\n                            return;\n                        }\n                        this._onConnect();\n                    })\n                );\n            } else {\n                setImmediate(() => this._onConnect());\n            }\n        } else if (this.options.socket) {\n            // socket object is set up but not yet connected\n            this._socket = this.options.socket;\n            try {\n                this._socket.connect(\n                    this.port,\n                    this.host,\n                    () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    }\n                );\n            } catch (E) {\n                return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n            }\n        } else if (this.secureConnection) {\n            // connect using tls\n            if (this.options.tls) {\n                Object.keys(this.options.tls).forEach(key => {\n                    opts[key] = this.options.tls[key];\n                });\n            }\n            try {\n                this._socket = tls.connect(\n                    this.port,\n                    this.host,\n                    opts,\n                    () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    }\n                );\n            } catch (E) {\n                return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n            }\n        } else {\n            // connect using plaintext\n            try {\n                this._socket = net.connect(\n                    opts,\n                    () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    }\n                );\n            } catch (E) {\n                return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n            }\n        }\n\n        this._connectionTimeout = setTimeout(() => {\n            this._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');\n        }, this.options.connectionTimeout || CONNECTION_TIMEOUT);\n\n        this._socket.on('error', err => {\n            this._onError(err, 'ECONNECTION', false, 'CONN');\n        });\n    }\n\n    /**\n     * Sends QUIT\n     */\n    quit() {\n        this._sendCommand('QUIT');\n        this._responseActions.push(this.close);\n    }\n\n    /**\n     * Closes the connection to the server\n     */\n    close() {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n        this._responseActions = [];\n\n        // allow to run this function only once\n        if (this._closing) {\n            return;\n        }\n        this._closing = true;\n\n        let closeMethod = 'end';\n\n        if (this.stage === 'init') {\n            // Close the socket immediately when connection timed out\n            closeMethod = 'destroy';\n        }\n\n        this.logger.debug(\n            {\n                tnx: 'smtp'\n            },\n            'Closing connection to the server using \"%s\"',\n            closeMethod\n        );\n\n        let socket = (this._socket && this._socket.socket) || this._socket;\n\n        if (socket && !socket.destroyed) {\n            try {\n                this._socket[closeMethod]();\n            } catch (E) {\n                // just ignore\n            }\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * Authenticate user\n     */\n    login(authData, callback) {\n        const isDestroyedMessage = this._isDestroyedMessage('login');\n        if (isDestroyedMessage) {\n            return callback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n        }\n\n        this._auth = authData || {};\n\n        // Select SASL authentication method\n        this._authMethod =\n            (this._auth.method || '')\n                .toString()\n                .trim()\n                .toUpperCase() || false;\n        if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {\n            this._authMethod = 'XOAUTH2';\n        } else if (!this._authMethod || (this._authMethod === 'XOAUTH2' && !this._auth.oauth2)) {\n            // use first supported\n            this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();\n        }\n\n        if (this._authMethod !== 'XOAUTH2' && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {\n            if (this._auth.user && this._auth.pass) {\n                this._auth.credentials = {\n                    user: this._auth.user,\n                    pass: this._auth.pass\n                };\n            } else {\n                return callback(this._formatError('Missing credentials for \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n            }\n        }\n\n        switch (this._authMethod) {\n            case 'XOAUTH2':\n                this._handleXOauth2Token(false, callback);\n                return;\n            case 'LOGIN':\n                this._responseActions.push(str => {\n                    this._actionAUTH_LOGIN_USER(str, callback);\n                });\n                this._sendCommand('AUTH LOGIN');\n                return;\n            case 'PLAIN':\n                this._responseActions.push(str => {\n                    this._actionAUTHComplete(str, callback);\n                });\n                this._sendCommand(\n                    'AUTH PLAIN ' +\n                        Buffer.from(\n                            //this._auth.user+'\\u0000'+\n                            '\\u0000' + // skip authorization identity as it causes problems with some servers\n                                this._auth.credentials.user +\n                                '\\u0000' +\n                                this._auth.credentials.pass,\n                            'utf-8'\n                        ).toString('base64')\n                );\n                return;\n            case 'CRAM-MD5':\n                this._responseActions.push(str => {\n                    this._actionAUTH_CRAM_MD5(str, callback);\n                });\n                this._sendCommand('AUTH CRAM-MD5');\n                return;\n        }\n\n        return callback(this._formatError('Unknown authentication method \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n    }\n\n    /**\n     * Sends a message\n     *\n     * @param {Object} envelope Envelope object, {from: addr, to: [addr]}\n     * @param {Object} message String, Buffer or a Stream\n     * @param {Function} callback Callback to return once sending is completed\n     */\n    send(envelope, message, done) {\n        if (!message) {\n            return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));\n        }\n\n        const isDestroyedMessage = this._isDestroyedMessage('send message');\n        if (isDestroyedMessage) {\n            return done(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n        }\n\n        // reject larger messages than allowed\n        if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {\n            return setImmediate(() => {\n                done(this._formatError('Message size larger than allowed ' + this._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));\n            });\n        }\n\n        // ensure that callback is only called once\n        let returned = false;\n        let callback = function() {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            done(...arguments);\n        };\n\n        if (typeof message.on === 'function') {\n            message.on('error', err => callback(this._formatError(err, 'ESTREAM', false, 'API')));\n        }\n\n        let startTime = Date.now();\n        this._setEnvelope(envelope, (err, info) => {\n            if (err) {\n                return callback(err);\n            }\n            let envelopeTime = Date.now();\n            let stream = this._createSendStream((err, str) => {\n                if (err) {\n                    return callback(err);\n                }\n\n                info.envelopeTime = envelopeTime - startTime;\n                info.messageTime = Date.now() - envelopeTime;\n                info.messageSize = stream.outByteCount;\n                info.response = str;\n\n                return callback(null, info);\n            });\n            if (typeof message.pipe === 'function') {\n                message.pipe(stream);\n            } else {\n                stream.write(message);\n                stream.end();\n            }\n        });\n    }\n\n    /**\n     * Resets connection state\n     *\n     * @param {Function} callback Callback to return once connection is reset\n     */\n    reset(callback) {\n        this._sendCommand('RSET');\n        this._responseActions.push(str => {\n            if (str.charAt(0) !== '2') {\n                return callback(this._formatError('Could not reset session state. response=' + str, 'EPROTOCOL', str, 'RSET'));\n            }\n            this._envelope = false;\n            return callback(null, true);\n        });\n    }\n\n    /**\n     * Connection listener that is run when the connection to\n     * the server is opened\n     *\n     * @event\n     */\n    _onConnect() {\n        clearTimeout(this._connectionTimeout);\n\n        this.logger.info(\n            {\n                tnx: 'network',\n                localAddress: this._socket.localAddress,\n                localPort: this._socket.localPort,\n                remoteAddress: this._socket.remoteAddress,\n                remotePort: this._socket.remotePort\n            },\n            '%s established to %s:%s',\n            this.secure ? 'Secure connection' : 'Connection',\n            this._socket.remoteAddress,\n            this._socket.remotePort\n        );\n\n        if (this._destroyed) {\n            // Connection was established after we already had canceled it\n            this.close();\n            return;\n        }\n\n        this.stage = 'connected';\n\n        // clear existing listeners for the socket\n        this._socket.removeAllListeners('data');\n        this._socket.removeAllListeners('timeout');\n        this._socket.removeAllListeners('close');\n        this._socket.removeAllListeners('end');\n\n        this._socket.on('data', chunk => this._onData(chunk));\n        this._socket.once('close', errored => this._onClose(errored));\n        this._socket.once('end', () => this._onEnd());\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);\n        this._socket.on('timeout', () => this._onTimeout());\n\n        this._greetingTimeout = setTimeout(() => {\n            // if still waiting for greeting, give up\n            if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {\n                this._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');\n            }\n        }, this.options.greetingTimeout || GREETING_TIMEOUT);\n\n        this._responseActions.push(this._actionGreeting);\n\n        // we have a 'data' listener set up so resume socket if it was paused\n        this._socket.resume();\n    }\n\n    /**\n     * 'data' listener for data coming from the server\n     *\n     * @event\n     * @param {Buffer} chunk Data chunk coming from the server\n     */\n    _onData(chunk) {\n        if (this._destroyed || !chunk || !chunk.length) {\n            return;\n        }\n\n        let data = (chunk || '').toString('binary');\n        let lines = (this._remainder + data).split(/\\r?\\n/);\n        let lastline;\n\n        this._remainder = lines.pop();\n\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (this._responseQueue.length) {\n                lastline = this._responseQueue[this._responseQueue.length - 1];\n                if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n                    this._responseQueue[this._responseQueue.length - 1] += '\\n' + lines[i];\n                    continue;\n                }\n            }\n            this._responseQueue.push(lines[i]);\n        }\n\n        this._processResponse();\n    }\n\n    /**\n     * 'error' listener for the socket\n     *\n     * @event\n     * @param {Error} err Error object\n     * @param {String} type Error name\n     */\n    _onError(err, type, data, command) {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n\n        if (this._destroyed) {\n            // just ignore, already closed\n            // this might happen when a socket is canceled because of reached timeout\n            // but the socket timeout error itself receives only after\n            return;\n        }\n\n        err = this._formatError(err, type, data, command);\n\n        this.logger.error(data, err.message);\n\n        this.emit('error', err);\n        this.close();\n    }\n\n    _formatError(message, type, response, command) {\n        let err;\n\n        if (/Error\\]$/i.test(Object.prototype.toString.call(message))) {\n            err = message;\n        } else {\n            err = new Error(message);\n        }\n\n        if (type && type !== 'Error') {\n            err.code = type;\n        }\n\n        if (response) {\n            err.response = response;\n            err.message += ': ' + response;\n        }\n\n        let responseCode = (typeof response === 'string' && Number((response.match(/^\\d+/) || [])[0])) || false;\n        if (responseCode) {\n            err.responseCode = responseCode;\n        }\n\n        if (command) {\n            err.command = command;\n        }\n\n        return err;\n    }\n\n    /**\n     * 'close' listener for the socket\n     *\n     * @event\n     */\n    _onClose() {\n        this.logger.info(\n            {\n                tnx: 'network'\n            },\n            'Connection closed'\n        );\n\n        if (this.upgrading && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', false, 'CONN');\n        } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', false, 'CONN');\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * 'end' listener for the socket\n     *\n     * @event\n     */\n    _onEnd() {\n        this._destroy();\n    }\n\n    /**\n     * 'timeout' listener for the socket\n     *\n     * @event\n     */\n    _onTimeout() {\n        return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');\n    }\n\n    /**\n     * Destroys the client, emits 'end'\n     */\n    _destroy() {\n        if (this._destroyed) {\n            return;\n        }\n        this._destroyed = true;\n        this.emit('end');\n    }\n\n    /**\n     * Upgrades the connection to TLS\n     *\n     * @param {Function} callback Callback function to run when the connection\n     *        has been secured\n     */\n    _upgradeConnection(callback) {\n        // do not remove all listeners or it breaks node v0.10 as there's\n        // apparently a 'finish' event set that would be cleared as well\n\n        // we can safely keep 'error', 'end', 'close' etc. events\n        this._socket.removeAllListeners('data'); // incoming data is going to be gibberish from this point onwards\n        this._socket.removeAllListeners('timeout'); // timeout will be re-set for the new socket object\n\n        let socketPlain = this._socket;\n        let opts = {\n            socket: this._socket,\n            host: this.host\n        };\n\n        Object.keys(this.options.tls || {}).forEach(key => {\n            opts[key] = this.options.tls[key];\n        });\n\n        this.upgrading = true;\n        this._socket = tls.connect(\n            opts,\n            () => {\n                this.secure = true;\n                this.upgrading = false;\n                this._socket.on('data', chunk => this._onData(chunk));\n\n                socketPlain.removeAllListeners('close');\n                socketPlain.removeAllListeners('end');\n\n                return callback(null, true);\n            }\n        );\n\n        this._socket.on('error', err => this._onError(err, 'ESOCKET', false, 'CONN'));\n        this._socket.once('close', errored => this._onClose(errored));\n        this._socket.once('end', () => this._onEnd());\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.\n        this._socket.on('timeout', () => this._onTimeout());\n\n        // resume in case the socket was paused\n        socketPlain.resume();\n    }\n\n    /**\n     * Processes queued responses from the server\n     *\n     * @param {Boolean} force If true, ignores _processing flag\n     */\n    _processResponse() {\n        if (!this._responseQueue.length) {\n            return false;\n        }\n\n        let str = (this.lastServerResponse = (this._responseQueue.shift() || '').toString());\n\n        if (/^\\d+-/.test(str.split('\\n').pop())) {\n            // keep waiting for the final part of multiline response\n            return;\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug(\n                {\n                    tnx: 'server'\n                },\n                str.replace(/\\r?\\n$/, '')\n            );\n        }\n\n        if (!str.trim()) {\n            // skip unexpected empty lines\n            setImmediate(() => this._processResponse(true));\n        }\n\n        let action = this._responseActions.shift();\n\n        if (typeof action === 'function') {\n            action.call(this, str);\n            setImmediate(() => this._processResponse(true));\n        } else {\n            return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');\n        }\n    }\n\n    /**\n     * Send a command to the server, append \\r\\n\n     *\n     * @param {String} str String to be sent to the server\n     */\n    _sendCommand(str) {\n        if (this._destroyed) {\n            // Connection already closed, can't send any more data\n            return;\n        }\n\n        if (this._socket.destroyed) {\n            return this.close();\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug(\n                {\n                    tnx: 'client'\n                },\n                (str || '').toString().replace(/\\r?\\n$/, '')\n            );\n        }\n\n        this._socket.write(Buffer.from(str + '\\r\\n', 'utf-8'));\n    }\n\n    /**\n     * Initiates a new message by submitting envelope data, starting with\n     * MAIL FROM: command\n     *\n     * @param {Object} envelope Envelope object in the form of\n     *        {from:'...', to:['...']}\n     *        or\n     *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}\n     */\n    _setEnvelope(envelope, callback) {\n        let args = [];\n        let useSmtpUtf8 = false;\n\n        this._envelope = envelope || {};\n        this._envelope.from = ((this._envelope.from && this._envelope.from.address) || this._envelope.from || '').toString().trim();\n\n        this._envelope.to = [].concat(this._envelope.to || []).map(to => ((to && to.address) || to || '').toString().trim());\n\n        if (!this._envelope.to.length) {\n            return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));\n        }\n\n        if (this._envelope.from && /[\\r\\n<>]/.test(this._envelope.from)) {\n            return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));\n        }\n\n        // check if the sender address uses only ASCII characters,\n        // otherwise require usage of SMTPUTF8 extension\n        if (/[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n            useSmtpUtf8 = true;\n        }\n\n        for (let i = 0, len = this._envelope.to.length; i < len; i++) {\n            if (!this._envelope.to[i] || /[\\r\\n<>]/.test(this._envelope.to[i])) {\n                return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));\n            }\n\n            // check if the recipients addresses use only ASCII characters,\n            // otherwise require usage of SMTPUTF8 extension\n            if (/[\\x80-\\uFFFF]/.test(this._envelope.to[i])) {\n                useSmtpUtf8 = true;\n            }\n        }\n\n        // clone the recipients array for latter manipulation\n        this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));\n        this._envelope.rejected = [];\n        this._envelope.rejectedErrors = [];\n        this._envelope.accepted = [];\n\n        if (this._envelope.dsn) {\n            try {\n                this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);\n            } catch (err) {\n                return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));\n            }\n        }\n\n        this._responseActions.push(str => {\n            this._actionMAIL(str, callback);\n        });\n\n        // If the server supports SMTPUTF8 and the envelope includes an internationalized\n        // email address then append SMTPUTF8 keyword to the MAIL FROM command\n        if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {\n            args.push('SMTPUTF8');\n            this._usingSmtpUtf8 = true;\n        }\n\n        // If the server supports 8BITMIME and the message might contain non-ascii bytes\n        // then append the 8BITMIME keyword to the MAIL FROM command\n        if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {\n            args.push('BODY=8BITMIME');\n            this._using8BitMime = true;\n        }\n\n        if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {\n            args.push('SIZE=' + this._envelope.size);\n        }\n\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the MAIL FROM command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.ret) {\n                args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));\n            }\n            if (this._envelope.dsn.envid) {\n                args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));\n            }\n        }\n\n        this._sendCommand('MAIL FROM:<' + this._envelope.from + '>' + (args.length ? ' ' + args.join(' ') : ''));\n    }\n\n    _setDsnEnvelope(params) {\n        let ret = (params.ret || params.return || '').toString().toUpperCase() || null;\n        if (ret) {\n            switch (ret) {\n                case 'HDRS':\n                case 'HEADERS':\n                    ret = 'HDRS';\n                    break;\n                case 'FULL':\n                case 'BODY':\n                    ret = 'FULL';\n                    break;\n            }\n        }\n\n        if (ret && !['FULL', 'HDRS'].includes(ret)) {\n            throw new Error('ret: ' + JSON.stringify(ret));\n        }\n\n        let envid = (params.envid || params.id || '').toString() || null;\n\n        let notify = params.notify || null;\n        if (notify) {\n            if (typeof notify === 'string') {\n                notify = notify.split(',');\n            }\n            notify = notify.map(n => n.trim().toUpperCase());\n            let validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];\n            let invaliNotify = notify.filter(n => !validNotify.includes(n));\n            if (invaliNotify.length || (notify.length > 1 && notify.includes('NEVER'))) {\n                throw new Error('notify: ' + JSON.stringify(notify.join(',')));\n            }\n            notify = notify.join(',');\n        }\n\n        let orcpt = (params.orcpt || params.recipient || '').toString() || null;\n        if (orcpt && orcpt.indexOf(';') < 0) {\n            orcpt = 'rfc822;' + orcpt;\n        }\n\n        return {\n            ret,\n            envid,\n            notify,\n            orcpt\n        };\n    }\n\n    _getDsnRcptToArgs() {\n        let args = [];\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the RCPT TO command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.notify) {\n                args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));\n            }\n            if (this._envelope.dsn.orcpt) {\n                args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));\n            }\n        }\n        return args.length ? ' ' + args.join(' ') : '';\n    }\n\n    _createSendStream(callback) {\n        let dataStream = new DataStream();\n        let logStream;\n\n        if (this.options.lmtp) {\n            this._envelope.accepted.forEach((recipient, i) => {\n                let final = i === this._envelope.accepted.length - 1;\n                this._responseActions.push(str => {\n                    this._actionLMTPStream(recipient, final, str, callback);\n                });\n            });\n        } else {\n            this._responseActions.push(str => {\n                this._actionSMTPStream(str, callback);\n            });\n        }\n\n        dataStream.pipe(\n            this._socket,\n            {\n                end: false\n            }\n        );\n\n        if (this.options.debug) {\n            logStream = new PassThrough();\n            logStream.on('readable', () => {\n                let chunk;\n                while ((chunk = logStream.read())) {\n                    this.logger.debug(\n                        {\n                            tnx: 'message'\n                        },\n                        chunk.toString('binary').replace(/\\r?\\n$/, '')\n                    );\n                }\n            });\n            dataStream.pipe(logStream);\n        }\n\n        dataStream.once('end', () => {\n            this.logger.info(\n                {\n                    tnx: 'message',\n                    inByteCount: dataStream.inByteCount,\n                    outByteCount: dataStream.outByteCount\n                },\n                '<%s bytes encoded mime message (source size %s bytes)>',\n                dataStream.outByteCount,\n                dataStream.inByteCount\n            );\n        });\n\n        return dataStream;\n    }\n\n    /** ACTIONS **/\n\n    /**\n     * Will be run after the connection is created and the server sends\n     * a greeting. If the incoming message starts with 220 initiate\n     * SMTP session by sending EHLO command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionGreeting(str) {\n        clearTimeout(this._greetingTimeout);\n\n        if (str.substr(0, 3) !== '220') {\n            this._onError(new Error('Invalid greeting. response=' + str), 'EPROTOCOL', str, 'CONN');\n            return;\n        }\n\n        if (this.options.lmtp) {\n            this._responseActions.push(this._actionLHLO);\n            this._sendCommand('LHLO ' + this.name);\n        } else {\n            this._responseActions.push(this._actionEHLO);\n            this._sendCommand('EHLO ' + this.name);\n        }\n    }\n\n    /**\n     * Handles server response for LHLO command. If it yielded in\n     * error, emit 'error', otherwise treat this as an EHLO response\n     *\n     * @param {String} str Message from the server\n     */\n    _actionLHLO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid LHLO. response=' + str), 'EPROTOCOL', str, 'LHLO');\n            return;\n        }\n\n        this._actionEHLO(str);\n    }\n\n    /**\n     * Handles server response for EHLO command. If it yielded in\n     * error, try HELO instead, otherwise initiate TLS negotiation\n     * if STARTTLS is supported by the server or move into the\n     * authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionEHLO(str) {\n        let match;\n\n        if (str.substr(0, 3) === '421') {\n            this._onError(new Error('Server terminates connection. response=' + str), 'ECONNECTION', str, 'EHLO');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            if (this.options.requireTLS) {\n                this._onError(new Error('EHLO failed but HELO does not support required STARTTLS. response=' + str), 'ECONNECTION', str, 'EHLO');\n                return;\n            }\n\n            // Try HELO instead\n            this._responseActions.push(this._actionHELO);\n            this._sendCommand('HELO ' + this.name);\n            return;\n        }\n\n        // Detect if the server supports STARTTLS\n        if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\\b/im.test(str) || this.options.requireTLS)) {\n            this._sendCommand('STARTTLS');\n            this._responseActions.push(this._actionSTARTTLS);\n            return;\n        }\n\n        // Detect if the server supports SMTPUTF8\n        if (/[ -]SMTPUTF8\\b/im.test(str)) {\n            this._supportedExtensions.push('SMTPUTF8');\n        }\n\n        // Detect if the server supports DSN\n        if (/[ -]DSN\\b/im.test(str)) {\n            this._supportedExtensions.push('DSN');\n        }\n\n        // Detect if the server supports 8BITMIME\n        if (/[ -]8BITMIME\\b/im.test(str)) {\n            this._supportedExtensions.push('8BITMIME');\n        }\n\n        // Detect if the server supports PIPELINING\n        if (/[ -]PIPELINING\\b/im.test(str)) {\n            this._supportedExtensions.push('PIPELINING');\n        }\n\n        // Detect if the server supports PLAIN auth\n        if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)PLAIN/i.test(str)) {\n            this._supportedAuth.push('PLAIN');\n        }\n\n        // Detect if the server supports LOGIN auth\n        if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)LOGIN/i.test(str)) {\n            this._supportedAuth.push('LOGIN');\n        }\n\n        // Detect if the server supports CRAM-MD5 auth\n        if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)CRAM-MD5/i.test(str)) {\n            this._supportedAuth.push('CRAM-MD5');\n        }\n\n        // Detect if the server supports XOAUTH2 auth\n        if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)XOAUTH2/i.test(str)) {\n            this._supportedAuth.push('XOAUTH2');\n        }\n\n        // Detect if the server supports SIZE extensions (and the max allowed size)\n        if ((match = str.match(/[ -]SIZE(?:[ \\t]+(\\d+))?/im))) {\n            this._supportedExtensions.push('SIZE');\n            this._maxAllowedSize = Number(match[1]) || 0;\n        }\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for HELO command. If it yielded in\n     * error, emit 'error', otherwise move into the authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionHELO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid HELO. response=' + str), 'EPROTOCOL', str, 'HELO');\n            return;\n        }\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for STARTTLS command. If there's an error\n     * try HELO instead, otherwise initiate TLS upgrade. If the upgrade\n     * succeedes restart the EHLO\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSTARTTLS(str) {\n        if (str.charAt(0) !== '2') {\n            if (this.options.opportunisticTLS) {\n                this.logger.info(\n                    {\n                        tnx: 'smtp'\n                    },\n                    'Failed STARTTLS upgrade, continuing unencrypted'\n                );\n                return this.emit('connect');\n            }\n            this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');\n            return;\n        }\n\n        this._upgradeConnection((err, secured) => {\n            if (err) {\n                this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');\n                return;\n            }\n\n            this.logger.info(\n                {\n                    tnx: 'smtp'\n                },\n                'Connection upgraded with STARTTLS'\n            );\n\n            if (secured) {\n                // restart session\n                if (this.options.lmtp) {\n                    this._responseActions.push(this._actionLHLO);\n                    this._sendCommand('LHLO ' + this.name);\n                } else {\n                    this._responseActions.push(this._actionEHLO);\n                    this._sendCommand('EHLO ' + this.name);\n                }\n            } else {\n                this.emit('connect');\n            }\n        });\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as\n     * response needs to be base64 encoded username. We do not need\n     * exact match but settle with 334 response in general as some\n     * hosts invalidly use a longer message than VXNlcm5hbWU6\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_USER(str, callback) {\n        if (!/^334[ -]/.test(str)) {\n            // expecting '334 VXNlcm5hbWU6'\n            callback(this._formatError('Invalid login sequence while waiting for \"334 VXNlcm5hbWU6\"', 'EAUTH', str, 'AUTH LOGIN'));\n            return;\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTH_LOGIN_PASS(str, callback);\n        });\n\n        this._sendCommand(Buffer.from(this._auth.credentials.user + '', 'utf-8').toString('base64'));\n    }\n\n    /**\n     * Handle the response for AUTH CRAM-MD5 command. We are expecting\n     * '334 <challenge string>'. Data to be sent as response needs to be\n     * base64 decoded challenge string, MD5 hashed using the password as\n     * a HMAC key, prefixed by the username and a space, and finally all\n     * base64 encoded again.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5(str, callback) {\n        let challengeMatch = str.match(/^334\\s+(.+)$/);\n        let challengeString = '';\n\n        if (!challengeMatch) {\n            return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));\n        } else {\n            challengeString = challengeMatch[1];\n        }\n\n        // Decode from base64\n        let base64decoded = Buffer.from(challengeString, 'base64').toString('ascii'),\n            hmac_md5 = crypto.createHmac('md5', this._auth.credentials.pass);\n\n        hmac_md5.update(base64decoded);\n\n        let hex_hmac = hmac_md5.digest('hex');\n        let prepended = this._auth.credentials.user + ' ' + hex_hmac;\n\n        this._responseActions.push(str => {\n            this._actionAUTH_CRAM_MD5_PASS(str, callback);\n        });\n\n        this._sendCommand(Buffer.from(prepended).toString('base64'));\n    }\n\n    /**\n     * Handles the response to CRAM-MD5 authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5_PASS(str, callback) {\n        if (!str.match(/^235\\s+/)) {\n            return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH CRAM-MD5'));\n        }\n\n        this.logger.info(\n            {\n                tnx: 'smtp',\n                username: this._auth.user,\n                action: 'authenticated',\n                method: this._authMethod\n            },\n            'User %s authenticated',\n            JSON.stringify(this._auth.user)\n        );\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as\n     * response needs to be base64 encoded password.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_PASS(str, callback) {\n        if (!/^334[ -]/.test(str)) {\n            // expecting '334 UGFzc3dvcmQ6'\n            return callback(this._formatError('Invalid login sequence while waiting for \"334 UGFzc3dvcmQ6\"', 'EAUTH', str, 'AUTH LOGIN'));\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTHComplete(str, callback);\n        });\n\n        this._sendCommand(Buffer.from(this._auth.credentials.pass + '', 'utf-8').toString('base64'));\n    }\n\n    /**\n     * Handles the response for authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTHComplete(str, isRetry, callback) {\n        if (!callback && typeof isRetry === 'function') {\n            callback = isRetry;\n            isRetry = false;\n        }\n\n        if (str.substr(0, 3) === '334') {\n            this._responseActions.push(str => {\n                if (isRetry || this._authMethod !== 'XOAUTH2') {\n                    this._actionAUTHComplete(str, true, callback);\n                } else {\n                    // fetch a new OAuth2 access token\n                    setImmediate(() => this._handleXOauth2Token(true, callback));\n                }\n            });\n            this._sendCommand('');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            this.logger.info(\n                {\n                    tnx: 'smtp',\n                    username: this._auth.user,\n                    action: 'authfail',\n                    method: this._authMethod\n                },\n                'User %s failed to authenticate',\n                JSON.stringify(this._auth.user)\n            );\n            return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));\n        }\n\n        this.logger.info(\n            {\n                tnx: 'smtp',\n                username: this._auth.user,\n                action: 'authenticated',\n                method: this._authMethod\n            },\n            'User %s authenticated',\n            JSON.stringify(this._auth.user)\n        );\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle response for a MAIL FROM: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionMAIL(str, callback) {\n        let message, curRecipient;\n        if (Number(str.charAt(0)) !== 2) {\n            if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Mail command failed';\n            }\n            return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));\n        }\n\n        if (!this._envelope.rcptQueue.length) {\n            return callback(this._formatError('Can\\x27t send mail - no recipients defined', 'EENVELOPE', false, 'API'));\n        } else {\n            this._recipientQueue = [];\n\n            if (this._supportedExtensions.includes('PIPELINING')) {\n                while (this._envelope.rcptQueue.length) {\n                    curRecipient = this._envelope.rcptQueue.shift();\n                    this._recipientQueue.push(curRecipient);\n                    this._responseActions.push(str => {\n                        this._actionRCPT(str, callback);\n                    });\n                    this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n                }\n            } else {\n                curRecipient = this._envelope.rcptQueue.shift();\n                this._recipientQueue.push(curRecipient);\n                this._responseActions.push(str => {\n                    this._actionRCPT(str, callback);\n                });\n                this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n            }\n        }\n    }\n\n    /**\n     * Handle response for a RCPT TO: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionRCPT(str, callback) {\n        let message,\n            err,\n            curRecipient = this._recipientQueue.shift();\n        if (Number(str.charAt(0)) !== 2) {\n            // this is a soft error\n            if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\\x80-\\uFFFF]/.test(curRecipient)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Recipient command failed';\n            }\n            this._envelope.rejected.push(curRecipient);\n            // store error for the failed recipient\n            err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');\n            err.recipient = curRecipient;\n            this._envelope.rejectedErrors.push(err);\n        } else {\n            this._envelope.accepted.push(curRecipient);\n        }\n\n        if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {\n            if (this._envelope.rejected.length < this._envelope.to.length) {\n                this._responseActions.push(str => {\n                    this._actionDATA(str, callback);\n                });\n                this._sendCommand('DATA');\n            } else {\n                err = this._formatError('Can\\x27t send mail - all recipients were rejected', 'EENVELOPE', str, 'RCPT TO');\n                err.rejected = this._envelope.rejected;\n                err.rejectedErrors = this._envelope.rejectedErrors;\n                return callback(err);\n            }\n        } else if (this._envelope.rcptQueue.length) {\n            curRecipient = this._envelope.rcptQueue.shift();\n            this._recipientQueue.push(curRecipient);\n            this._responseActions.push(str => {\n                this._actionRCPT(str, callback);\n            });\n            this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n        }\n    }\n\n    /**\n     * Handle response for a DATA command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionDATA(str, callback) {\n        // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24\n        // some servers might use 250 instead, so lets check for 2 or 3 as the first digit\n        if (!/^[23]/.test(str)) {\n            return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));\n        }\n\n        let response = {\n            accepted: this._envelope.accepted,\n            rejected: this._envelope.rejected\n        };\n\n        if (this._envelope.rejectedErrors.length) {\n            response.rejectedErrors = this._envelope.rejectedErrors;\n        }\n\n        callback(null, response);\n    }\n\n    /**\n     * Handle response for a DATA stream when using SMTP\n     * We expect a single response that defines if the sending succeeded or failed\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSMTPStream(str, callback) {\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));\n        } else {\n            // Message sent succesfully\n            return callback(null, str);\n        }\n    }\n\n    /**\n     * Handle response for a DATA stream\n     * We expect a separate response for every recipient. All recipients can either\n     * succeed or fail separately\n     *\n     * @param {String} recipient The recipient this response applies to\n     * @param {Boolean} final Is this the final recipient?\n     * @param {String} str Message from the server\n     */\n    _actionLMTPStream(recipient, final, str, callback) {\n        let err;\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');\n            err.recipient = recipient;\n            this._envelope.rejected.push(recipient);\n            this._envelope.rejectedErrors.push(err);\n            for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {\n                if (this._envelope.accepted[i] === recipient) {\n                    this._envelope.accepted.splice(i, 1);\n                }\n            }\n        }\n        if (final) {\n            return callback(null, str);\n        }\n    }\n\n    _handleXOauth2Token(isRetry, callback) {\n        this._auth.oauth2.getToken(isRetry, (err, accessToken) => {\n            if (err) {\n                this.logger.info(\n                    {\n                        tnx: 'smtp',\n                        username: this._auth.user,\n                        action: 'authfail',\n                        method: this._authMethod\n                    },\n                    'User %s failed to authenticate',\n                    JSON.stringify(this._auth.user)\n                );\n                return callback(this._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));\n            }\n            this._responseActions.push(str => {\n                this._actionAUTHComplete(str, isRetry, callback);\n            });\n            this._sendCommand('AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token(accessToken));\n        });\n    }\n\n    /**\n     *\n     * @param {string} command\n     * @private\n     */\n    _isDestroyedMessage(command) {\n        if (this._destroyed) {\n            return 'Cannot ' + command + ' - smtp connection is already destroyed.';\n        }\n\n        if (this._socket) {\n            if (this._socket.destroyed) {\n                return 'Cannot ' + command + ' - smtp connection socket is already destroyed.';\n            }\n\n            if (!this._socket.writable) {\n                return 'Cannot ' + command + ' - smtp connection socket is already half-closed.';\n            }\n        }\n    }\n\n    _getHostname() {\n        // defaul hostname is machine hostname or [IP]\n        let defaultHostname = os.hostname() || '';\n\n        // ignore if not FQDN\n        if (defaultHostname.indexOf('.') < 0) {\n            defaultHostname = '[127.0.0.1]';\n        }\n\n        // IP should be enclosed in []\n        if (defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) {\n            defaultHostname = '[' + defaultHostname + ']';\n        }\n\n        return defaultHostname;\n    }\n}\n\nmodule.exports = SMTPConnection;\n"]},"metadata":{},"sourceType":"script"}