{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar EventEmitter = require('events');\n\nvar SMTPConnection = require('../smtp-connection');\n\nvar wellKnown = require('../well-known');\n\nvar shared = require('../shared');\n\nvar XOAuth2 = require('../xoauth2');\n\nvar packageData = require('../../package.json');\n/**\n * Creates a SMTP transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options Connection options\n */\n\n\nvar SMTPTransport = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(SMTPTransport, _EventEmitter);\n\n  var _super = _createSuper(SMTPTransport);\n\n  function SMTPTransport(options) {\n    var _this;\n\n    _classCallCheck(this, SMTPTransport);\n\n    _this = _super.call(this);\n    options = options || {};\n\n    if (typeof options === 'string') {\n      options = {\n        url: options\n      };\n    }\n\n    var urlData;\n    var service = options.service;\n\n    if (typeof options.getSocket === 'function') {\n      _this.getSocket = options.getSocket;\n    }\n\n    if (options.url) {\n      urlData = shared.parseConnectionUrl(options.url);\n      service = service || urlData.service;\n    }\n\n    _this.options = shared.assign(false, // create new object\n    options, // regular options\n    urlData, // url options\n    service && wellKnown(service) // wellknown options\n    );\n    _this.logger = shared.getLogger(_this.options, {\n      component: _this.options.component || 'smtp-transport'\n    }); // temporary object\n\n    var connection = new SMTPConnection(_this.options);\n    _this.name = 'SMTP';\n    _this.version = packageData.version + '[client:' + connection.version + ']';\n\n    if (_this.options.auth) {\n      _this.auth = _this.getAuth({});\n    }\n\n    return _this;\n  }\n  /**\n   * Placeholder function for creating proxy sockets. This method immediatelly returns\n   * without a socket\n   *\n   * @param {Object} options Connection options\n   * @param {Function} callback Callback function to run with the socket keys\n   */\n\n\n  _createClass(SMTPTransport, [{\n    key: \"getSocket\",\n    value: function getSocket(options, callback) {\n      // return immediatelly\n      return setImmediate(function () {\n        return callback(null, false);\n      });\n    }\n  }, {\n    key: \"getAuth\",\n    value: function getAuth(authOpts) {\n      var _this2 = this;\n\n      if (!authOpts) {\n        return this.auth;\n      }\n\n      var hasAuth = false;\n      var authData = {};\n\n      if (this.options.auth && typeof this.options.auth === 'object') {\n        Object.keys(this.options.auth).forEach(function (key) {\n          hasAuth = true;\n          authData[key] = _this2.options.auth[key];\n        });\n      }\n\n      if (authOpts && typeof authOpts === 'object') {\n        Object.keys(authOpts).forEach(function (key) {\n          hasAuth = true;\n          authData[key] = authOpts[key];\n        });\n      }\n\n      if (!hasAuth) {\n        return false;\n      }\n\n      switch ((authData.type || '').toString().toUpperCase()) {\n        case 'OAUTH2':\n          {\n            if (!authData.service && !authData.user) {\n              return false;\n            }\n\n            var oauth2 = new XOAuth2(authData, this.logger);\n            oauth2.provisionCallback = this.mailer && this.mailer.get('oauth2_provision_cb') || oauth2.provisionCallback;\n            oauth2.on('token', function (token) {\n              return _this2.mailer.emit('token', token);\n            });\n            oauth2.on('error', function (err) {\n              return _this2.emit('error', err);\n            });\n            return {\n              type: 'OAUTH2',\n              user: authData.user,\n              oauth2: oauth2,\n              method: 'XOAUTH2'\n            };\n          }\n\n        default:\n          return {\n            type: 'LOGIN',\n            user: authData.user,\n            credentials: {\n              user: authData.user || '',\n              pass: authData.pass\n            },\n            method: (authData.method || '').trim().toUpperCase() || false\n          };\n      }\n    }\n    /**\n     * Sends an e-mail using the selected settings\n     *\n     * @param {Object} mail Mail object\n     * @param {Function} callback Callback function\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(mail, callback) {\n      var _this3 = this;\n\n      this.getSocket(this.options, function (err, socketOptions) {\n        if (err) {\n          return callback(err);\n        }\n\n        var returned = false;\n        var options = _this3.options;\n\n        if (socketOptions && socketOptions.connection) {\n          _this3.logger.info({\n            tnx: 'proxy',\n            remoteAddress: socketOptions.connection.remoteAddress,\n            remotePort: socketOptions.connection.remotePort,\n            destHost: options.host || '',\n            destPort: options.port || '',\n            action: 'connected'\n          }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || ''); // only copy options if we need to modify it\n\n\n          options = shared.assign(false, options);\n          Object.keys(socketOptions).forEach(function (key) {\n            options[key] = socketOptions[key];\n          });\n        }\n\n        var connection = new SMTPConnection(options);\n        connection.once('error', function (err) {\n          if (returned) {\n            return;\n          }\n\n          returned = true;\n          connection.close();\n          return callback(err);\n        });\n        connection.once('end', function () {\n          if (returned) {\n            return;\n          }\n\n          var timer = setTimeout(function () {\n            if (returned) {\n              return;\n            }\n\n            returned = true; // still have not returned, this means we have an unexpected connection close\n\n            var err = new Error('Unexpected socket close');\n\n            if (connection && connection._socket && connection._socket.upgrading) {\n              // starttls connection errors\n              err.code = 'ETLS';\n            }\n\n            callback(err);\n          }, 1000);\n\n          try {\n            timer.unref();\n          } catch (E) {// Ignore. Happens on envs with non-node timer implementation\n          }\n        });\n\n        var sendMessage = function sendMessage() {\n          var envelope = mail.message.getEnvelope();\n          var messageId = mail.message.messageId();\n          var recipients = [].concat(envelope.to || []);\n\n          if (recipients.length > 3) {\n            recipients.push('...and ' + recipients.splice(2).length + ' more');\n          }\n\n          if (mail.data.dsn) {\n            envelope.dsn = mail.data.dsn;\n          }\n\n          _this3.logger.info({\n            tnx: 'send',\n            messageId: messageId\n          }, 'Sending message %s to <%s>', messageId, recipients.join(', '));\n\n          connection.send(envelope, mail.message.createReadStream(), function (err, info) {\n            returned = true;\n            connection.close();\n\n            if (err) {\n              _this3.logger.error({\n                err: err,\n                tnx: 'send'\n              }, 'Send error for %s: %s', messageId, err.message);\n\n              return callback(err);\n            }\n\n            info.envelope = {\n              from: envelope.from,\n              to: envelope.to\n            };\n            info.messageId = messageId;\n\n            try {\n              return callback(null, info);\n            } catch (E) {\n              _this3.logger.error({\n                err: E,\n                tnx: 'callback'\n              }, 'Callback error for %s: %s', messageId, E.message);\n            }\n          });\n        };\n\n        connection.connect(function () {\n          if (returned) {\n            return;\n          }\n\n          var auth = _this3.getAuth(mail.data.auth);\n\n          if (auth) {\n            connection.login(auth, function (err) {\n              if (auth && auth !== _this3.auth && auth.oauth2) {\n                auth.oauth2.removeAllListeners();\n              }\n\n              if (returned) {\n                return;\n              }\n\n              if (err) {\n                returned = true;\n                connection.close();\n                return callback(err);\n              }\n\n              sendMessage();\n            });\n          } else {\n            sendMessage();\n          }\n        });\n      });\n    }\n    /**\n     * Verifies SMTP configuration\n     *\n     * @param {Function} callback Callback function\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(callback) {\n      var _this4 = this;\n\n      var promise;\n\n      if (!callback && typeof Promise === 'function') {\n        promise = new Promise(function (resolve, reject) {\n          callback = shared.callbackPromise(resolve, reject);\n        });\n      }\n\n      this.getSocket(this.options, function (err, socketOptions) {\n        if (err) {\n          return callback(err);\n        }\n\n        var options = _this4.options;\n\n        if (socketOptions && socketOptions.connection) {\n          _this4.logger.info({\n            tnx: 'proxy',\n            remoteAddress: socketOptions.connection.remoteAddress,\n            remotePort: socketOptions.connection.remotePort,\n            destHost: options.host || '',\n            destPort: options.port || '',\n            action: 'connected'\n          }, 'Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');\n\n          options = shared.assign(false, options);\n          Object.keys(socketOptions).forEach(function (key) {\n            options[key] = socketOptions[key];\n          });\n        }\n\n        var connection = new SMTPConnection(options);\n        var returned = false;\n        connection.once('error', function (err) {\n          if (returned) {\n            return;\n          }\n\n          returned = true;\n          connection.close();\n          return callback(err);\n        });\n        connection.once('end', function () {\n          if (returned) {\n            return;\n          }\n\n          returned = true;\n          return callback(new Error('Connection closed'));\n        });\n\n        var finalize = function finalize() {\n          if (returned) {\n            return;\n          }\n\n          returned = true;\n          connection.quit();\n          return callback(null, true);\n        };\n\n        connection.connect(function () {\n          if (returned) {\n            return;\n          }\n\n          var authData = _this4.getAuth({});\n\n          if (authData) {\n            connection.login(authData, function (err) {\n              if (returned) {\n                return;\n              }\n\n              if (err) {\n                returned = true;\n                connection.close();\n                return callback(err);\n              }\n\n              finalize();\n            });\n          } else {\n            finalize();\n          }\n        });\n      });\n      return promise;\n    }\n    /**\n     * Releases resources\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this.auth && this.auth.oauth2) {\n        this.auth.oauth2.removeAllListeners();\n      }\n\n      this.emit('close');\n    }\n  }]);\n\n  return SMTPTransport;\n}(EventEmitter); // expose to the world\n\n\nmodule.exports = SMTPTransport;","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/node_modules/nodemailer/lib/smtp-transport/index.js"],"names":["EventEmitter","require","SMTPConnection","wellKnown","shared","XOAuth2","packageData","SMTPTransport","options","url","urlData","service","getSocket","parseConnectionUrl","assign","logger","getLogger","component","connection","name","version","auth","getAuth","callback","setImmediate","authOpts","hasAuth","authData","Object","keys","forEach","key","type","toString","toUpperCase","user","oauth2","provisionCallback","mailer","get","on","token","emit","err","method","credentials","pass","trim","mail","socketOptions","returned","info","tnx","remoteAddress","remotePort","destHost","host","destPort","port","action","once","close","timer","setTimeout","Error","_socket","upgrading","code","unref","E","sendMessage","envelope","message","getEnvelope","messageId","recipients","concat","to","length","push","splice","data","dsn","join","send","createReadStream","error","from","connect","login","removeAllListeners","promise","Promise","resolve","reject","callbackPromise","finalize","quit","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst SMTPConnection = require('../smtp-connection');\nconst wellKnown = require('../well-known');\nconst shared = require('../shared');\nconst XOAuth2 = require('../xoauth2');\nconst packageData = require('../../package.json');\n\n/**\n * Creates a SMTP transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options Connection options\n */\nclass SMTPTransport extends EventEmitter {\n    constructor(options) {\n        super();\n\n        options = options || {};\n        if (typeof options === 'string') {\n            options = {\n                url: options\n            };\n        }\n\n        let urlData;\n        let service = options.service;\n\n        if (typeof options.getSocket === 'function') {\n            this.getSocket = options.getSocket;\n        }\n\n        if (options.url) {\n            urlData = shared.parseConnectionUrl(options.url);\n            service = service || urlData.service;\n        }\n\n        this.options = shared.assign(\n            false, // create new object\n            options, // regular options\n            urlData, // url options\n            service && wellKnown(service) // wellknown options\n        );\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-transport'\n        });\n\n        // temporary object\n        let connection = new SMTPConnection(this.options);\n\n        this.name = 'SMTP';\n        this.version = packageData.version + '[client:' + connection.version + ']';\n\n        if (this.options.auth) {\n            this.auth = this.getAuth({});\n        }\n    }\n\n    /**\n     * Placeholder function for creating proxy sockets. This method immediatelly returns\n     * without a socket\n     *\n     * @param {Object} options Connection options\n     * @param {Function} callback Callback function to run with the socket keys\n     */\n    getSocket(options, callback) {\n        // return immediatelly\n        return setImmediate(() => callback(null, false));\n    }\n\n    getAuth(authOpts) {\n        if (!authOpts) {\n            return this.auth;\n        }\n\n        let hasAuth = false;\n        let authData = {};\n\n        if (this.options.auth && typeof this.options.auth === 'object') {\n            Object.keys(this.options.auth).forEach(key => {\n                hasAuth = true;\n                authData[key] = this.options.auth[key];\n            });\n        }\n\n        if (authOpts && typeof authOpts === 'object') {\n            Object.keys(authOpts).forEach(key => {\n                hasAuth = true;\n                authData[key] = authOpts[key];\n            });\n        }\n\n        if (!hasAuth) {\n            return false;\n        }\n\n        switch ((authData.type || '').toString().toUpperCase()) {\n            case 'OAUTH2': {\n                if (!authData.service && !authData.user) {\n                    return false;\n                }\n                let oauth2 = new XOAuth2(authData, this.logger);\n                oauth2.provisionCallback = (this.mailer && this.mailer.get('oauth2_provision_cb')) || oauth2.provisionCallback;\n                oauth2.on('token', token => this.mailer.emit('token', token));\n                oauth2.on('error', err => this.emit('error', err));\n                return {\n                    type: 'OAUTH2',\n                    user: authData.user,\n                    oauth2,\n                    method: 'XOAUTH2'\n                };\n            }\n            default:\n                return {\n                    type: 'LOGIN',\n                    user: authData.user,\n                    credentials: {\n                        user: authData.user || '',\n                        pass: authData.pass\n                    },\n                    method: (authData.method || '').trim().toUpperCase() || false\n                };\n        }\n    }\n\n    /**\n     * Sends an e-mail using the selected settings\n     *\n     * @param {Object} mail Mail object\n     * @param {Function} callback Callback function\n     */\n    send(mail, callback) {\n        this.getSocket(this.options, (err, socketOptions) => {\n            if (err) {\n                return callback(err);\n            }\n\n            let returned = false;\n            let options = this.options;\n            if (socketOptions && socketOptions.connection) {\n                this.logger.info(\n                    {\n                        tnx: 'proxy',\n                        remoteAddress: socketOptions.connection.remoteAddress,\n                        remotePort: socketOptions.connection.remotePort,\n                        destHost: options.host || '',\n                        destPort: options.port || '',\n                        action: 'connected'\n                    },\n                    'Using proxied socket from %s:%s to %s:%s',\n                    socketOptions.connection.remoteAddress,\n                    socketOptions.connection.remotePort,\n                    options.host || '',\n                    options.port || ''\n                );\n\n                // only copy options if we need to modify it\n                options = shared.assign(false, options);\n                Object.keys(socketOptions).forEach(key => {\n                    options[key] = socketOptions[key];\n                });\n            }\n\n            let connection = new SMTPConnection(options);\n\n            connection.once('error', err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.close();\n                return callback(err);\n            });\n\n            connection.once('end', () => {\n                if (returned) {\n                    return;\n                }\n\n                let timer = setTimeout(() => {\n                    if (returned) {\n                        return;\n                    }\n                    returned = true;\n                    // still have not returned, this means we have an unexpected connection close\n                    let err = new Error('Unexpected socket close');\n                    if (connection && connection._socket && connection._socket.upgrading) {\n                        // starttls connection errors\n                        err.code = 'ETLS';\n                    }\n                    callback(err);\n                }, 1000);\n\n                try {\n                    timer.unref();\n                } catch (E) {\n                    // Ignore. Happens on envs with non-node timer implementation\n                }\n            });\n\n            let sendMessage = () => {\n                let envelope = mail.message.getEnvelope();\n                let messageId = mail.message.messageId();\n\n                let recipients = [].concat(envelope.to || []);\n                if (recipients.length > 3) {\n                    recipients.push('...and ' + recipients.splice(2).length + ' more');\n                }\n\n                if (mail.data.dsn) {\n                    envelope.dsn = mail.data.dsn;\n                }\n\n                this.logger.info(\n                    {\n                        tnx: 'send',\n                        messageId\n                    },\n                    'Sending message %s to <%s>',\n                    messageId,\n                    recipients.join(', ')\n                );\n\n                connection.send(envelope, mail.message.createReadStream(), (err, info) => {\n                    returned = true;\n                    connection.close();\n                    if (err) {\n                        this.logger.error(\n                            {\n                                err,\n                                tnx: 'send'\n                            },\n                            'Send error for %s: %s',\n                            messageId,\n                            err.message\n                        );\n                        return callback(err);\n                    }\n                    info.envelope = {\n                        from: envelope.from,\n                        to: envelope.to\n                    };\n                    info.messageId = messageId;\n                    try {\n                        return callback(null, info);\n                    } catch (E) {\n                        this.logger.error(\n                            {\n                                err: E,\n                                tnx: 'callback'\n                            },\n                            'Callback error for %s: %s',\n                            messageId,\n                            E.message\n                        );\n                    }\n                });\n            };\n\n            connection.connect(() => {\n                if (returned) {\n                    return;\n                }\n\n                let auth = this.getAuth(mail.data.auth);\n\n                if (auth) {\n                    connection.login(auth, err => {\n                        if (auth && auth !== this.auth && auth.oauth2) {\n                            auth.oauth2.removeAllListeners();\n                        }\n                        if (returned) {\n                            return;\n                        }\n\n                        if (err) {\n                            returned = true;\n                            connection.close();\n                            return callback(err);\n                        }\n\n                        sendMessage();\n                    });\n                } else {\n                    sendMessage();\n                }\n            });\n        });\n    }\n\n    /**\n     * Verifies SMTP configuration\n     *\n     * @param {Function} callback Callback function\n     */\n    verify(callback) {\n        let promise;\n\n        if (!callback && typeof Promise === 'function') {\n            promise = new Promise((resolve, reject) => {\n                callback = shared.callbackPromise(resolve, reject);\n            });\n        }\n\n        this.getSocket(this.options, (err, socketOptions) => {\n            if (err) {\n                return callback(err);\n            }\n\n            let options = this.options;\n            if (socketOptions && socketOptions.connection) {\n                this.logger.info(\n                    {\n                        tnx: 'proxy',\n                        remoteAddress: socketOptions.connection.remoteAddress,\n                        remotePort: socketOptions.connection.remotePort,\n                        destHost: options.host || '',\n                        destPort: options.port || '',\n                        action: 'connected'\n                    },\n                    'Using proxied socket from %s:%s to %s:%s',\n                    socketOptions.connection.remoteAddress,\n                    socketOptions.connection.remotePort,\n                    options.host || '',\n                    options.port || ''\n                );\n\n                options = shared.assign(false, options);\n                Object.keys(socketOptions).forEach(key => {\n                    options[key] = socketOptions[key];\n                });\n            }\n\n            let connection = new SMTPConnection(options);\n            let returned = false;\n\n            connection.once('error', err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.close();\n                return callback(err);\n            });\n\n            connection.once('end', () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                return callback(new Error('Connection closed'));\n            });\n\n            let finalize = () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                connection.quit();\n                return callback(null, true);\n            };\n\n            connection.connect(() => {\n                if (returned) {\n                    return;\n                }\n\n                let authData = this.getAuth({});\n\n                if (authData) {\n                    connection.login(authData, err => {\n                        if (returned) {\n                            return;\n                        }\n\n                        if (err) {\n                            returned = true;\n                            connection.close();\n                            return callback(err);\n                        }\n\n                        finalize();\n                    });\n                } else {\n                    finalize();\n                }\n            });\n        });\n\n        return promise;\n    }\n\n    /**\n     * Releases resources\n     */\n    close() {\n        if (this.auth && this.auth.oauth2) {\n            this.auth.oauth2.removeAllListeners();\n        }\n        this.emit('close');\n    }\n}\n\n// expose to the world\nmodule.exports = SMTPTransport;\n"]},"metadata":{},"sourceType":"script"}