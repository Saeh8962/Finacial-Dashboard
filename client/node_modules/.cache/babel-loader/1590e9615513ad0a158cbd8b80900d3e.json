{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _toConsumableArray = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _asyncToGenerator = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require(\"./stream-errors\"),\n    StreamError = _require.StreamError;\n/**\n * Generate read methods on the stream class.\n *\n * @internal\n * @param  {DataStreamOptions} newOptions Sanitized options passed to scramjet stream\n * @return {Boolean} returns true if creation of new stream is not necessary (promise can be pushed to queue)\n */\n\n\nmodule.exports = function () {\n  return function mkRead(newOptions) {\n    var _this = this;\n\n    this.setOptions({\n      // transforms: [],\n      promiseRead: newOptions.promiseRead\n    });\n    var chunks = [];\n    var done = false; // TODO: implement the actual parallel logic - items can be promises and should be flushed when resolved.\n\n    var pushSome = function pushSome() {\n      return Array.prototype.findIndex.call(chunks, function (chunk) {\n        return !_this.push(chunk);\n      }) + 1;\n    }; // let last = Promise.resolve();\n    // let processing = [];\n\n\n    this.on(\"pipe\", function () {\n      throw new Error(\"Cannot pipe to a Readable stream\");\n    });\n\n    this._read = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(size) {\n        var add, _chunks, nw, pushed;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                add = 0;\n\n                if (done) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _context.next = 5;\n                return _this._options.promiseRead(size);\n\n              case 5:\n                nw = _context.sent;\n\n                (_chunks = chunks).push.apply(_chunks, _toConsumableArray(nw));\n\n                add = nw.length;\n\n              case 8:\n                pushed = pushSome();\n                chunks = chunks.slice(pushed || Infinity); // Yes, it could be reassigned, but only with true so we don't need to care\n                // eslint-disable-next-line require-atomic-updates\n\n                done = done || !add;\n\n                if (!(done && !chunks.length)) {\n                  _context.next = 15;\n                  break;\n                }\n\n                _context.next = 14;\n                return new Promise(function (res, rej) {\n                  return _this._flush(function (err) {\n                    return err ? rej(err) : res();\n                  });\n                });\n\n              case 14:\n                _this.push(null);\n\n              case 15:\n                _context.next = 22;\n                break;\n\n              case 17:\n                _context.prev = 17;\n                _context.t0 = _context[\"catch\"](0);\n                _context.next = 21;\n                return _this.raise(new StreamError(_context.t0, _this));\n\n              case 21:\n                return _context.abrupt(\"return\", _this._read(size));\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[0, 17]]);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  };\n};","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/client/node_modules/scramjet-core/lib/util/mk-read.js"],"names":["require","StreamError","module","exports","mkRead","newOptions","setOptions","promiseRead","chunks","done","pushSome","Array","prototype","findIndex","call","chunk","push","on","Error","_read","size","add","_options","nw","length","pushed","slice","Infinity","Promise","res","rej","_flush","err","raise"],"mappings":";;;;;;AAAA,eAAwBA,OAAO,CAAC,iBAAD,CAA/B;AAAA,IAAQC,WAAR,YAAQA,WAAR;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB;AAAA,SAAM,SAASC,MAAT,CAAgBC,UAAhB,EAA4B;AAAA;;AAC/C,SAAKC,UAAL,CACI;AACI;AACAC,MAAAA,WAAW,EAAEF,UAAU,CAACE;AAF5B,KADJ;AAOA,QAAIC,MAAM,GAAG,EAAb;AACA,QAAIC,IAAI,GAAG,KAAX,CAT+C,CAU/C;;AACA,QAAMC,QAAQ,GAAG,SAAXA,QAAW;AAAA,aAAMC,KAAK,CAACC,SAAN,CAAgBC,SAAhB,CAA0BC,IAA1B,CAA+BN,MAA/B,EAAuC,UAAAO,KAAK,EAAI;AACnE,eAAO,CAAC,KAAI,CAACC,IAAL,CAAUD,KAAV,CAAR;AACH,OAFsB,IAElB,CAFY;AAAA,KAAjB,CAX+C,CAe/C;AACA;;;AAEA,SAAKE,EAAL,CAAQ,MAAR,EAAgB,YAAM;AAClB,YAAM,IAAIC,KAAJ,CAAU,kCAAV,CAAN;AACH,KAFD;;AAIA,SAAKC,KAAL;AAAA,0EAAa,iBAAOC,IAAP;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEDC,gBAAAA,GAFC,GAEK,CAFL;;AAAA,oBAGAZ,IAHA;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAIgB,KAAI,CAACa,QAAL,CAAcf,WAAd,CAA0Ba,IAA1B,CAJhB;;AAAA;AAIKG,gBAAAA,EAJL;;AAKD,2BAAAf,MAAM,EAACQ,IAAP,mCAAeO,EAAf;;AACAF,gBAAAA,GAAG,GAAGE,EAAE,CAACC,MAAT;;AANC;AAQCC,gBAAAA,MARD,GAQUf,QAAQ,EARlB;AASLF,gBAAAA,MAAM,GAAGA,MAAM,CAACkB,KAAP,CAAaD,MAAM,IAAIE,QAAvB,CAAT,CATK,CAWL;AACA;;AACAlB,gBAAAA,IAAI,GAAGA,IAAI,IAAI,CAACY,GAAhB;;AAbK,sBAeDZ,IAAI,IAAI,CAACD,MAAM,CAACgB,MAff;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAgBK,IAAII,OAAJ,CAAY,UAACC,GAAD,EAAMC,GAAN;AAAA,yBAAc,KAAI,CAACC,MAAL,CAAY,UAACC,GAAD;AAAA,2BAASA,GAAG,GAAGF,GAAG,CAACE,GAAD,CAAN,GAAcH,GAAG,EAA7B;AAAA,mBAAZ,CAAd;AAAA,iBAAZ,CAhBL;;AAAA;AAiBD,gBAAA,KAAI,CAACb,IAAL,CAAU,IAAV;;AAjBC;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,uBA0BC,KAAI,CAACiB,KAAL,CAAW,IAAIhC,WAAJ,cAAmB,KAAnB,CAAX,CA1BD;;AAAA;AAAA,iDA2BE,KAAI,CAACkB,KAAL,CAAWC,IAAX,CA3BF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAb;;AAAA;AAAA;AAAA;AAAA;AA+BH,GArDgB;AAAA,CAAjB","sourcesContent":["const { StreamError } = require(\"./stream-errors\");\n\n/**\n * Generate read methods on the stream class.\n *\n * @internal\n * @param  {DataStreamOptions} newOptions Sanitized options passed to scramjet stream\n * @return {Boolean} returns true if creation of new stream is not necessary (promise can be pushed to queue)\n */\nmodule.exports = () => function mkRead(newOptions) {\n    this.setOptions(\n        {\n            // transforms: [],\n            promiseRead: newOptions.promiseRead\n        }\n    );\n\n    let chunks = [];\n    let done = false;\n    // TODO: implement the actual parallel logic - items can be promises and should be flushed when resolved.\n    const pushSome = () => Array.prototype.findIndex.call(chunks, chunk => {\n        return !this.push(chunk);\n    }) + 1;\n\n    // let last = Promise.resolve();\n    // let processing = [];\n\n    this.on(\"pipe\", () => {\n        throw new Error(\"Cannot pipe to a Readable stream\");\n    });\n\n    this._read = async (size) => {\n        try {\n            let add = 0;\n            if (!done) {\n                const nw = await this._options.promiseRead(size);\n                chunks.push(...nw);\n                add = nw.length;\n            }\n            const pushed = pushSome();\n            chunks = chunks.slice(pushed || Infinity);\n\n            // Yes, it could be reassigned, but only with true so we don't need to care\n            // eslint-disable-next-line require-atomic-updates\n            done = done || !add;\n\n            if (done && !chunks.length) {\n                await new Promise((res, rej) => this._flush((err) => err ? rej(err) : res()));\n                this.push(null);\n            }\n\n            // console.log(\"read\", pushed, chunks, add, size);\n            // TODO: check for existence of transforms and push to transform directly.\n            // TODO: but in both cases transform methods must be there... which aren't there now.\n            // TODO: at least the subset that makes the transform - yes, otherwise all that transform stuff\n            // TODO: is useless and can be bypassed...\n        } catch(e) {\n            await this.raise(new StreamError(e, this));\n            return this._read(size);\n        }\n    };\n\n};\n"]},"metadata":{},"sourceType":"script"}