{"ast":null,"code":"var _toConsumableArray = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _require = require(\"stream\"),\n    Writable = _require.Writable,\n    Readable = _require.Readable;\n\nvar _require2 = require(\"events\"),\n    EventEmitter = _require2.EventEmitter;\n\nvar ReReadable = /*#__PURE__*/function (_Writable) {\n  \"use strict\";\n\n  _inherits(ReReadable, _Writable);\n\n  var _super = _createSuper(ReReadable);\n\n  function ReReadable(options) {\n    var _this;\n\n    _classCallCheck(this, ReReadable);\n\n    options = Object.assign({\n      length: 1048576,\n      highWaterMark: 32,\n      dropInterval: 1e3\n    }, options);\n    _this = _super.call(this, options);\n    _this._readableOptions = options;\n    _this._highWaterMark = options.highWaterMark;\n    _this._bufArrLength = options.length;\n    _this._reading = 0;\n    _this._bufArr = [];\n    _this.hiBufCr = 0;\n    _this.loBufCr = 0;\n    _this._waiting = null;\n    _this._ended = new Promise(function (res) {\n      return _this.on(\"finish\", res);\n    });\n    return _this;\n  }\n\n  _createClass(ReReadable, [{\n    key: \"_write\",\n    value: function _write(chunk, encoding, callback) {\n      this._bufArr.push([chunk, encoding]);\n\n      if (this._bufArr.length > this._bufArrLength) {\n        this._waiting = callback;\n        this.drop();\n      } else {\n        callback();\n      }\n\n      this.emit(\"wrote\");\n    }\n  }, {\n    key: \"_writev\",\n    value: function _writev(chunks, callback) {\n      var _this$_bufArr;\n\n      (_this$_bufArr = this._bufArr).push.apply(_this$_bufArr, _toConsumableArray(chunks.map(function (_ref) {\n        var chunk = _ref.chunk,\n            encoding = _ref.encoding;\n        return [chunk, encoding];\n      })));\n\n      if (this._bufArr.length > this._bufArrLength) {\n        this._waiting = callback;\n        this.drop();\n      } else {\n        callback();\n      }\n\n      this.emit(\"wrote\");\n    }\n  }, {\n    key: \"updateBufPosition\",\n    value: function updateBufPosition(bufCr) {\n      this.hiBufCr = bufCr > this.hiBufCr ? bufCr : this.hiBufCr;\n      this.loBufCr = bufCr > this.loBufCr ? bufCr : this.loBufCr;\n\n      if (this._waiting && this.hiBufCr >= this._bufArrLength - this._highWaterMark) {\n        var cb = this._waiting;\n        this._waiting = null;\n        cb();\n      }\n    }\n  }, {\n    key: \"drop\",\n    value: function drop() {\n      if (this._bufArr.length > this._bufArrLength) this.emit(\"drop\", this._bufArr.splice(0, this._bufArr.length - this._bufArrLength).length);\n    }\n  }, {\n    key: \"rewind\",\n    value: function rewind() {\n      return this.tail(-1);\n    }\n  }, {\n    key: \"tail\",\n    value: function tail(count) {\n      var _this2 = this;\n\n      var end = false;\n\n      this._ended.then(function () {\n        return ret._read(end = true);\n      });\n\n      this.setMaxListeners(++this._reading + EventEmitter.defaultMaxListeners);\n      var ret = new Readable(Object.assign(this._readableOptions, {\n        read: function read() {\n          if (ret.bufCr < _this2._bufArr.length) {\n            while (ret.bufCr < _this2._bufArr.length) {\n              // while there's anything to read\n              var resp = ret.push.apply(ret, _toConsumableArray(_this2._bufArr[ret.bufCr++])); // push to readable\n\n              if (!resp && !end) break; // until there's not willing to read and we're not ended\n            }\n\n            _this2.updateBufPosition(ret.bufCr);\n          } else if (!end) {\n            _this2.once(\"wrote\", ret._read);\n          }\n\n          if (end) ret.push(null);\n        }\n      }));\n      ret.bufCr = count < this._bufArr.length && count > 0 ? this._bufArr.length - count : 0;\n      this.on(\"drop\", function (count) {\n        ret.bufCr -= count;\n\n        if (ret.bufCr < 0) {\n          ret.emit(\"drop\", -ret.bufCr);\n          ret.bufCr = 0;\n        }\n      });\n      return ret;\n    }\n  }]);\n\n  return ReReadable;\n}(Writable);\n\nmodule.exports = {\n  ReReadable: ReReadable\n};","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/client/node_modules/rereadable-stream/index.js"],"names":["require","Writable","Readable","EventEmitter","ReReadable","options","Object","assign","length","highWaterMark","dropInterval","_readableOptions","_highWaterMark","_bufArrLength","_reading","_bufArr","hiBufCr","loBufCr","_waiting","_ended","Promise","res","on","chunk","encoding","callback","push","drop","emit","chunks","map","bufCr","cb","splice","tail","count","end","then","ret","_read","setMaxListeners","defaultMaxListeners","read","resp","updateBufPosition","once","module","exports"],"mappings":"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","sourcesContent":["const {Writable, Readable} = require(\"stream\");\nconst {EventEmitter} = require(\"events\");\n\nclass ReReadable extends Writable {\n\n    constructor(options) {\n\n        options = Object.assign({\n            length: 1048576,\n            highWaterMark: 32,\n            dropInterval: 1e3\n        }, options);\n\n        super(options);\n\n        this._readableOptions = options;\n\n        this._highWaterMark = options.highWaterMark;\n        this._bufArrLength = options.length;\n\n        this._reading = 0;\n        this._bufArr = [];\n        this.hiBufCr = 0;\n        this.loBufCr = 0;\n        this._waiting = null;\n        this._ended = new Promise((res) => this.on(\"finish\", res));\n\n    }\n\n    _write(chunk, encoding, callback) {\n        this._bufArr.push([chunk, encoding]);\n        if (this._bufArr.length > this._bufArrLength) {\n            this._waiting = callback;\n            this.drop();\n        } else {\n            callback();\n        }\n        this.emit(\"wrote\");\n    }\n\n    _writev(chunks, callback) {\n        this._bufArr.push(...chunks.map(({chunk, encoding}) => [chunk, encoding]));\n        if (this._bufArr.length > this._bufArrLength) {\n            this._waiting = callback;\n            this.drop();\n        } else {\n            callback();\n        }\n        this.emit(\"wrote\");\n    }\n\n    updateBufPosition(bufCr) {\n        this.hiBufCr = bufCr > this.hiBufCr ? bufCr : this.hiBufCr;\n        this.loBufCr = bufCr > this.loBufCr ? bufCr : this.loBufCr;\n        if (this._waiting && this.hiBufCr >= this._bufArrLength - this._highWaterMark) {\n            const cb = this._waiting;\n            this._waiting = null;\n            cb();\n        }\n    }\n\n    drop() {\n        if (this._bufArr.length > this._bufArrLength)\n            this.emit(\"drop\", this._bufArr.splice(0, this._bufArr.length - this._bufArrLength).length);\n    }\n\n    rewind() {\n        return this.tail(-1);\n    }\n\n    tail(count) {\n        let end = false;\n        this._ended.then(() => ret._read(end = true));\n        this.setMaxListeners(++this._reading + EventEmitter.defaultMaxListeners);\n\n        const ret = new Readable(Object.assign(this._readableOptions, {\n            read: () => {\n                if (ret.bufCr < this._bufArr.length) {\n                    while(ret.bufCr < this._bufArr.length) {                 // while there's anything to read\n                        const resp = ret.push(...this._bufArr[ret.bufCr++]); // push to readable\n                        if (!resp && !end) break;                            // until there's not willing to read and we're not ended\n                    }\n                    this.updateBufPosition(ret.bufCr);\n                } else if (!end) {\n                    this.once(\"wrote\", ret._read);\n                }\n\n                if (end)\n                    ret.push(null);\n            }\n        }));\n\n        ret.bufCr = count < this._bufArr.length && count > 0 ? this._bufArr.length - count : 0;\n\n        this.on(\"drop\", (count) => {\n            ret.bufCr -= count;\n            if (ret.bufCr < 0) {\n                ret.emit(\"drop\", -ret.bufCr);\n                ret.bufCr = 0;\n            }\n        });\n\n        return ret;\n    }\n}\n\nmodule.exports = {ReReadable};\n"]},"metadata":{},"sourceType":"script"}