{"ast":null,"code":"var _slicedToArray = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar scramjet = require(\"./\");\n\nvar PromiseTransformStream = scramjet.PromiseTransformStream,\n    StringStream = scramjet.StringStream,\n    DataStream = scramjet.DataStream,\n    MultiStream = scramjet.MultiStream;\n\nvar _require = require(\"events\"),\n    EventEmitter = _require.EventEmitter;\n\nvar _require2 = require(\"rereadable-stream\"),\n    ReReadable = _require2.ReReadable;\n\nvar _require3 = require(\"scramjet-core/lib/util/utils\"),\n    AsyncGeneratorFunction = _require3.AsyncGeneratorFunction,\n    GeneratorFunction = _require3.GeneratorFunction;\n\nvar os = require(\"os\");\n\nvar path = require(\"path\");\n/** @ignore */\n\n\nvar _require4 = require(\"scramjet-core/lib/util/utils\"),\n    getCalleeDirname = _require4.getCalleeDirname;\n\nmodule.exports = {\n  constructor: function constructor() {\n    this.TimeSource = Date;\n    this.setTimeout = setTimeout;\n    this.clearTimeout = clearTimeout;\n    this.buffer = null;\n  },\n\n  /**\n   * Pulls in any readable stream, resolves when the pulled stream ends.\n   *\n   * You can also pass anything that can be passed to `DataStream.from`.\n   *\n   * Does not preserve order, does not end this stream.\n   *\n   * @async\n   * @memberof module:scramjet.DataStream#\n   * @param {Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|string|Readable} pullable\n   * @param {any[]} ...args any additional args\n   * @returns {Promise<any>} resolved when incoming stream ends, rejects on incoming error\n   *\n   * @test test/methods/data-stream-pull.js\n   */\n  pull: function pull(pullable) {\n    var _arguments = arguments,\n        _this = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var _len, args, _key;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              for (_len = _arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = _arguments[_key];\n              }\n\n              return _context.abrupt(\"return\", new Promise(function (res, rej) {\n                var _this$constructor;\n\n                var incoming = (_this$constructor = _this.constructor).from.apply(_this$constructor, [pullable, {}].concat(args));\n\n                incoming.pipe(_this, {\n                  end: false\n                });\n                incoming.on(\"end\", res);\n                incoming.on(\"error\", rej);\n              }));\n\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  },\n\n  /**\n   * Shift Function\n   *\n   * @callback ShiftCallback\n   * @memberof module:scramjet~\n   * @param {Array<object>|any} shifted an array of shifted chunks\n   */\n\n  /**\n   * Shifts the first n items from the stream and pushes out the remaining ones.\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param {number} count The number of items to shift.\n   * @param {ShiftCallback} func Function that receives an array of shifted items\n   *\n   * @test test/methods/data-stream-shift.js\n   */\n  shift: function shift(count, func) {\n    var _this2 = this;\n\n    var ret = [];\n\n    var str = this.tap()._selfInstance({\n      referrer: this\n    });\n\n    var chunkHandler = function chunkHandler(chunk) {\n      ret.push(chunk);\n\n      if (ret.length >= count) {\n        _this2.pause();\n\n        unHook().then(function () {\n          return _this2.resume().pipe(str);\n        });\n      }\n    };\n\n    var endHandler = function endHandler() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      unHook().then(function () {\n        return str.end.apply(str, args);\n      });\n    };\n\n    var errorHandler = str.emit.bind(str, \"error\");\n    var hooked = true;\n\n    var unHook = function unHook() {\n      if (hooked) {\n        hooked = false;\n\n        _this2.removeListener(\"data\", chunkHandler);\n\n        _this2.removeListener(\"end\", endHandler);\n\n        _this2.removeListener(\"error\", errorHandler);\n      }\n\n      return Promise.resolve(ret).then(func);\n    };\n\n    this.on(\"data\", chunkHandler);\n    this.on(\"end\", endHandler);\n    this.on(\"error\", errorHandler);\n    return str;\n  },\n\n  /**\n   * Allows previewing some of the streams data without removing them from the stream.\n   *\n   * Important: Peek does not resume the flow.\n   *\n   * @memberof module:scramjet.DataStream#\n   * @param  {number} count The number of items to view before\n   * @param  {ShiftCallback} func Function called before other streams\n   * @chainable\n   */\n  peek: function peek(count, func) {\n    var _this3 = this;\n\n    var ref = this._selfInstance({\n      referrer: this\n    });\n\n    this.tap().pipe(ref).shift(count, function (batch) {\n      _this3.unpipe(ref);\n\n      return func(batch);\n    });\n    return this;\n  },\n\n  /**\n   * Slices out a part of the stream to the passed Function.\n   *\n   * Returns a stream consisting of an array of items with `0` to `start`\n   * omitted and `length` items after `start` included. Works similarly to\n   * Array.prototype.slice.\n   *\n   * Takes count from the moment it's called. Any previous items will not be\n   * taken into account.\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param {number} [start=0] omit this number of entries.\n   * @param {number} [length=Infinity] get this number of entries to the resulting stream\n   *\n   * @test test/methods/data-stream-slice.js\n   */\n  slice: function slice() {\n    var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n    var n = 0;\n    var stream = this;\n\n    if (start > 0) {\n      stream = this.shift(start, function () {\n        return 0;\n      });\n    }\n\n    if (length === Infinity) {\n      return this;\n    }\n\n    return stream.until(function () {\n      return n++ >= length;\n    });\n  },\n\n  /**\n   * Transforms stream objects by assigning the properties from the returned\n   * data along with data from original ones.\n   *\n   * The original objects are unaltered.\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param {MapCallback|object} func The function that returns new object properties or just the new properties\n   *\n   * @test test/methods/data-stream-assign.js\n   */\n  assign: function assign(func) {\n    if (typeof func === \"function\") {\n      return this.map(function (chunk) {\n        return Promise.resolve(func(chunk)).then(function (obj) {\n          return Object.assign({}, chunk, obj);\n        });\n      });\n    } else {\n      return this.map(function (chunk) {\n        return Object.assign({}, chunk, func);\n      });\n    }\n  },\n\n  /**\n   * Called only before the stream ends without passing any items\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param {Function} callback Function called when stream ends\n   *\n   * @test test/methods/data-stream-empty.js\n   */\n  empty: function empty(callback) {\n    var _this4 = this;\n\n    var z = false;\n\n    var promiseTransform = function promiseTransform() {\n      z = true;\n\n      _this4.dropTransform(promiseTransform);\n    };\n\n    this.pushTransform({\n      promiseTransform: promiseTransform\n    }).tap().whenEnd().then(function () {\n      return z || Promise.resolve().then(callback);\n    }, function () {\n      return 0;\n    });\n    return this;\n  },\n\n  /**\n   * Pushes any data at call time (essentially at the beginning of the stream)\n   *\n   * This is a synchronous only function.\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param {any[]} ...item list of items to unshift (you can pass more items)\n   */\n  unshift: function unshift() {\n    var _this5 = this;\n\n    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      items[_key3] = arguments[_key3];\n    }\n\n    items.forEach(function (item) {\n      return _this5.write(item);\n    });\n    return this.tap();\n  },\n\n  /**\n   * Pushes any data at end of stream\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param {*} item list of items to push at end\n   * @meta.noreadme\n   *\n   * @test test/methods/data-stream-endwith.js\n   */\n  endWith: function endWith() {\n    for (var _len4 = arguments.length, items = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      items[_key4] = arguments[_key4];\n    }\n\n    // TODO: overhead on unneeded transform, but requires changes in core.\n    // TODO: should accept similar args as `from`\n    return this.pipe(this._selfInstance({\n      referrer: this,\n      promiseTransform: function promiseTransform(a) {\n        return a;\n      },\n      flushPromise: function flushPromise() {\n        return items;\n      }\n    }));\n  },\n\n  /**\n   * Accumulates data into the object.\n   *\n   * Works very similarly to reduce, but result of previous operations have\n   * no influence over the accumulator in the next one.\n   *\n   * Method works in parallel.\n   *\n   * @async\n   * @memberof module:scramjet.DataStream#\n   * @param  {AccumulateCallback} func The accumulation function\n   * @param  {*} into Accumulator object\n   * @return {Promise<any>}  resolved with the \"into\" object on stream end.\n   * @meta.noreadme\n   *\n   * @test test/methods/data-stream-accumulate.js\n   */\n  accumulate: function accumulate(func, into) {\n    var _this6 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", new Promise(function (res, rej) {\n                var bound = /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(chunk) {\n                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            _context2.next = 2;\n                            return func(into, chunk);\n\n                          case 2:\n                            return _context2.abrupt(\"return\", Promise.reject(DataStream.filter));\n\n                          case 3:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2);\n                  }));\n\n                  return function bound(_x) {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n\n                bound.to = func;\n\n                _this6.tap().pipe(new PromiseTransformStream({\n                  promiseTransform: bound,\n                  referrer: _this6\n                })).on(\"end\", function () {\n                  return res(into);\n                }).on(\"error\", rej).resume();\n              }));\n\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }))();\n  },\n\n  /**\n   * @callback AccumulateCallback\n   * @memberof module:scramjet~\n   * @param {*} accumulator Accumulator passed to accumulate function\n   * @param {*} chunk the stream chunk\n   * @return {Promise<any>|*} resolved when all operations are completed\n   */\n\n  /**\n   * Consumes the stream by running each Function\n   *\n   * @deprecated use {@link DataStream#each} instead\n   *\n   * @async\n   * @memberof module:scramjet.DataStream#\n   * @param {ConsumeCallback|AsyncGeneratorFunction|GeneratorFunction} func the consument\n   * @param {any[]} ...args additional args will be passed to generators\n   * @meta.noreadme\n   */\n  consume: function consume(func) {\n    var _arguments2 = arguments,\n        _this7 = this;\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n      var runFunc, _len5, args, _key5, gen;\n\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              runFunc = func;\n\n              if (!(func instanceof GeneratorFunction || func instanceof AsyncGeneratorFunction)) {\n                _context5.next = 9;\n                break;\n              }\n\n              for (_len5 = _arguments2.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n                args[_key5 - 1] = _arguments2[_key5];\n              }\n\n              _context5.next = 5;\n              return func.apply(void 0, args);\n\n            case 5:\n              gen = _context5.sent;\n              _context5.next = 8;\n              return gen.next();\n\n            case 8:\n              runFunc = /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(item) {\n                  return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          _context4.next = 2;\n                          return gen.next(item);\n\n                        case 2:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _callee4);\n                }));\n\n                return function runFunc(_x2) {\n                  return _ref2.apply(this, arguments);\n                };\n              }();\n\n            case 9:\n              return _context5.abrupt(\"return\", _this7.tap().do(runFunc).resume().whenEnd());\n\n            case 10:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }))();\n  },\n\n  /**\n   * @callback ConsumeCallback\n   * @memberof module:scramjet~\n   * @param {*} chunk the stream chunk\n   * @return {Promise<any>|*} resolved when all operations are completed\n   */\n\n  /**\n   * Reduces the stream into the given object, returning it immediately.\n   *\n   * The main difference to reduce is that only the first object will be\n   * returned at once (however the method will be called with the previous\n   * entry).\n   * If the object is an instance of EventEmitter then it will propagate the\n   * error from the previous stream.\n   *\n   * This method is serial - meaning that any processing on an entry will\n   * occur only after the previous entry is fully processed. This does mean\n   * it's much slower than parallel functions.\n   *\n   * @meta.noreadme\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param  {ReduceCallback} func The into object will be passed as the first argument, the data object from the stream as the second.\n   * @param  {*|EventEmitter} into Any object passed initially to the transform  function\n   * @return {*} whatever was passed as into\n   *\n   * @test test/methods/data-stream-reduceNow.js\n   */\n  reduceNow: function reduceNow(func, into) {\n    var prm = this.reduce(func, into);\n\n    if (into instanceof EventEmitter) {\n      prm.catch(function (e) {\n        return into.emit(\"error\", e);\n      });\n    }\n\n    return into;\n  },\n\n  /**\n   * @callback RemapCallback\n   * @memberof module:scramjet~\n   * @param {Function} emit a method to emit objects in the remapped stream\n   * @param {*} chunk the chunk from the original stream\n   * @returns {Promise<any>|*} promise to be resolved when chunk has been processed\n   */\n\n  /**\n   * Remaps the stream into a new stream.\n   *\n   * This means that every item may emit as many other items as we like.\n   *\n   * @meta.noreadme\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param  {RemapCallback} func A Function that is called on every chunk\n   * @param  {function(new:DataStream)} [ClassType=this.constructor] Optional DataStream subclass to be constructed\n   *\n   * @test test/methods/data-stream-remap.js\n   */\n  remap: function remap(func) {\n    var ClassType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.constructor;\n    var ref = new (ClassType || this.constructor)({\n      referrer: this\n    });\n    return this.into( /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(str, chunk) {\n        var out, last, _i, _out, val;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                out = [];\n                _context6.next = 3;\n                return func(function (newChunk) {\n                  return out.push(newChunk);\n                }, chunk);\n\n              case 3:\n                last = true;\n\n                for (_i = 0, _out = out; _i < _out.length; _i++) {\n                  val = _out[_i];\n                  last = ref.write(val);\n                }\n\n                return _context6.abrupt(\"return\", last ? null : ref.whenDrained());\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      return function (_x3, _x4) {\n        return _ref3.apply(this, arguments);\n      };\n    }(), ref);\n  },\n\n  /**\n   * Takes any method that returns any iterable and flattens the result.\n   *\n   * The passed Function must return an iterable (otherwise an error will be emitted). The resulting stream will\n   * consist of all the items of the returned iterables, one iterable after another.\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param {FlatMapCallback} func A Function that is called on every chunk\n   * @param {function(new:DataStream)} [ClassType=this.constructor] Optional DataStream subclass to be constructed\n   * @param {any[]} ...args additional args will be passed to generators\n   *\n   * @test test/methods/data-stream-flatmap.js\n   */\n  flatMap: function flatMap(func, ClassType) {\n    for (var _len6 = arguments.length, args = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {\n      args[_key6 - 2] = arguments[_key6];\n    }\n\n    if (typeof ClassType !== \"function\") ClassType = this.constructor;\n    var ref = new ClassType({\n      referrer: this\n    });\n    var asyncIteratorSymbol = Symbol.asyncIterator;\n    return this.into( /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(ref, chunk) {\n        var out, iterator, item, chunks;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return func.apply(void 0, [chunk].concat(args));\n\n              case 2:\n                out = _context7.sent;\n\n                if (out) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Non iterable object returned for flatMap!\");\n\n              case 5:\n                if (!(asyncIteratorSymbol && out[asyncIteratorSymbol])) {\n                  _context7.next = 20;\n                  break;\n                }\n\n                iterator = out[asyncIteratorSymbol](); // eslint-disable-next-line no-constant-condition\n\n              case 7:\n                if (!true) {\n                  _context7.next = 18;\n                  break;\n                }\n\n                _context7.next = 10;\n                return iterator.next();\n\n              case 10:\n                item = _context7.sent;\n\n                if (!item.done) {\n                  _context7.next = 13;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\");\n\n              case 13:\n                if (ref.write(item.value)) {\n                  _context7.next = 16;\n                  break;\n                }\n\n                _context7.next = 16;\n                return ref.whenDrained();\n\n              case 16:\n                _context7.next = 7;\n                break;\n\n              case 18:\n                _context7.next = 25;\n                break;\n\n              case 20:\n                chunks = _toConsumableArray(out);\n\n                if (!(chunks.length === 0)) {\n                  _context7.next = 23;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\");\n\n              case 23:\n                _context7.next = 25;\n                return ref.whenWrote.apply(ref, _toConsumableArray(chunks));\n\n              case 25:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      return function (_x5, _x6) {\n        return _ref4.apply(this, arguments);\n      };\n    }(), ref);\n  },\n\n  /**\n   * @callback FlatMapCallback\n   * @memberof module:scramjet~\n   * @param {*} chunk the chunk from the original stream\n   * @returns {AsyncGenerator<any, void, any>|Promise<Iterable<any>>|Iterable<any>}  promise to be resolved when chunk has been processed\n   */\n\n  /**\n   * A shorthand for streams of arrays or iterables to flatten them.\n   *\n   * More efficient equivalent of: `.flatmap(i => i);`\n   * Works on streams of async iterables too.\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @return {DataStream}\n   *\n   * @test test/methods/data-stream-flatten.js\n   */\n  flatten: function flatten() {\n    var iteratorSymbol = Symbol.asyncIterator;\n    var wroteAll = Promise.resolve();\n    return this.into( /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(ref, chunk) {\n        var prevWrote, res, iterator, item, last, _iterator, _step, val;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                prevWrote = wroteAll;\n                wroteAll = new Promise(function (_res) {\n                  return res = _res;\n                });\n\n                if (!(iteratorSymbol && chunk[iteratorSymbol])) {\n                  _context8.next = 19;\n                  break;\n                }\n\n                iterator = chunk[iteratorSymbol]();\n                _context8.next = 6;\n                return prevWrote;\n\n              case 6:\n                if (!true) {\n                  _context8.next = 17;\n                  break;\n                }\n\n                _context8.next = 9;\n                return iterator.next();\n\n              case 9:\n                item = _context8.sent;\n\n                if (!(item.value && !ref.write(item.value))) {\n                  _context8.next = 13;\n                  break;\n                }\n\n                _context8.next = 13;\n                return ref.whenDrained();\n\n              case 13:\n                if (!item.done) {\n                  _context8.next = 15;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", res());\n\n              case 15:\n                _context8.next = 6;\n                break;\n\n              case 17:\n                _context8.next = 42;\n                break;\n\n              case 19:\n                last = true;\n                _context8.next = 22;\n                return prevWrote;\n\n              case 22:\n                _iterator = _createForOfIteratorHelper(chunk);\n                _context8.prev = 23;\n\n                _iterator.s();\n\n              case 25:\n                if ((_step = _iterator.n()).done) {\n                  _context8.next = 33;\n                  break;\n                }\n\n                val = _step.value;\n                last = ref.write(val);\n\n                if (last) {\n                  _context8.next = 31;\n                  break;\n                }\n\n                _context8.next = 31;\n                return ref.whenDrained();\n\n              case 31:\n                _context8.next = 25;\n                break;\n\n              case 33:\n                _context8.next = 38;\n                break;\n\n              case 35:\n                _context8.prev = 35;\n                _context8.t0 = _context8[\"catch\"](23);\n\n                _iterator.e(_context8.t0);\n\n              case 38:\n                _context8.prev = 38;\n\n                _iterator.f();\n\n                return _context8.finish(38);\n\n              case 41:\n                return _context8.abrupt(\"return\", res());\n\n              case 42:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, null, [[23, 35, 38, 41]]);\n      }));\n\n      return function (_x7, _x8) {\n        return _ref5.apply(this, arguments);\n      };\n    }(), this._selfInstance());\n  },\n\n  /**\n   * Returns a new stream that will append the passed streams to the callee\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param  {Readable[]} ...streams Streams to be injected into the current stream\n   *\n   * @test test/methods/data-stream-concat.js\n   */\n  concat: function concat() {\n    for (var _len7 = arguments.length, streams = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      streams[_key7] = arguments[_key7];\n    }\n\n    var out = this._selfInstance({\n      referrer: this\n    });\n\n    streams.unshift(this);\n\n    var next = function next() {\n      if (streams.length) streams.shift().on(\"end\", next).pipe(out, {\n        end: !streams.length\n      });\n    };\n\n    next();\n    return out;\n  },\n\n  /**\n   * @callback JoinCallback\n   * @memberof module:scramjet~\n   * @param {*} previous the chunk before\n   * @param {*} next the chunk after\n   * @returns {Promise<*>|*}  promise that is resolved with the joining item\n   */\n\n  /**\n   * Method will put the passed object between items. It can also be a function call or generator / iterator.\n   *\n   * If a generator or iterator is passed, when the iteration is done no items will be interweaved.\n   * Generator receives\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param  {*|AsyncGeneratorFunction|GeneratorFunction|JoinCallback} item An object that should be interweaved between stream items\n   * @param {any[]} ...args additional args will be passed to generators\n   *\n   * @test test/methods/data-stream-join.js\n   */\n  join: function join(item) {\n    for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n      args[_key8 - 1] = arguments[_key8];\n    }\n\n    var ref = this._selfInstance({\n      referrer: this\n    });\n\n    var prev;\n    var consumer;\n\n    if (typeof item !== \"function\") {\n      consumer = function consumer(cur) {\n        return Promise.all([ref.whenWrote(item), ref.whenWrote(cur)]);\n      };\n    } else if (item instanceof GeneratorFunction || item instanceof AsyncGeneratorFunction) {\n      var iterator = item.apply(void 0, args);\n\n      consumer = function consumer(cur) {\n        return Promise.resolve().then(function () {\n          return iterator.next(prev);\n        }).then(function (_ref6) {\n          var value = _ref6.value,\n              done = _ref6.done;\n          return Promise.all([!done && ref.whenWrote(value), ref.whenWrote(prev = cur)]);\n        });\n      };\n    } else {\n      consumer = function consumer(cur) {\n        return Promise.resolve([prev, prev = cur]).then(function (_ref7) {\n          var _ref8 = _slicedToArray(_ref7, 2),\n              prev = _ref8[0],\n              cur = _ref8[1];\n\n          return item.apply(void 0, [prev, cur].concat(args));\n        }).then(function (joint) {\n          return Promise.all([joint && ref.whenWrote(joint), ref.whenWrote(cur)]);\n        });\n      };\n    }\n\n    this.shift(1, function (_ref9) {\n      var _ref10 = _slicedToArray(_ref9, 1),\n          first = _ref10[0];\n\n      return ref.push(prev = first);\n    }).consume(consumer).then(function () {\n      return ref.end();\n    });\n    return ref;\n  },\n\n  /**\n   * Keep a buffer of n-chunks for use with {@see DataStream..rewind}\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param {number} [count=Infinity] Number of objects or -1 for all the stream\n   *\n   * @test test/methods/data-stream-keep.js\n   */\n  keep: function keep() {\n    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    if (count < 0) count = Infinity;\n    this.pipe(this.buffer = new ReReadable({\n      length: count,\n      objectMode: true\n    }));\n    return this.tap();\n  },\n\n  /**\n   * Rewinds the buffered chunks the specified length backwards. Requires a prior call to {@see DataStream..keep}\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param {number} [count=Infinity] Number of objects or -1 for all the buffer\n   */\n  rewind: function rewind() {\n    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    if (count < 0) count = Infinity;\n\n    if (this.buffer) {\n      return this.buffer.tail(count).pipe(this._selfInstance());\n    } else {\n      throw new Error(\"Stream not buffered, cannot rewind.\");\n    }\n  },\n\n  /**\n   * Returns a stream that stacks up incoming items always feeding out the newest items first.\n   * It returns the older items when read\n   *\n   * When the stack length exceeds the given `count` the given `drop` function is awaited\n   * and used for flow control.\n   *\n   * By default the drop function ignores and quietly disposes of items not read before overflow.\n   *\n   * @chainable\n   * @param {number} [count=1000]\n   * @param {function} [drop]\n   * @memberof module:scramjet.DataStream#\n   *\n   * @test test/methods/data-stream-stack.js\n   */\n  stack: function stack() {\n    var _this8 = this;\n\n    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;\n    var drop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n      return 0;\n    };\n    if (count < 0) count = Infinity;\n    return this.tap().use(function (source) {\n      var stack = [];\n      var waiting = [];\n      var end = false;\n      var target = new _this8.constructor({\n        referrer: _this8,\n        promiseRead: function promiseRead() {\n          if (end) {\n            if (stack.length) {\n              var out = stack.slice().reverse();\n              stack.length = 0;\n              return out;\n            } else {\n              return [];\n            }\n          }\n\n          if (stack.length) {\n            return [stack.pop()];\n          }\n\n          return new Promise(function (res) {\n            waiting.push(res);\n          });\n        }\n      });\n      source.each(function (item) {\n        if (waiting.length === 0) {\n          stack.push(item);\n\n          if (stack.length > count) {\n            return drop(stack.shift());\n          }\n        } else {\n          waiting.shift()([item]);\n        }\n      }).catch(function (e) {\n        return target.raise(e);\n      }).whenEnd().then(function () {\n        end = true;\n\n        if (waiting.length) {\n          console.log(waiting[0]);\n          waiting.shift()([]);\n        }\n      });\n      return target;\n    });\n  },\n\n  /**\n   * Distributes processing into multiple sub-processes or threads if you like.\n   *\n   * @todo Currently order is not kept.\n   * @todo Example test breaks travis-ci build\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param {AffinityCallback|Function|number} [affinity] A Function that affixes the item to specific output stream which must exist in the object for each chunk, must return a string. A number may be passed to identify how many round-robin threads to start up. Defaults to Round Robin to twice the number of CPU threads.\n   * @param {Function|DataStreamOptions} [clusterFunc] stream transforms similar to {@see DataStream#use method}\n   * @param {DataStreamOptions} [options] Options\n   *\n   * @test test/methods/data-stream-distribute.js\n   */\n  distribute: function distribute(affinity) {\n    var clusterFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    var _ref11 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref11$plugins = _ref11.plugins,\n        plugins = _ref11$plugins === void 0 ? [] : _ref11$plugins,\n        _ref11$options = _ref11.options,\n        options = _ref11$options === void 0 ? {} : _ref11$options;\n\n    if (!clusterFunc && affinity) {\n      clusterFunc = affinity;\n      affinity = os.cpus().length * 2;\n    }\n\n    if (typeof affinity === \"number\") {\n      var roundRobinLength = affinity;\n      var z = 0;\n      options.threads = affinity;\n\n      affinity = function affinity() {\n        return z = ++z % roundRobinLength;\n      };\n    }\n\n    if (!Array.isArray(clusterFunc)) clusterFunc = [clusterFunc];\n    var streams = this.separate(affinity, options.createOptions, this.constructor).cluster(clusterFunc, {\n      plugins: plugins,\n      threads: options.threads,\n      StreamClass: this.constructor\n    });\n    return streams.mux();\n  },\n\n  /**\n   * Separates stream into a hash of streams. Does not create new streams!\n   *\n   * @chainable\n   * @meta.noreadme\n   * @memberof module:scramjet.DataStream#\n   * @param {object} streams the object hash of streams. Keys must be the outputs of the affinity function\n   * @param {AffinityCallback} affinity the Function that affixes the item to specific streams which must exist in the object for each chunk.\n   */\n  separateInto: function separateInto(streams, affinity) {\n    this.consume( /*#__PURE__*/function () {\n      var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(chunk) {\n        var streamId, found;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return affinity(chunk);\n\n              case 2:\n                streamId = _context9.sent;\n                found = streams[streamId];\n\n                if (!found) {\n                  _context9.next = 6;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", found.whenWrote(chunk));\n\n              case 6:\n                throw new Error(\"Output for \" + streamId + \" not found in \" + JSON.stringify(chunk));\n\n              case 7:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n\n      return function (_x9) {\n        return _ref12.apply(this, arguments);\n      };\n    }());\n    return this;\n  },\n\n  /**\n   * @callback AffinityCallback\n   * @memberof module:scramjet~\n   * @param {*} chunk\n   * @returns {Symbol|string}\n   */\n\n  /**\n   * Separates execution to multiple streams using the hashes returned by the passed Function.\n   *\n   * Calls the given Function for a hash, then makes sure all items with the same hash are processed within a single\n   * stream. Thanks to that streams can be distributed to multiple threads.\n   *\n   * @meta.noreadme\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param {AffinityCallback} affinity the affinity function\n   * @param {DataStreamOptions} [createOptions] options to use to create the separated streams\n   * @param {function(new:DataStream)} [ClassType=this.constructor] options to use to create the separated streams\n   * @return {MultiStream} separated stream\n   *\n   * @test test/methods/data-stream-separate.js\n   */\n  separate: function separate(affinity) {\n    var createOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var ClassType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.constructor;\n    var ret = new MultiStream();\n    var hashes = new Map();\n    ClassType = ClassType || this.constructor;\n\n    var pushChunk = /*#__PURE__*/function () {\n      var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(hash, chunk) {\n        var _hash, rightStream;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _hash = hash.toString();\n\n                if (!hashes.has(_hash)) {\n                  rightStream = new ClassType(createOptions);\n                  rightStream._separateId = _hash;\n                  hashes.set(_hash, rightStream);\n                  ret.add(rightStream);\n                } else {\n                  rightStream = hashes.get(_hash);\n                }\n\n                return _context10.abrupt(\"return\", rightStream.whenWrote(chunk));\n\n              case 3:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10);\n      }));\n\n      return function pushChunk(_x10, _x11) {\n        return _ref13.apply(this, arguments);\n      };\n    }();\n\n    this.pipe(new this.constructor({\n      promiseTransform: function promiseTransform(chunk) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n          var hash;\n          return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n            while (1) {\n              switch (_context11.prev = _context11.next) {\n                case 0:\n                  _context11.prev = 0;\n                  _context11.next = 3;\n                  return affinity(chunk);\n\n                case 3:\n                  hash = _context11.sent;\n\n                  if (!Array.isArray(hash)) {\n                    _context11.next = 8;\n                    break;\n                  }\n\n                  return _context11.abrupt(\"return\", Promise.all(hash.map(function (str) {\n                    return pushChunk(str, chunk);\n                  })));\n\n                case 8:\n                  return _context11.abrupt(\"return\", pushChunk(hash, chunk));\n\n                case 9:\n                  _context11.next = 14;\n                  break;\n\n                case 11:\n                  _context11.prev = 11;\n                  _context11.t0 = _context11[\"catch\"](0);\n                  ret.emit(\"error\", _context11.t0);\n\n                case 14:\n                case \"end\":\n                  return _context11.stop();\n              }\n            }\n          }, _callee11, null, [[0, 11]]);\n        }))();\n      },\n      referrer: this\n    }).on(\"end\", function () {\n      ret.streams.forEach(function (stream) {\n        return stream.end();\n      });\n    }).resume());\n    return ret;\n  },\n\n  /**\n   * @memberof module:scramjet~\n   * @typedef {Function} DelegateCallback\n   */\n\n  /**\n   * Delegates work to a specified worker.\n   *\n   * @meta.noreadme\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param  {DelegateCallback} delegateFunc A function to be run in the sub-thread.\n   * @param  {StreamWorker}     worker\n   * @param  {Array}            [plugins=[]]\n   */\n  delegate: function delegate(delegateFunc, worker) {\n    var plugins = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    var ret = this._selfInstance({\n      referrer: this\n    });\n\n    return worker.delegate(this, delegateFunc, plugins).pipe(ret);\n  },\n\n  /**\n   * Limit the rate of the stream to a given number of chunks per second or given timeframe.\n   *\n   * @meta.noreadme\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param  {number}      cps Chunks per timeframe, the default timeframe is 1000 ms.\n   * @param  {RateOptions} [options={}] Options for the limiter controlling the timeframe and time source. Both must work on same units.\n   */\n  rate: function rate(cps) {\n    var _ref14 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref14$windowSize = _ref14.windowSize,\n        windowSize = _ref14$windowSize === void 0 ? 1000 : _ref14$windowSize,\n        _ref14$getTime = _ref14.getTime,\n        getTime = _ref14$getTime === void 0 ? Date.now : _ref14$getTime,\n        _ref14$setTimeout = _ref14.setTimeout,\n        setTimeout = _ref14$setTimeout === void 0 ? global.setTimeout : _ref14$setTimeout;\n\n    var refs = [];\n\n    var defer = function defer(time) {\n      return new Promise(function (res) {\n        return setTimeout(res, time);\n      });\n    };\n\n    return this.do(function () {\n      var time = getTime();\n      refs.push(time);\n      if (refs.length <= cps) return; // DRY fail on purpose here - we don't need to slice the lemon twice.\n\n      refs.splice(0, refs.find(function (x) {\n        return x < time - windowSize;\n      }));\n      if (refs.length <= cps) return;\n      return defer(time - refs.shift() + windowSize);\n    });\n  },\n\n  /**\n   * @typedef {object} RateOptions\n   * @memberof module:scramjet~\n   * @param  {number}   [timeFrame=1000] The size of the window to look for streams.\n   * @param  {Function} [getTime=Date.now] Time source - anything that returns time.\n   * @param  {Function} [setTimeout=setTimeout] Timing function that works identically to setTimeout.\n   */\n\n  /**\n   * Aggregates chunks in arrays given number of number of items long.\n   *\n   * This can be used for micro-batch processing.\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param  {number} count How many items to aggregate\n   *\n   * @test test/methods/data-stream-batch.js\n   */\n  batch: function batch(count) {\n    var arr = [];\n    var ret = this.tap().pipe(new this.constructor({\n      promiseTransform: function promiseTransform(chunk) {\n        arr.push(chunk);\n\n        if (arr.length >= count) {\n          var push = arr;\n          arr = [];\n          return push;\n        }\n\n        return Promise.reject(DataStream.filter);\n      },\n      promiseFlush: function promiseFlush() {\n        if (arr.length > 0) {\n          return [arr];\n        } else return [];\n      },\n      referrer: this\n    }));\n    return ret;\n  },\n\n  /**\n   * Aggregates chunks to arrays not delaying output by more than the given number of ms.\n   *\n   * @meta.noreadme\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param  {number} ms    Maximum amount of milliseconds\n   * @param  {number} [count] Maximum number of items in batch (otherwise no limit)\n   *\n   * @test test/methods/data-stream-timebatch.js\n   */\n  timeBatch: function timeBatch(ms) {\n    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n    var arr = [];\n    var setTimeout = this.setTimeout;\n    var clearTimeout = this.clearTimeout;\n\n    var ret = this._selfInstance({\n      referrer: this\n    });\n\n    var pushTimeout = null;\n\n    var push = function push() {\n      if (pushTimeout) {\n        clearTimeout(pushTimeout);\n        pushTimeout = null;\n      }\n\n      var last = ret.whenWrote(arr);\n      arr = [];\n      return last;\n    };\n\n    this.consume( /*#__PURE__*/function () {\n      var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(chunk) {\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                arr.push(chunk);\n\n                if (!(arr.length >= count)) {\n                  _context12.next = 6;\n                  break;\n                }\n\n                _context12.next = 4;\n                return push();\n\n              case 4:\n                _context12.next = 7;\n                break;\n\n              case 6:\n                if (!pushTimeout) {\n                  pushTimeout = setTimeout(push, ms);\n                }\n\n              case 7:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12);\n      }));\n\n      return function (_x12) {\n        return _ref15.apply(this, arguments);\n      };\n    }()).then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n      return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              if (!arr.length) {\n                _context13.next = 4;\n                break;\n              }\n\n              clearTimeout(pushTimeout);\n              _context13.next = 4;\n              return ret.whenWrote(arr);\n\n            case 4:\n              ret.end();\n\n            case 5:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n      }, _callee13);\n    })));\n    return ret;\n  },\n\n  /**\n   * Performs the Nagle's algorithm on the data. In essence it waits until we receive some more data and releases them\n   * in bulk.\n   *\n   * @memberof module:scramjet.DataStream#\n   * @todo needs more work, for now it's simply waiting some time, not checking the queues.\n   * @param  {number} [size=32] maximum number of items to wait for\n   * @param  {number} [ms=10]   milliseconds to wait for more data\n   * @chainable\n   * @meta.noreadme\n   */\n  nagle: function nagle() {\n    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n    var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    return this.timeBatch(size, ms).flatten();\n  },\n\n  /**\n   * Returns a WindowStream of the specified length\n   *\n   * @memberof module:scramjet.DataStream#\n   * @chainable\n   * @param {number} length\n   * @returns {WindowStream} a stream of array's\n   * @meta.noreadme\n   */\n  window: function window(length) {\n    if (!(+length > 0)) throw new Error(\"Length argument must be a positive integer!\");\n    var arr = [];\n    return this.into(function (out, chunk) {\n      arr.push(chunk);\n      if (arr.length > length) arr.shift();\n      return out.whenWrote(arr.slice());\n    }, new scramjet.WindowStream());\n  },\n\n  /**\n   * Transforms the stream to a streamed JSON array.\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param  {Iterable<any>} [enclosure='[]'] Any iterable object of two items (beginning and end)\n   * @return {StringStream}\n   * @meta.noreadme\n   *\n   * @test test/methods/data-stream-tojsonarray.js\n   */\n  toJSONArray: function toJSONArray() {\n    var enclosure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [\"[\\n\", \"\\n]\"];\n    var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \",\\n\";\n    var stringify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : JSON.stringify;\n    var ref = new StringStream({\n      referrer: this\n    });\n    this.shift(1, function (_ref17) {\n      var _ref18 = _slicedToArray(_ref17, 1),\n          first = _ref18[0];\n\n      ref.push(enclosure[0]);\n      if (first) return ref.whenWrote(stringify(first));\n    }).each(function (chunk) {\n      return Promise.all([ref.whenWrote(separator), ref.whenWrote(stringify(chunk))]);\n    }).run().then(function () {\n      return ref.end(enclosure[1]);\n    });\n    return ref;\n  },\n\n  /**\n   * Transforms the stream to a streamed JSON object.\n   *\n   * @meta.noreadme\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param  {MapCallback} [entryCallback] async function returning an entry (array of [key, value])\n   * @param  {Iterable<any>} [enclosure='{}'] Any iterable object of two items (beginning and end)\n   * @return {StringStream}\n   * @meta.noreadme\n   *\n   * @test test/methods/data-stream-tojsonobject.js\n   */\n  toJSONObject: function toJSONObject(entryCallback) {\n    var enclosure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [\"{\\n\", \"\\n}\"];\n    var separator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \",\\n\";\n    var ref = this;\n    return ref.map(function (item) {\n      return [entryCallback(item), item];\n    }).toJSONArray(enclosure, separator, function (_ref19) {\n      var _ref20 = _slicedToArray(_ref19, 2),\n          key = _ref20[0],\n          value = _ref20[1];\n\n      return JSON.stringify(key.toString()) + \":\" + JSON.stringify(value);\n    });\n  },\n\n  /**\n   * Returns a StringStream containing JSON per item with optional end line\n   *\n   * @meta.noreadme\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param  {Boolean|string} [endline=os.EOL] whether to add endlines (boolean or string as delimiter)\n   * @return {StringStream}  output stream\n   * \n   * @test test/methods/data-stream-jsonstringify.js\n   */\n  JSONStringify: function JSONStringify() {\n    var eol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : os.EOL;\n    if (!eol) eol = \"\";\n    return this.stringify(function (item) {\n      return JSON.stringify(item) + eol;\n    });\n  },\n\n  /**\n   * Stringifies CSV to DataString using 'papaparse' module.\n   *\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param {object} [options={}] options for the papaparse.unparse module.\n   * @return {StringStream}  stream of parsed items\n   *\n   * @test test/methods/data-stream-csv.js\n   */\n  CSVStringify: function CSVStringify() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var Papa = require(\"papaparse\");\n\n    var header = null;\n    var start = 1;\n    options = Object.assign({\n      header: true,\n      newline: os.EOL\n    }, options);\n    var outOptions = Object.assign({}, options, {\n      header: false\n    });\n    return this.timeBatch(16, 64).map(function (arr) {\n      var out = [];\n\n      if (!header) {\n        header = Object.keys(arr[0]);\n        if (options.header) out.push(header);\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(arr),\n          _step2;\n\n      try {\n        var _loop = function _loop() {\n          var item = _step2.value;\n          out.push(header.map(function (key) {\n            return item[key];\n          }));\n        };\n\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var x = Papa.unparse(out, outOptions) + options.newline;\n\n      if (start) {\n        start = 0;\n        return x;\n      }\n\n      return x;\n    }).pipe(new StringStream());\n  },\n\n  /**\n   * @typedef {object} ExecDataOptions\n   * @memberof module:scramjet~\n   * @property {UseCallback} [parse] scramjet module to transform the stream to string or buffer stream\n   * @property {UseCallback} [stringify] scramjet module to transform from string or buffer stream to wanted version\n   * @extends StringStream.ExecOptions\n   */\n\n  /**\n   * Executes a given sub-process with arguments and pipes the current stream into it while returning the output as another DataStream.\n   *\n   * Pipes the current stream into the sub-processes stdin.\n   * The data is serialized and deserialized as JSON lines by default. You\n   * can provide your own alternative methods in the ExecOptions object.\n   *\n   * Note: if you're piping both stderr and stdout (options.stream=3) keep in mind that chunks may get mixed up!\n   *\n   * @param {string} command command to execute\n   * @memberof module:scramjet.DataStream#\n   * @param {ExecDataOptions|any} [options={}] options to be passed to `spawn` and defining serialization.\n   * @param {string[]} ...args additional args will be passed to function\n   *\n   * @test test/methods/data-stream-exec.js\n   */\n  exec: function exec(command) {\n    var _this$use;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var resolvedCmd = path.resolve(getCalleeDirname(1), command);\n\n    var stringify = options.stringify || function (stream) {\n      return stream.JSONStringify();\n    };\n\n    var parse = options.parse || function (stream) {\n      return stream.JSONParse();\n    };\n\n    for (var _len9 = arguments.length, args = new Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {\n      args[_key9 - 2] = arguments[_key9];\n    }\n\n    return (_this$use = this.use(stringify)).exec.apply(_this$use, [resolvedCmd, options].concat(args)).use(parse);\n  },\n\n  /**\n   * Injects a ```debugger``` statement when called.\n   *\n   * @meta.noreadme\n   * @chainable\n   * @memberof module:scramjet.DataStream#\n   * @param  {Function} func if passed, the function will be called on self to add an option to inspect the stream in place, while not breaking the transform chain\n   * @return {DataStream}  self\n   *\n   * @test test/methods/data-stream-debug.js\n   */\n  debug: function debug(func) {\n    debugger; // eslint-disable-line\n\n    this.use(func);\n    return this;\n  }\n};\nmodule.exports.pop = module.exports.shift;\nmodule.exports.group = module.exports.separate;","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/client/node_modules/scramjet/lib/data-stream.js"],"names":["scramjet","require","PromiseTransformStream","StringStream","DataStream","MultiStream","EventEmitter","ReReadable","AsyncGeneratorFunction","GeneratorFunction","os","path","getCalleeDirname","module","exports","constructor","TimeSource","Date","setTimeout","clearTimeout","buffer","pull","pullable","args","Promise","res","rej","incoming","from","pipe","end","on","shift","count","func","ret","str","tap","_selfInstance","referrer","chunkHandler","chunk","push","length","pause","unHook","then","resume","endHandler","errorHandler","emit","bind","hooked","removeListener","resolve","peek","ref","batch","unpipe","slice","start","Infinity","n","stream","until","assign","map","obj","Object","empty","callback","z","promiseTransform","dropTransform","pushTransform","whenEnd","unshift","items","forEach","item","write","endWith","a","flushPromise","accumulate","into","bound","reject","filter","to","consume","runFunc","gen","next","do","reduceNow","prm","reduce","catch","e","remap","ClassType","out","newChunk","last","val","whenDrained","flatMap","asyncIteratorSymbol","Symbol","asyncIterator","Error","iterator","done","value","chunks","whenWrote","flatten","iteratorSymbol","wroteAll","prevWrote","_res","concat","streams","join","prev","consumer","cur","all","joint","first","keep","objectMode","rewind","tail","stack","drop","use","source","waiting","target","promiseRead","reverse","pop","each","raise","console","log","distribute","affinity","clusterFunc","plugins","options","cpus","roundRobinLength","threads","Array","isArray","separate","createOptions","cluster","StreamClass","mux","separateInto","streamId","found","JSON","stringify","hashes","Map","pushChunk","hash","_hash","toString","has","rightStream","_separateId","set","add","get","delegate","delegateFunc","worker","rate","cps","windowSize","getTime","now","global","refs","defer","time","splice","find","x","arr","promiseFlush","timeBatch","ms","pushTimeout","nagle","size","window","WindowStream","toJSONArray","enclosure","separator","run","toJSONObject","entryCallback","key","JSONStringify","eol","EOL","CSVStringify","Papa","header","newline","outOptions","keys","unparse","exec","command","resolvedCmd","parse","JSONParse","debug","group"],"mappings":"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","sourcesContent":["const scramjet = require(\"./\");\nconst { PromiseTransformStream, StringStream, DataStream, MultiStream } = scramjet;\nconst { EventEmitter } = require(\"events\");\nconst { ReReadable } = require(\"rereadable-stream\");\nconst { AsyncGeneratorFunction, GeneratorFunction } = require(\"scramjet-core/lib/util/utils\");\n\nconst os = require(\"os\");\nconst path = require(\"path\");\n\n/** @ignore */\nconst {getCalleeDirname} = require(\"scramjet-core/lib/util/utils\");\n\nmodule.exports = {\n\n    constructor() {\n        this.TimeSource = Date;\n        this.setTimeout = setTimeout;\n        this.clearTimeout = clearTimeout;\n\n        this.buffer = null;\n    },\n\n    /**\n     * Pulls in any readable stream, resolves when the pulled stream ends.\n     *\n     * You can also pass anything that can be passed to `DataStream.from`.\n     *\n     * Does not preserve order, does not end this stream.\n     *\n     * @async\n     * @memberof module:scramjet.DataStream#\n     * @param {Array|Iterable<any>|AsyncGeneratorFunction|GeneratorFunction|AsyncFunction|Function|string|Readable} pullable\n     * @param {any[]} ...args any additional args\n     * @returns {Promise<any>} resolved when incoming stream ends, rejects on incoming error\n     *\n     * @test test/methods/data-stream-pull.js\n     */\n    async pull(pullable, ...args) {\n        return new Promise((res, rej) => {\n            const incoming = this.constructor.from(pullable, {}, ...args);\n\n            incoming.pipe(this, { end: false });\n            incoming.on(\"end\", res);\n            incoming.on(\"error\", rej);\n        });\n    },\n\n    /**\n     * Shift Function\n     *\n     * @callback ShiftCallback\n     * @memberof module:scramjet~\n     * @param {Array<object>|any} shifted an array of shifted chunks\n     */\n\n    /**\n     * Shifts the first n items from the stream and pushes out the remaining ones.\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param {number} count The number of items to shift.\n     * @param {ShiftCallback} func Function that receives an array of shifted items\n     *\n     * @test test/methods/data-stream-shift.js\n     */\n    shift(count, func) {\n        const ret = [];\n        const str = this.tap()._selfInstance({referrer: this});\n\n        const chunkHandler = (chunk) => {\n            ret.push(chunk);\n            if (ret.length >= count) {\n                this.pause();\n                unHook().then(\n                    () => this.resume().pipe(str)\n                );\n            }\n        };\n\n        const endHandler = (...args) => {\n            unHook().then(\n                () => str.end(...args)\n            );\n        };\n\n        const errorHandler = str.emit.bind(str, \"error\");\n\n        let hooked = true;\n        const unHook = () => {\n            if (hooked) {\n                hooked = false;\n                this.removeListener(\"data\", chunkHandler);\n                this.removeListener(\"end\", endHandler);\n                this.removeListener(\"error\", errorHandler);\n            }\n            return Promise.resolve(ret)\n                .then(func);\n        };\n\n        this.on(\"data\", chunkHandler);\n        this.on(\"end\", endHandler);\n        this.on(\"error\", errorHandler);\n\n        return str;\n    },\n\n    /**\n     * Allows previewing some of the streams data without removing them from the stream.\n     *\n     * Important: Peek does not resume the flow.\n     *\n     * @memberof module:scramjet.DataStream#\n     * @param  {number} count The number of items to view before\n     * @param  {ShiftCallback} func Function called before other streams\n     * @chainable\n     */\n    peek(count, func) {\n        const ref = this._selfInstance({referrer: this});\n\n        this\n            .tap()\n            .pipe(ref)\n            .shift(count, batch => {\n                this.unpipe(ref);\n                return func(batch);\n            });\n\n        return this;\n    },\n\n    /**\n     * Slices out a part of the stream to the passed Function.\n     *\n     * Returns a stream consisting of an array of items with `0` to `start`\n     * omitted and `length` items after `start` included. Works similarly to\n     * Array.prototype.slice.\n     *\n     * Takes count from the moment it's called. Any previous items will not be\n     * taken into account.\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param {number} [start=0] omit this number of entries.\n     * @param {number} [length=Infinity] get this number of entries to the resulting stream\n     *\n     * @test test/methods/data-stream-slice.js\n     */\n    slice(start = 0, length = Infinity) {\n        let n = 0;\n\n        let stream = this;\n        if (start > 0) {\n            stream = this.shift(start, () => 0);\n        }\n\n        if (length === Infinity) {\n            return this;\n        }\n\n        return stream.until(() => n++ >= length);\n    },\n\n    /**\n     * Transforms stream objects by assigning the properties from the returned\n     * data along with data from original ones.\n     *\n     * The original objects are unaltered.\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param {MapCallback|object} func The function that returns new object properties or just the new properties\n     *\n     * @test test/methods/data-stream-assign.js\n     */\n    assign(func) {\n        if (typeof func === \"function\") {\n            return this.map(\n                (chunk) => Promise.resolve(func(chunk))\n                    .then(obj => Object.assign({}, chunk, obj))\n            );\n        } else {\n            return this.map(\n                (chunk) => Object.assign({}, chunk, func)\n            );\n        }\n    },\n\n    /**\n     * Called only before the stream ends without passing any items\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param {Function} callback Function called when stream ends\n     *\n     * @test test/methods/data-stream-empty.js\n     */\n    empty(callback) {\n        let z = false;\n        const promiseTransform = () => {\n            z = true;\n            this.dropTransform(promiseTransform);\n        };\n\n        this.pushTransform({promiseTransform})\n            .tap()\n            .whenEnd()\n            .then(\n                () => (z || Promise.resolve().then(callback)),\n                () => 0\n            );\n\n        return this;\n    },\n\n\n    /**\n     * Pushes any data at call time (essentially at the beginning of the stream)\n     *\n     * This is a synchronous only function.\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param {any[]} ...item list of items to unshift (you can pass more items)\n     */\n    unshift(...items) {\n        items.forEach(\n            item => this.write(item)\n        );\n        return this.tap();\n    },\n\n    /**\n     * Pushes any data at end of stream\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param {*} item list of items to push at end\n     * @meta.noreadme\n     *\n     * @test test/methods/data-stream-endwith.js\n     */\n    endWith(...items) {\n        // TODO: overhead on unneeded transform, but requires changes in core.\n        // TODO: should accept similar args as `from`\n        return this.pipe(this._selfInstance({\n            referrer: this,\n            promiseTransform: (a) => a,\n            flushPromise: () => items\n        }));\n    },\n\n    /**\n     * Accumulates data into the object.\n     *\n     * Works very similarly to reduce, but result of previous operations have\n     * no influence over the accumulator in the next one.\n     *\n     * Method works in parallel.\n     *\n     * @async\n     * @memberof module:scramjet.DataStream#\n     * @param  {AccumulateCallback} func The accumulation function\n     * @param  {*} into Accumulator object\n     * @return {Promise<any>}  resolved with the \"into\" object on stream end.\n     * @meta.noreadme\n     *\n     * @test test/methods/data-stream-accumulate.js\n     */\n    async accumulate(func, into) {\n        return new Promise((res, rej) => {\n            const bound = async (chunk) => (await func(into, chunk), Promise.reject(DataStream.filter));\n            bound.to = func;\n\n            this.tap().pipe(new PromiseTransformStream({\n                promiseTransform: bound,\n                referrer: this\n            }))\n                .on(\"end\", () => res(into))\n                .on(\"error\", rej)\n                .resume();\n        });\n    },\n\n    /**\n     * @callback AccumulateCallback\n     * @memberof module:scramjet~\n     * @param {*} accumulator Accumulator passed to accumulate function\n     * @param {*} chunk the stream chunk\n     * @return {Promise<any>|*} resolved when all operations are completed\n     */\n\n    /**\n     * Consumes the stream by running each Function\n     *\n     * @deprecated use {@link DataStream#each} instead\n     *\n     * @async\n     * @memberof module:scramjet.DataStream#\n     * @param {ConsumeCallback|AsyncGeneratorFunction|GeneratorFunction} func the consument\n     * @param {any[]} ...args additional args will be passed to generators\n     * @meta.noreadme\n     */\n    async consume(func, ...args) {\n        let runFunc = func;\n        if (func instanceof GeneratorFunction || func instanceof AsyncGeneratorFunction) {\n            const gen = await func(...args);\n            await gen.next();\n            runFunc = async item => {\n                await gen.next(item);\n            };\n        }\n\n        return this.tap()\n            .do(runFunc)\n            .resume()\n            .whenEnd();\n    },\n\n    /**\n     * @callback ConsumeCallback\n     * @memberof module:scramjet~\n     * @param {*} chunk the stream chunk\n     * @return {Promise<any>|*} resolved when all operations are completed\n     */\n\n    /**\n     * Reduces the stream into the given object, returning it immediately.\n     *\n     * The main difference to reduce is that only the first object will be\n     * returned at once (however the method will be called with the previous\n     * entry).\n     * If the object is an instance of EventEmitter then it will propagate the\n     * error from the previous stream.\n     *\n     * This method is serial - meaning that any processing on an entry will\n     * occur only after the previous entry is fully processed. This does mean\n     * it's much slower than parallel functions.\n     *\n     * @meta.noreadme\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param  {ReduceCallback} func The into object will be passed as the first argument, the data object from the stream as the second.\n     * @param  {*|EventEmitter} into Any object passed initially to the transform  function\n     * @return {*} whatever was passed as into\n     *\n     * @test test/methods/data-stream-reduceNow.js\n     */\n    reduceNow(func, into) {\n        const prm = this.reduce(func, into);\n\n        if (into instanceof EventEmitter) {\n            prm.catch((e) => into.emit(\"error\", e));\n        }\n\n        return into;\n    },\n\n    /**\n     * @callback RemapCallback\n     * @memberof module:scramjet~\n     * @param {Function} emit a method to emit objects in the remapped stream\n     * @param {*} chunk the chunk from the original stream\n     * @returns {Promise<any>|*} promise to be resolved when chunk has been processed\n     */\n\n    /**\n     * Remaps the stream into a new stream.\n     *\n     * This means that every item may emit as many other items as we like.\n     *\n     * @meta.noreadme\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param  {RemapCallback} func A Function that is called on every chunk\n     * @param  {function(new:DataStream)} [ClassType=this.constructor] Optional DataStream subclass to be constructed\n     *\n     * @test test/methods/data-stream-remap.js\n     */\n    remap(func, ClassType = this.constructor) {\n\n        const ref = new (ClassType || this.constructor)({referrer: this});\n\n        return this.into(\n            async (str, chunk) => {\n                let out = [];\n                await func((newChunk) => out.push(newChunk), chunk);\n\n                let last = true;\n                for (const val of out)\n                    last = ref.write(val);\n\n                return last ? null : ref.whenDrained();\n            },\n            ref\n        );\n    },\n\n    /**\n     * Takes any method that returns any iterable and flattens the result.\n     *\n     * The passed Function must return an iterable (otherwise an error will be emitted). The resulting stream will\n     * consist of all the items of the returned iterables, one iterable after another.\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param {FlatMapCallback} func A Function that is called on every chunk\n     * @param {function(new:DataStream)} [ClassType=this.constructor] Optional DataStream subclass to be constructed\n     * @param {any[]} ...args additional args will be passed to generators\n     *\n     * @test test/methods/data-stream-flatmap.js\n     */\n    flatMap(func, ClassType, ...args) {\n        if (typeof ClassType !== \"function\")\n            ClassType = this.constructor;\n\n        const ref = new ClassType({referrer: this});\n        const asyncIteratorSymbol = Symbol.asyncIterator;\n\n        return this.into(\n            async (ref, chunk) => {\n                const out = await func(chunk, ...args);\n                if (!out) {\n                    throw new Error(\"Non iterable object returned for flatMap!\");\n                }\n\n                if (asyncIteratorSymbol && out[asyncIteratorSymbol]) {\n                    const iterator = out[asyncIteratorSymbol]();\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                        const item = await iterator.next();\n                        if (item.done) return;\n                        if (!ref.write(item.value)) await ref.whenDrained();\n                    }\n                } else {\n                    const chunks = [...out];\n                    if (chunks.length === 0) return;\n                    await ref.whenWrote(...chunks);\n                }\n            },\n            ref\n        );\n    },\n\n    /**\n     * @callback FlatMapCallback\n     * @memberof module:scramjet~\n     * @param {*} chunk the chunk from the original stream\n     * @returns {AsyncGenerator<any, void, any>|Promise<Iterable<any>>|Iterable<any>}  promise to be resolved when chunk has been processed\n     */\n\n    /**\n     * A shorthand for streams of arrays or iterables to flatten them.\n     *\n     * More efficient equivalent of: `.flatmap(i => i);`\n     * Works on streams of async iterables too.\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @return {DataStream}\n     *\n     * @test test/methods/data-stream-flatten.js\n     */\n    flatten() {\n        const iteratorSymbol = Symbol.asyncIterator;\n        let wroteAll = Promise.resolve();\n\n        return this.into(\n            async (ref, chunk) => {\n                const prevWrote = wroteAll;\n                let res;\n                wroteAll = new Promise(_res => res = _res);\n\n                if (iteratorSymbol && chunk[iteratorSymbol]) {\n                    const iterator = chunk[iteratorSymbol]();\n                    await prevWrote;\n                    // eslint-disable-next-line no-constant-condition\n                    while (true) {\n                        const item = await iterator.next();\n                        \n                        if (item.value && !ref.write(item.value)) await ref.whenDrained();\n                        if (item.done) return res();\n                    }\n                } else {\n                    let last = true;\n                    await prevWrote;\n                    for (const val of chunk) {\n                        last = ref.write(val);\n                        if (!last) await ref.whenDrained();\n                    }\n                    return res();\n                }\n            },\n            this._selfInstance()\n        );\n    },\n\n    /**\n     * Returns a new stream that will append the passed streams to the callee\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param  {Readable[]} ...streams Streams to be injected into the current stream\n     *\n     * @test test/methods/data-stream-concat.js\n     */\n    concat(...streams) {\n        const out = this._selfInstance({referrer: this});\n\n        streams.unshift(this);\n\n        const next = () => {\n            if (streams.length)\n                streams.shift()\n                    .on(\"end\", next)\n                    .pipe(out, {end: !streams.length});\n        };\n        next();\n\n        return out;\n    },\n\n    /**\n     * @callback JoinCallback\n     * @memberof module:scramjet~\n     * @param {*} previous the chunk before\n     * @param {*} next the chunk after\n     * @returns {Promise<*>|*}  promise that is resolved with the joining item\n     */\n\n    /**\n     * Method will put the passed object between items. It can also be a function call or generator / iterator.\n     *\n     * If a generator or iterator is passed, when the iteration is done no items will be interweaved.\n     * Generator receives\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param  {*|AsyncGeneratorFunction|GeneratorFunction|JoinCallback} item An object that should be interweaved between stream items\n     * @param {any[]} ...args additional args will be passed to generators\n     *\n     * @test test/methods/data-stream-join.js\n     */\n    join(item, ...args) {\n        const ref = this._selfInstance({referrer: this});\n\n        let prev;\n        let consumer;\n        if (typeof item !== \"function\") {\n            consumer = (cur) => Promise.all([\n                ref.whenWrote(item),\n                ref.whenWrote(cur)\n            ]);\n        } else if (item instanceof GeneratorFunction || item instanceof AsyncGeneratorFunction) {\n            const iterator = item(...args);\n            consumer = cur => Promise.resolve()\n                .then(() => iterator.next(prev))\n                .then(({value, done}) => Promise.all([\n                    !done && ref.whenWrote(value),\n                    ref.whenWrote(prev = cur)\n                ]))\n            ;\n        } else {\n            consumer = cur =>\n                Promise.resolve([prev, prev = cur])\n                    .then(([prev, cur]) => item(prev, cur, ...args),)\n                    .then(joint => Promise.all([\n                        joint && ref.whenWrote(joint),\n                        ref.whenWrote(cur)\n                    ]))\n            ;\n        }\n\n        this.shift(1, ([first]) => ref.push(prev = first))\n            .consume(consumer)\n            .then(() => ref.end());\n\n        return ref;\n    },\n\n    /**\n     * Keep a buffer of n-chunks for use with {@see DataStream..rewind}\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param {number} [count=Infinity] Number of objects or -1 for all the stream\n     *\n     * @test test/methods/data-stream-keep.js\n     */\n    keep(count = -1) {\n        if (count < 0)\n            count = Infinity;\n\n        this.pipe(this.buffer = new ReReadable({ length: count, objectMode: true }));\n\n        return this.tap();\n    },\n\n    /**\n     * Rewinds the buffered chunks the specified length backwards. Requires a prior call to {@see DataStream..keep}\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param {number} [count=Infinity] Number of objects or -1 for all the buffer\n     */\n    rewind(count = -1) {\n        if (count < 0)\n            count = Infinity;\n\n        if (this.buffer) {\n            return this.buffer.tail(count).pipe(this._selfInstance());\n        } else {\n            throw new Error(\"Stream not buffered, cannot rewind.\");\n        }\n    },\n\n    /**\n     * Returns a stream that stacks up incoming items always feeding out the newest items first.\n     * It returns the older items when read\n     *\n     * When the stack length exceeds the given `count` the given `drop` function is awaited\n     * and used for flow control.\n     *\n     * By default the drop function ignores and quietly disposes of items not read before overflow.\n     *\n     * @chainable\n     * @param {number} [count=1000]\n     * @param {function} [drop]\n     * @memberof module:scramjet.DataStream#\n     *\n     * @test test/methods/data-stream-stack.js\n     */\n    stack(count = 1000, drop = () => 0) {\n        if (count < 0)\n            count = Infinity;\n\n        return this.tap().use(\n            source => {\n                const stack = [];\n                const waiting = [];\n                let end = false;\n                const target = new this.constructor({referrer: this, promiseRead() {\n                    if (end) {\n                        if (stack.length) {\n                            const out = stack.slice().reverse();\n                            stack.length = 0;\n                            return out;\n                        } else {\n                            return [];\n                        }\n                    }\n                    if (stack.length) {\n                        return [stack.pop()];\n                    }\n\n                    return new Promise(res => {\n                        waiting.push(res);\n                    });\n                }});\n\n                source\n                    .each(item => {\n                        if (waiting.length === 0) {\n                            stack.push(item);\n                            if (stack.length > count) {\n                                return drop(stack.shift());\n                            }\n                        } else {\n                            waiting.shift()([item]);\n                        }\n                    })\n                    .catch(\n                        e => target.raise(e)\n                    )\n                    .whenEnd()\n                    .then(() => {\n                        end = true;\n                        if (waiting.length) {\n                            console.log(waiting[0]);\n                            waiting.shift()([]);\n                        }\n                    });\n\n                return target;\n            }\n        );\n    },\n\n    /**\n     * Distributes processing into multiple sub-processes or threads if you like.\n     *\n     * @todo Currently order is not kept.\n     * @todo Example test breaks travis-ci build\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param {AffinityCallback|Function|number} [affinity] A Function that affixes the item to specific output stream which must exist in the object for each chunk, must return a string. A number may be passed to identify how many round-robin threads to start up. Defaults to Round Robin to twice the number of CPU threads.\n     * @param {Function|DataStreamOptions} [clusterFunc] stream transforms similar to {@see DataStream#use method}\n     * @param {DataStreamOptions} [options] Options\n     *\n     * @test test/methods/data-stream-distribute.js\n     */\n    distribute(affinity, clusterFunc = null, {\n        plugins = [],\n        options = {}\n    } = {}) {\n\n        if (!clusterFunc && affinity) {\n            clusterFunc = affinity;\n            affinity = os.cpus().length * 2;\n        }\n\n        if (typeof affinity === \"number\") {\n            const roundRobinLength = affinity;\n            let z = 0;\n            options.threads = affinity;\n            affinity = () => z = ++z % roundRobinLength;\n        }\n\n        if (!Array.isArray(clusterFunc))\n            clusterFunc = [clusterFunc];\n\n        const streams = this\n            .separate(affinity, options.createOptions, this.constructor)\n            .cluster(clusterFunc, {\n                plugins,\n                threads: options.threads,\n                StreamClass: this.constructor\n            });\n\n        return streams.mux();\n    },\n\n    /**\n     * Separates stream into a hash of streams. Does not create new streams!\n     *\n     * @chainable\n     * @meta.noreadme\n     * @memberof module:scramjet.DataStream#\n     * @param {object} streams the object hash of streams. Keys must be the outputs of the affinity function\n     * @param {AffinityCallback} affinity the Function that affixes the item to specific streams which must exist in the object for each chunk.\n     */\n    separateInto(streams, affinity) {\n        this.consume(\n            async (chunk) => {\n                const streamId = await affinity(chunk);\n                const found = streams[streamId];\n\n                if (found) {\n                    return found.whenWrote(chunk);\n                }\n\n                throw new Error(\"Output for \" + streamId + \" not found in \" + JSON.stringify(chunk));\n            }\n        );\n        return this;\n    },\n\n    /**\n     * @callback AffinityCallback\n     * @memberof module:scramjet~\n     * @param {*} chunk\n     * @returns {Symbol|string}\n     */\n\n    /**\n     * Separates execution to multiple streams using the hashes returned by the passed Function.\n     *\n     * Calls the given Function for a hash, then makes sure all items with the same hash are processed within a single\n     * stream. Thanks to that streams can be distributed to multiple threads.\n     *\n     * @meta.noreadme\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param {AffinityCallback} affinity the affinity function\n     * @param {DataStreamOptions} [createOptions] options to use to create the separated streams\n     * @param {function(new:DataStream)} [ClassType=this.constructor] options to use to create the separated streams\n     * @return {MultiStream} separated stream\n     *\n     * @test test/methods/data-stream-separate.js\n     */\n    separate(affinity, createOptions = {}, ClassType = this.constructor) {\n        const ret = new MultiStream();\n        const hashes = new Map();\n\n        ClassType = ClassType || this.constructor;\n\n        const pushChunk = async (hash, chunk) => {\n            const _hash = hash.toString();\n            let rightStream;\n            if (!hashes.has(_hash)) {\n                rightStream = new ClassType(createOptions);\n                rightStream._separateId = _hash;\n                hashes.set(_hash, rightStream);\n                ret.add(rightStream);\n            } else {\n                rightStream = hashes.get(_hash);\n            }\n\n            return rightStream.whenWrote(chunk);\n        };\n\n        this.pipe(\n            new this.constructor({\n                async promiseTransform(chunk) {\n                    try {\n                        const hash = await affinity(chunk);\n                        if (Array.isArray(hash)) return Promise.all(hash.map(str => pushChunk(str, chunk)));\n                        else return pushChunk(hash, chunk);\n                    } catch (e) {\n                        ret.emit(\"error\", e);\n                    }\n                },\n                referrer: this\n            })\n                .on(\"end\", () => {\n                    ret.streams.forEach(stream => stream.end());\n                })\n                .resume()\n        );\n\n        return ret;\n    },\n\n    /**\n     * @memberof module:scramjet~\n     * @typedef {Function} DelegateCallback\n     */\n\n    /**\n     * Delegates work to a specified worker.\n     *\n     * @meta.noreadme\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param  {DelegateCallback} delegateFunc A function to be run in the sub-thread.\n     * @param  {StreamWorker}     worker\n     * @param  {Array}            [plugins=[]]\n     */\n    delegate(delegateFunc, worker, plugins = []) {\n        const ret = this._selfInstance({referrer: this});\n        return worker.delegate(this, delegateFunc, plugins).pipe(ret);\n    },\n\n    /**\n     * Limit the rate of the stream to a given number of chunks per second or given timeframe.\n     *\n     * @meta.noreadme\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param  {number}      cps Chunks per timeframe, the default timeframe is 1000 ms.\n     * @param  {RateOptions} [options={}] Options for the limiter controlling the timeframe and time source. Both must work on same units.\n     */\n    rate(cps, {windowSize = 1000, getTime = Date.now, setTimeout = global.setTimeout} = {}) {\n        const refs = [];\n\n        const defer = (time) => new Promise(res => setTimeout(res, time));\n\n        return this.do(\n            () => {\n                const time = getTime();\n                refs.push(time);\n\n                if (refs.length <= cps) return; // DRY fail on purpose here - we don't need to slice the lemon twice.\n\n                refs.splice(0, refs.find(x => x < time - windowSize));\n                if (refs.length <= cps) return;\n\n                return defer(time - refs.shift() + windowSize);\n            }\n        );\n    },\n\n    /**\n     * @typedef {object} RateOptions\n     * @memberof module:scramjet~\n     * @param  {number}   [timeFrame=1000] The size of the window to look for streams.\n     * @param  {Function} [getTime=Date.now] Time source - anything that returns time.\n     * @param  {Function} [setTimeout=setTimeout] Timing function that works identically to setTimeout.\n     */\n\n    /**\n     * Aggregates chunks in arrays given number of number of items long.\n     *\n     * This can be used for micro-batch processing.\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param  {number} count How many items to aggregate\n     *\n     * @test test/methods/data-stream-batch.js\n     */\n    batch(count) {\n        let arr = [];\n\n        const ret = this.tap().pipe(new this.constructor({\n            promiseTransform(chunk) {\n                arr.push(chunk);\n                if (arr.length >= count) {\n                    const push = arr;\n                    arr = [];\n                    return push;\n                }\n                return Promise.reject(DataStream.filter);\n            },\n            promiseFlush() {\n                if (arr.length > 0) {\n                    return [arr];\n                } else\n                    return [];\n            },\n            referrer: this\n        }));\n\n        return ret;\n    },\n\n    /**\n     * Aggregates chunks to arrays not delaying output by more than the given number of ms.\n     *\n     * @meta.noreadme\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param  {number} ms    Maximum amount of milliseconds\n     * @param  {number} [count] Maximum number of items in batch (otherwise no limit)\n     *\n     * @test test/methods/data-stream-timebatch.js\n     */\n    timeBatch(ms, count = Infinity) {\n        let arr = [];\n\n        const setTimeout = this.setTimeout;\n        const clearTimeout = this.clearTimeout;\n\n        let ret = this._selfInstance({referrer: this});\n\n        let pushTimeout = null;\n\n        const push = () => {\n            if (pushTimeout) {\n                clearTimeout(pushTimeout);\n                pushTimeout = null;\n            }\n            const last = ret.whenWrote(arr);\n            arr = [];\n            return last;\n        };\n\n        this.consume(async (chunk) => {\n            arr.push(chunk);\n            if (arr.length >= count) {\n                await push();\n            } else if (!pushTimeout) {\n                pushTimeout = setTimeout(push, ms);\n            }\n        }).then(async () => {\n            if (arr.length) {\n                clearTimeout(pushTimeout);\n                await ret.whenWrote(arr);\n            }\n            ret.end();\n        });\n\n        return ret;\n    },\n\n    /**\n     * Performs the Nagle's algorithm on the data. In essence it waits until we receive some more data and releases them\n     * in bulk.\n     *\n     * @memberof module:scramjet.DataStream#\n     * @todo needs more work, for now it's simply waiting some time, not checking the queues.\n     * @param  {number} [size=32] maximum number of items to wait for\n     * @param  {number} [ms=10]   milliseconds to wait for more data\n     * @chainable\n     * @meta.noreadme\n     */\n    nagle(size = 32, ms = 10) {\n        return this.timeBatch(size, ms)\n            .flatten();\n    },\n\n    /**\n     * Returns a WindowStream of the specified length\n     *\n     * @memberof module:scramjet.DataStream#\n     * @chainable\n     * @param {number} length\n     * @returns {WindowStream} a stream of array's\n     * @meta.noreadme\n     */\n    window(length) {\n        if (!(+length > 0))\n            throw new Error(\"Length argument must be a positive integer!\");\n\n        const arr = [];\n        return this.into(\n            (out, chunk) => {\n                arr.push(chunk);\n                if (arr.length > length)\n                    arr.shift();\n\n                return out.whenWrote(arr.slice());\n            },\n            new scramjet.WindowStream()\n        );\n    },\n\n    /**\n     * Transforms the stream to a streamed JSON array.\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param  {Iterable<any>} [enclosure='[]'] Any iterable object of two items (beginning and end)\n     * @return {StringStream}\n     * @meta.noreadme\n     *\n     * @test test/methods/data-stream-tojsonarray.js\n     */\n    toJSONArray(enclosure = [\"[\\n\", \"\\n]\"], separator = \",\\n\", stringify = JSON.stringify) {\n        const ref = new StringStream({referrer: this});\n        this\n            .shift(1, ([first]) => {\n                ref.push(enclosure[0]);\n                if (first) return ref.whenWrote(stringify(first));\n            })\n            .each(\n                (chunk) => Promise.all([\n                    ref.whenWrote(separator),\n                    ref.whenWrote(stringify(chunk))\n                ])\n            )\n            .run()\n            .then(\n                () => ref.end(enclosure[1])\n            );\n\n        return ref;\n    },\n\n    /**\n     * Transforms the stream to a streamed JSON object.\n     *\n     * @meta.noreadme\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param  {MapCallback} [entryCallback] async function returning an entry (array of [key, value])\n     * @param  {Iterable<any>} [enclosure='{}'] Any iterable object of two items (beginning and end)\n     * @return {StringStream}\n     * @meta.noreadme\n     *\n     * @test test/methods/data-stream-tojsonobject.js\n     */\n    toJSONObject(entryCallback, enclosure = [\"{\\n\",\"\\n}\"], separator = \",\\n\") {\n        let ref = this;\n\n        return ref.map((item) => [entryCallback(item), item])\n            .toJSONArray(enclosure, separator, ([key, value]) => JSON.stringify(key.toString()) + \":\" + JSON.stringify(value));\n    },\n\n\n    /**\n     * Returns a StringStream containing JSON per item with optional end line\n     *\n     * @meta.noreadme\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param  {Boolean|string} [endline=os.EOL] whether to add endlines (boolean or string as delimiter)\n     * @return {StringStream}  output stream\n     * \n     * @test test/methods/data-stream-jsonstringify.js\n     */\n    JSONStringify(eol = os.EOL) {\n        if (!eol)\n            eol = \"\";\n\n        return this.stringify((item) => JSON.stringify(item) + eol);\n    },\n\n    /**\n     * Stringifies CSV to DataString using 'papaparse' module.\n     *\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param {object} [options={}] options for the papaparse.unparse module.\n     * @return {StringStream}  stream of parsed items\n     *\n     * @test test/methods/data-stream-csv.js\n     */\n    CSVStringify(options = {}) {\n        const Papa = require(\"papaparse\");\n        let header = null;\n        let start = 1;\n        options = Object.assign({\n            header: true,\n            newline: os.EOL\n        }, options);\n\n        const outOptions = Object.assign({}, options, {\n            header: false\n        });\n\n        return this\n            .timeBatch(16, 64)\n            .map((arr) => {\n                const out = [];\n                if (!header) {\n                    header = Object.keys(arr[0]);\n                    if (options.header) out.push(header);\n                }\n                for (const item of arr)\n                    out.push(header.map(key => item[key]));\n\n                const x = Papa.unparse(out, outOptions) + options.newline;\n                if (start) {\n                    start = 0;\n                    return x;\n                }\n                return x;\n            })\n            .pipe(new StringStream());\n    },\n\n    /**\n     * @typedef {object} ExecDataOptions\n     * @memberof module:scramjet~\n     * @property {UseCallback} [parse] scramjet module to transform the stream to string or buffer stream\n     * @property {UseCallback} [stringify] scramjet module to transform from string or buffer stream to wanted version\n     * @extends StringStream.ExecOptions\n     */\n\n    /**\n     * Executes a given sub-process with arguments and pipes the current stream into it while returning the output as another DataStream.\n     *\n     * Pipes the current stream into the sub-processes stdin.\n     * The data is serialized and deserialized as JSON lines by default. You\n     * can provide your own alternative methods in the ExecOptions object.\n     *\n     * Note: if you're piping both stderr and stdout (options.stream=3) keep in mind that chunks may get mixed up!\n     *\n     * @param {string} command command to execute\n     * @memberof module:scramjet.DataStream#\n     * @param {ExecDataOptions|any} [options={}] options to be passed to `spawn` and defining serialization.\n     * @param {string[]} ...args additional args will be passed to function\n     *\n     * @test test/methods/data-stream-exec.js\n     */\n    exec(command, options = {}, ...args) {\n        const resolvedCmd = path.resolve(getCalleeDirname(1), command);\n        const stringify = options.stringify || (stream => stream.JSONStringify());\n        const parse = options.parse || (stream => stream.JSONParse());\n\n        return this\n            .use(stringify)\n            .exec(resolvedCmd, options, ...args)\n            .use(parse);\n    },\n\n    /**\n     * Injects a ```debugger``` statement when called.\n     *\n     * @meta.noreadme\n     * @chainable\n     * @memberof module:scramjet.DataStream#\n     * @param  {Function} func if passed, the function will be called on self to add an option to inspect the stream in place, while not breaking the transform chain\n     * @return {DataStream}  self\n     *\n     * @test test/methods/data-stream-debug.js\n     */\n    debug(func) {\n        debugger; // eslint-disable-line\n        this.use(func);\n        return this;\n    },\n\n};\n\nmodule.exports.pop = module.exports.shift;\nmodule.exports.group = module.exports.separate;\n"]},"metadata":{},"sourceType":"script"}