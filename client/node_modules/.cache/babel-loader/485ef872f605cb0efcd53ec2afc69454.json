{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nmodule.exports = /*#__PURE__*/function () {\n  function SymbolTreeNode() {\n    _classCallCheck(this, SymbolTreeNode);\n\n    this.parent = null;\n    this.previousSibling = null;\n    this.nextSibling = null;\n    this.firstChild = null;\n    this.lastChild = null;\n    /** This value is incremented anytime a children is added or removed */\n\n    this.childrenVersion = 0;\n    /** The last child object which has a cached index */\n\n    this.childIndexCachedUpTo = null;\n    /** This value represents the cached node index, as long as\n     * cachedIndexVersion matches with the childrenVersion of the parent */\n\n    this.cachedIndex = -1;\n    this.cachedIndexVersion = NaN; // NaN is never equal to anything\n  }\n\n  _createClass(SymbolTreeNode, [{\n    key: \"isAttached\",\n    get: function get() {\n      return Boolean(this.parent || this.previousSibling || this.nextSibling);\n    }\n  }, {\n    key: \"hasChildren\",\n    get: function get() {\n      return Boolean(this.firstChild);\n    }\n  }, {\n    key: \"childrenChanged\",\n    value: function childrenChanged() {\n      /* jshint -W016 */\n      // integer wrap around\n      this.childrenVersion = this.childrenVersion + 1 & 0xFFFFFFFF;\n      this.childIndexCachedUpTo = null;\n    }\n  }, {\n    key: \"getCachedIndex\",\n    value: function getCachedIndex(parentNode) {\n      // (assumes parentNode is actually the parent)\n      if (this.cachedIndexVersion !== parentNode.childrenVersion) {\n        this.cachedIndexVersion = NaN; // cachedIndex is no longer valid\n\n        return -1;\n      }\n\n      return this.cachedIndex; // -1 if not cached\n    }\n  }, {\n    key: \"setCachedIndex\",\n    value: function setCachedIndex(parentNode, index) {\n      // (assumes parentNode is actually the parent)\n      this.cachedIndexVersion = parentNode.childrenVersion;\n      this.cachedIndex = index;\n    }\n  }]);\n\n  return SymbolTreeNode;\n}();","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/node_modules/symbol-tree/lib/SymbolTreeNode.js"],"names":["module","exports","parent","previousSibling","nextSibling","firstChild","lastChild","childrenVersion","childIndexCachedUpTo","cachedIndex","cachedIndexVersion","NaN","Boolean","parentNode","index"],"mappings":"AAAA;;;;;;AAEAA,MAAM,CAACC,OAAP;AACQ,4BAAc;AAAA;;AACN,SAAKC,MAAL,GAAc,IAAd;AACA,SAAKC,eAAL,GAAuB,IAAvB;AACA,SAAKC,WAAL,GAAmB,IAAnB;AAEA,SAAKC,UAAL,GAAkB,IAAlB;AACA,SAAKC,SAAL,GAAiB,IAAjB;AAEA;;AACA,SAAKC,eAAL,GAAuB,CAAvB;AACA;;AACA,SAAKC,oBAAL,GAA4B,IAA5B;AAEA;AAChB;;AACgB,SAAKC,WAAL,GAAmB,CAAC,CAApB;AACA,SAAKC,kBAAL,GAA0BC,GAA1B,CAhBM,CAgByB;AACtC;;AAlBT;AAAA;AAAA,SAoBQ,eAAiB;AACT,aAAOC,OAAO,CAAC,KAAKV,MAAL,IAAe,KAAKC,eAApB,IAAuC,KAAKC,WAA7C,CAAd;AACP;AAtBT;AAAA;AAAA,SAwBQ,eAAkB;AACV,aAAOQ,OAAO,CAAC,KAAKP,UAAN,CAAd;AACP;AA1BT;AAAA;AAAA,WA4BQ,2BAAkB;AACV;AACA;AACA,WAAKE,eAAL,GAAwB,KAAKA,eAAL,GAAuB,CAAxB,GAA6B,UAApD;AACA,WAAKC,oBAAL,GAA4B,IAA5B;AACP;AAjCT;AAAA;AAAA,WAmCQ,wBAAeK,UAAf,EAA2B;AACnB;AACA,UAAI,KAAKH,kBAAL,KAA4BG,UAAU,CAACN,eAA3C,EAA4D;AACpD,aAAKG,kBAAL,GAA0BC,GAA1B,CADoD,CAEpD;;AACA,eAAO,CAAC,CAAR;AACP;;AAED,aAAO,KAAKF,WAAZ,CARmB,CAQM;AAChC;AA5CT;AAAA;AAAA,WA8CQ,wBAAeI,UAAf,EAA2BC,KAA3B,EAAkC;AAC1B;AACA,WAAKJ,kBAAL,GAA0BG,UAAU,CAACN,eAArC;AACA,WAAKE,WAAL,GAAmBK,KAAnB;AACP;AAlDT;;AAAA;AAAA","sourcesContent":["'use strict';\n\nmodule.exports = class SymbolTreeNode {\n        constructor() {\n                this.parent = null;\n                this.previousSibling = null;\n                this.nextSibling = null;\n\n                this.firstChild = null;\n                this.lastChild = null;\n\n                /** This value is incremented anytime a children is added or removed */\n                this.childrenVersion = 0;\n                /** The last child object which has a cached index */\n                this.childIndexCachedUpTo = null;\n\n                /** This value represents the cached node index, as long as\n                 * cachedIndexVersion matches with the childrenVersion of the parent */\n                this.cachedIndex = -1;\n                this.cachedIndexVersion = NaN; // NaN is never equal to anything\n        }\n\n        get isAttached() {\n                return Boolean(this.parent || this.previousSibling || this.nextSibling);\n        }\n\n        get hasChildren() {\n                return Boolean(this.firstChild);\n        }\n\n        childrenChanged() {\n                /* jshint -W016 */\n                // integer wrap around\n                this.childrenVersion = (this.childrenVersion + 1) & 0xFFFFFFFF;\n                this.childIndexCachedUpTo = null;\n        }\n\n        getCachedIndex(parentNode) {\n                // (assumes parentNode is actually the parent)\n                if (this.cachedIndexVersion !== parentNode.childrenVersion) {\n                        this.cachedIndexVersion = NaN;\n                        // cachedIndex is no longer valid\n                        return -1;\n                }\n\n                return this.cachedIndex; // -1 if not cached\n        }\n\n        setCachedIndex(parentNode, index) {\n                // (assumes parentNode is actually the parent)\n                this.cachedIndexVersion = parentNode.childrenVersion;\n                this.cachedIndex = index;\n        }\n};\n"]},"metadata":{},"sourceType":"script"}