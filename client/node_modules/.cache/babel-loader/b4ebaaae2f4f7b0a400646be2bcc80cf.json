{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require(\"../../utils\"),\n    hasWeakRefs = _require.hasWeakRefs;\n\nvar _require2 = require(\"../helpers/internal-constants\"),\n    domSymbolTree = _require2.domSymbolTree;\n\nvar _require3 = require(\"./helpers\"),\n    filter = _require3.filter,\n    FILTER_ACCEPT = _require3.FILTER_ACCEPT;\n\nexports.implementation = /*#__PURE__*/function () {\n  function NodeIteratorImpl(globalObject, args, privateData) {\n    _classCallCheck(this, NodeIteratorImpl);\n\n    this._active = false;\n    this.root = privateData.root;\n    this.whatToShow = privateData.whatToShow;\n    this.filter = privateData.filter;\n    this._referenceNode = this.root;\n    this._pointerBeforeReferenceNode = true; // This is used to deactivate the NodeIterator if there are too many working in a Document at the same time.\n    // Without weak references, a JS implementation of NodeIterator will leak, since we can't know when to clean it up.\n    // This ensures we force a clean up of those beyond some maximum (specified by the Document).\n\n    if (!hasWeakRefs) {\n      this._working = true;\n    }\n\n    this._globalObject = globalObject;\n  }\n\n  _createClass(NodeIteratorImpl, [{\n    key: \"referenceNode\",\n    get: function get() {\n      this._throwIfNotWorking();\n\n      return this._referenceNode;\n    }\n  }, {\n    key: \"pointerBeforeReferenceNode\",\n    get: function get() {\n      this._throwIfNotWorking();\n\n      return this._pointerBeforeReferenceNode;\n    }\n  }, {\n    key: \"nextNode\",\n    value: function nextNode() {\n      this._throwIfNotWorking();\n\n      return this._traverse(\"next\");\n    }\n  }, {\n    key: \"previousNode\",\n    value: function previousNode() {\n      this._throwIfNotWorking();\n\n      return this._traverse(\"previous\");\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {// Intentionally do nothing, per spec.\n    } // Called by Documents.\n\n  }, {\n    key: \"_preRemovingSteps\",\n    value: function _preRemovingSteps(toBeRemovedNode) {\n      // Second clause is https://github.com/whatwg/dom/issues/496\n      if (!toBeRemovedNode.contains(this._referenceNode) || toBeRemovedNode === this.root) {\n        return;\n      }\n\n      if (this._pointerBeforeReferenceNode) {\n        var next = null;\n        var candidateForNext = domSymbolTree.following(toBeRemovedNode, {\n          skipChildren: true\n        });\n\n        while (candidateForNext !== null) {\n          if (this.root.contains(candidateForNext)) {\n            next = candidateForNext;\n            break;\n          }\n\n          candidateForNext = domSymbolTree.following(candidateForNext, {\n            skipChildren: true\n          });\n        }\n\n        if (next !== null) {\n          this._referenceNode = next;\n          return;\n        }\n\n        this._pointerBeforeReferenceNode = false;\n      }\n\n      var previousSibling = toBeRemovedNode.previousSibling;\n      this._referenceNode = previousSibling === null ? toBeRemovedNode.parentNode : domSymbolTree.lastInclusiveDescendant(toBeRemovedNode.previousSibling);\n    } // Only called by getters and methods that are affected by the pre-removing steps\n\n  }, {\n    key: \"_throwIfNotWorking\",\n    value: function _throwIfNotWorking() {\n      if (!hasWeakRefs && !this._working) {\n        throw Error(\"This NodeIterator is no longer working. More than 10 iterators are being used concurrently. \" + \"Using more than 10 node iterators requires WeakRef support.\");\n      }\n    }\n  }, {\n    key: \"_traverse\",\n    value: function _traverse(direction) {\n      var node = this._referenceNode;\n      var beforeNode = this._pointerBeforeReferenceNode;\n\n      while (true) {\n        if (direction === \"next\") {\n          if (!beforeNode) {\n            node = domSymbolTree.following(node, {\n              root: this.root\n            });\n\n            if (!node) {\n              return null;\n            }\n          }\n\n          beforeNode = false;\n        } else if (direction === \"previous\") {\n          if (beforeNode) {\n            node = domSymbolTree.preceding(node, {\n              root: this.root\n            });\n\n            if (!node) {\n              return null;\n            }\n          }\n\n          beforeNode = true;\n        }\n\n        var result = filter(this, node);\n\n        if (result === FILTER_ACCEPT) {\n          break;\n        }\n      }\n\n      this._referenceNode = node;\n      this._pointerBeforeReferenceNode = beforeNode;\n      return node;\n    }\n  }]);\n\n  return NodeIteratorImpl;\n}();","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/node_modules/jsdom/lib/jsdom/living/traversal/NodeIterator-impl.js"],"names":["require","hasWeakRefs","domSymbolTree","filter","FILTER_ACCEPT","exports","implementation","globalObject","args","privateData","_active","root","whatToShow","_referenceNode","_pointerBeforeReferenceNode","_working","_globalObject","_throwIfNotWorking","_traverse","toBeRemovedNode","contains","next","candidateForNext","following","skipChildren","previousSibling","parentNode","lastInclusiveDescendant","Error","direction","node","beforeNode","preceding","result"],"mappings":"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","sourcesContent":["\"use strict\";\nconst { hasWeakRefs } = require(\"../../utils\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst { filter, FILTER_ACCEPT } = require(\"./helpers\");\n\nexports.implementation = class NodeIteratorImpl {\n  constructor(globalObject, args, privateData) {\n    this._active = false;\n    this.root = privateData.root;\n    this.whatToShow = privateData.whatToShow;\n    this.filter = privateData.filter;\n\n    this._referenceNode = this.root;\n    this._pointerBeforeReferenceNode = true;\n\n    // This is used to deactivate the NodeIterator if there are too many working in a Document at the same time.\n    // Without weak references, a JS implementation of NodeIterator will leak, since we can't know when to clean it up.\n    // This ensures we force a clean up of those beyond some maximum (specified by the Document).\n    if (!hasWeakRefs) {\n      this._working = true;\n    }\n\n    this._globalObject = globalObject;\n  }\n\n  get referenceNode() {\n    this._throwIfNotWorking();\n    return this._referenceNode;\n  }\n\n  get pointerBeforeReferenceNode() {\n    this._throwIfNotWorking();\n    return this._pointerBeforeReferenceNode;\n  }\n\n  nextNode() {\n    this._throwIfNotWorking();\n    return this._traverse(\"next\");\n  }\n\n  previousNode() {\n    this._throwIfNotWorking();\n    return this._traverse(\"previous\");\n  }\n\n  detach() {\n    // Intentionally do nothing, per spec.\n  }\n\n  // Called by Documents.\n  _preRemovingSteps(toBeRemovedNode) {\n    // Second clause is https://github.com/whatwg/dom/issues/496\n    if (!toBeRemovedNode.contains(this._referenceNode) || toBeRemovedNode === this.root) {\n      return;\n    }\n\n    if (this._pointerBeforeReferenceNode) {\n      let next = null;\n      let candidateForNext = domSymbolTree.following(toBeRemovedNode, { skipChildren: true });\n      while (candidateForNext !== null) {\n        if (this.root.contains(candidateForNext)) {\n          next = candidateForNext;\n          break;\n        }\n        candidateForNext = domSymbolTree.following(candidateForNext, { skipChildren: true });\n      }\n\n      if (next !== null) {\n        this._referenceNode = next;\n        return;\n      }\n\n      this._pointerBeforeReferenceNode = false;\n    }\n\n    const { previousSibling } = toBeRemovedNode;\n    this._referenceNode = previousSibling === null ?\n                          toBeRemovedNode.parentNode :\n                          domSymbolTree.lastInclusiveDescendant(toBeRemovedNode.previousSibling);\n  }\n\n  // Only called by getters and methods that are affected by the pre-removing steps\n  _throwIfNotWorking() {\n    if (!hasWeakRefs && !this._working) {\n      throw Error(`This NodeIterator is no longer working. More than 10 iterators are being used concurrently. ` +\n        `Using more than 10 node iterators requires WeakRef support.`);\n    }\n  }\n\n  _traverse(direction) {\n    let node = this._referenceNode;\n    let beforeNode = this._pointerBeforeReferenceNode;\n\n    while (true) {\n      if (direction === \"next\") {\n        if (!beforeNode) {\n          node = domSymbolTree.following(node, { root: this.root });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = false;\n      } else if (direction === \"previous\") {\n        if (beforeNode) {\n          node = domSymbolTree.preceding(node, { root: this.root });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = true;\n      }\n\n      const result = filter(this, node);\n      if (result === FILTER_ACCEPT) {\n        break;\n      }\n    }\n\n    this._referenceNode = node;\n    this._pointerBeforeReferenceNode = beforeNode;\n    return node;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}