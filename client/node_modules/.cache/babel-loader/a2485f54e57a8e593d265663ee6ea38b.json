{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/samehrlich/Desktop/final-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar DOMException = require(\"domexception/webidl2js-wrapper\");\n\nvar _require = require(\"../node\"),\n    clone = _require.clone;\n\nvar NODE_TYPE = require(\"../node-type\");\n\nvar _require2 = require(\"../../browser/parser/index\"),\n    parseFragment = _require2.parseFragment;\n\nvar _require3 = require(\"../helpers/namespaces\"),\n    HTML_NS = _require3.HTML_NS;\n\nvar _require4 = require(\"../helpers/internal-constants\"),\n    domSymbolTree = _require4.domSymbolTree;\n\nvar _require5 = require(\"./boundary-point\"),\n    compareBoundaryPointsPosition = _require5.compareBoundaryPointsPosition;\n\nvar _require6 = require(\"../helpers/node\"),\n    nodeRoot = _require6.nodeRoot,\n    nodeLength = _require6.nodeLength,\n    isInclusiveAncestor = _require6.isInclusiveAncestor;\n\nvar _require7 = require(\"../helpers/create-element\"),\n    createElement = _require7.createElement;\n\nvar AbstractRangeImpl = require(\"./AbstractRange-impl\").implementation;\n\nvar Range = require(\"../generated/Range\");\n\nvar DocumentFragment = require(\"../generated/DocumentFragment\");\n\nvar _require8 = require(\"../generated/utils\"),\n    implForWrapper = _require8.implForWrapper;\n\nvar RANGE_COMPARISON_TYPE = {\n  START_TO_START: 0,\n  START_TO_END: 1,\n  END_TO_END: 2,\n  END_TO_START: 3\n};\n\nvar RangeImpl = /*#__PURE__*/function (_AbstractRangeImpl) {\n  _inherits(RangeImpl, _AbstractRangeImpl);\n\n  var _super = _createSuper(RangeImpl);\n\n  function RangeImpl(globalObject, args, privateData) {\n    var _this;\n\n    _classCallCheck(this, RangeImpl);\n\n    _this = _super.call(this, globalObject, args, privateData);\n    var defaultBoundaryPoint = {\n      node: implForWrapper(globalObject._document),\n      offset: 0\n    };\n    var _privateData$start = privateData.start,\n        start = _privateData$start === void 0 ? defaultBoundaryPoint : _privateData$start,\n        _privateData$end = privateData.end,\n        end = _privateData$end === void 0 ? defaultBoundaryPoint : _privateData$end;\n\n    _this._setLiveRangeStart(start.node, start.offset);\n\n    _this._setLiveRangeEnd(end.node, end.offset);\n\n    return _this;\n  } // https://dom.spec.whatwg.org/#dom-range-commonancestorcontainer\n\n\n  _createClass(RangeImpl, [{\n    key: \"commonAncestorContainer\",\n    get: function get() {\n      var _start = this._start,\n          _end = this._end;\n\n      var _iterator = _createForOfIteratorHelper(domSymbolTree.ancestorsIterator(_start.node)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var container = _step.value;\n\n          if (isInclusiveAncestor(container, _end.node)) {\n            return container;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return null;\n    } // https://dom.spec.whatwg.org/#dom-range-setstart\n\n  }, {\n    key: \"setStart\",\n    value: function setStart(node, offset) {\n      setBoundaryPointStart(this, node, offset);\n    } // https://dom.spec.whatwg.org/#dom-range-setend\n\n  }, {\n    key: \"setEnd\",\n    value: function setEnd(node, offset) {\n      setBoundaryPointEnd(this, node, offset);\n    } // https://dom.spec.whatwg.org/#dom-range-setstartbefore\n\n  }, {\n    key: \"setStartBefore\",\n    value: function setStartBefore(node) {\n      var parent = domSymbolTree.parent(node);\n\n      if (!parent) {\n        throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n      }\n\n      setBoundaryPointStart(this, parent, domSymbolTree.index(node));\n    } // https://dom.spec.whatwg.org/#dom-range-setstartafter\n\n  }, {\n    key: \"setStartAfter\",\n    value: function setStartAfter(node) {\n      var parent = domSymbolTree.parent(node);\n\n      if (!parent) {\n        throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n      }\n\n      setBoundaryPointStart(this, parent, domSymbolTree.index(node) + 1);\n    } // https://dom.spec.whatwg.org/#dom-range-setendbefore\n\n  }, {\n    key: \"setEndBefore\",\n    value: function setEndBefore(node) {\n      var parent = domSymbolTree.parent(node);\n\n      if (!parent) {\n        throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n      }\n\n      setBoundaryPointEnd(this, parent, domSymbolTree.index(node));\n    } // https://dom.spec.whatwg.org/#dom-range-setendafter\n\n  }, {\n    key: \"setEndAfter\",\n    value: function setEndAfter(node) {\n      var parent = domSymbolTree.parent(node);\n\n      if (!parent) {\n        throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n      }\n\n      setBoundaryPointEnd(this, parent, domSymbolTree.index(node) + 1);\n    } // https://dom.spec.whatwg.org/#dom-range-collapse\n\n  }, {\n    key: \"collapse\",\n    value: function collapse(toStart) {\n      if (toStart) {\n        this._setLiveRangeEnd(this._start.node, this._start.offset);\n      } else {\n        this._setLiveRangeStart(this._end.node, this._end.offset);\n      }\n    } // https://dom.spec.whatwg.org/#dom-range-selectnode\n\n  }, {\n    key: \"selectNode\",\n    value: function selectNode(node) {\n      selectNodeWithinRange(node, this);\n    } // https://dom.spec.whatwg.org/#dom-range-selectnodecontents\n\n  }, {\n    key: \"selectNodeContents\",\n    value: function selectNodeContents(node) {\n      if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n        throw DOMException.create(this._globalObject, [\"DocumentType Node can't be used as boundary point.\", \"InvalidNodeTypeError\"]);\n      }\n\n      var length = nodeLength(node);\n\n      this._setLiveRangeStart(node, 0);\n\n      this._setLiveRangeEnd(node, length);\n    } // https://dom.spec.whatwg.org/#dom-range-compareboundarypoints\n\n  }, {\n    key: \"compareBoundaryPoints\",\n    value: function compareBoundaryPoints(how, sourceRange) {\n      if (how !== RANGE_COMPARISON_TYPE.START_TO_START && how !== RANGE_COMPARISON_TYPE.START_TO_END && how !== RANGE_COMPARISON_TYPE.END_TO_END && how !== RANGE_COMPARISON_TYPE.END_TO_START) {\n        var message = \"The comparison method provided must be one of 'START_TO_START', 'START_TO_END', 'END_TO_END', \" + \"or 'END_TO_START'.\";\n        throw DOMException.create(this._globalObject, [message, \"NotSupportedError\"]);\n      }\n\n      if (this._root !== sourceRange._root) {\n        throw DOMException.create(this._globalObject, [\"The two Ranges are not in the same tree.\", \"WrongDocumentError\"]);\n      }\n\n      var thisPoint, otherPoint;\n\n      if (how === RANGE_COMPARISON_TYPE.START_TO_START) {\n        thisPoint = this._start;\n        otherPoint = sourceRange._start;\n      } else if (how === RANGE_COMPARISON_TYPE.START_TO_END) {\n        thisPoint = this._end;\n        otherPoint = sourceRange._start;\n      } else if (how === RANGE_COMPARISON_TYPE.END_TO_END) {\n        thisPoint = this._end;\n        otherPoint = sourceRange._end;\n      } else {\n        thisPoint = this._start;\n        otherPoint = sourceRange._end;\n      }\n\n      return compareBoundaryPointsPosition(thisPoint, otherPoint);\n    } // https://dom.spec.whatwg.org/#dom-range-deletecontents\n\n  }, {\n    key: \"deleteContents\",\n    value: function deleteContents() {\n      if (this.collapsed) {\n        return;\n      }\n\n      var originalStart = this._start,\n          originalEnd = this._end;\n\n      if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n        originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n        return;\n      }\n\n      var nodesToRemove = [];\n      var currentNode = this._start.node;\n      var endNode = nextNodeDescendant(this._end.node);\n\n      while (currentNode && currentNode !== endNode) {\n        if (isContained(currentNode, this) && !isContained(domSymbolTree.parent(currentNode), this)) {\n          nodesToRemove.push(currentNode);\n        }\n\n        currentNode = domSymbolTree.following(currentNode);\n      }\n\n      var newNode, newOffset;\n\n      if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n        newNode = originalStart.node;\n        newOffset = originalStart.offset;\n      } else {\n        var referenceNode = originalStart.node;\n\n        while (referenceNode && !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)) {\n          referenceNode = domSymbolTree.parent(referenceNode);\n        }\n\n        newNode = domSymbolTree.parent(referenceNode);\n        newOffset = domSymbolTree.index(referenceNode) + 1;\n      }\n\n      if (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE) {\n        originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n      }\n\n      for (var _i = 0, _nodesToRemove = nodesToRemove; _i < _nodesToRemove.length; _i++) {\n        var node = _nodesToRemove[_i];\n        var parent = domSymbolTree.parent(node);\n        parent.removeChild(node);\n      }\n\n      if (originalEnd.node.nodeType === NODE_TYPE.TEXT_NODE || originalEnd.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalEnd.node.nodeType === NODE_TYPE.COMMENT_NODE) {\n        originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n      }\n\n      this._setLiveRangeStart(newNode, newOffset);\n\n      this._setLiveRangeEnd(newNode, newOffset);\n    } // https://dom.spec.whatwg.org/#dom-range-extractcontents\n\n  }, {\n    key: \"extractContents\",\n    value: function extractContents() {\n      return extractRange(this);\n    } // https://dom.spec.whatwg.org/#dom-range-clonecontents\n\n  }, {\n    key: \"cloneContents\",\n    value: function cloneContents() {\n      return cloneRange(this);\n    } // https://dom.spec.whatwg.org/#dom-range-insertnode\n\n  }, {\n    key: \"insertNode\",\n    value: function insertNode(node) {\n      insertNodeInRange(node, this);\n    } // https://dom.spec.whatwg.org/#dom-range-surroundcontents\n\n  }, {\n    key: \"surroundContents\",\n    value: function surroundContents(newParent) {\n      var node = this.commonAncestorContainer;\n      var endNode = nextNodeDescendant(node);\n\n      while (node !== endNode) {\n        if (node.nodeType !== NODE_TYPE.TEXT_NODE && isPartiallyContained(node, this)) {\n          throw DOMException.create(this._globalObject, [\"The Range has partially contains a non-Text node.\", \"InvalidStateError\"]);\n        }\n\n        node = domSymbolTree.following(node);\n      }\n\n      if (newParent.nodeType === NODE_TYPE.DOCUMENT_NODE || newParent.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || newParent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n        throw DOMException.create(this._globalObject, [\"Invalid element type.\", \"InvalidNodeTypeError\"]);\n      }\n\n      var fragment = extractRange(this);\n\n      while (domSymbolTree.firstChild(newParent)) {\n        newParent.removeChild(domSymbolTree.firstChild(newParent));\n      }\n\n      insertNodeInRange(newParent, this);\n      newParent.appendChild(fragment);\n      selectNodeWithinRange(newParent, this);\n    } // https://dom.spec.whatwg.org/#dom-range-clonerange\n\n  }, {\n    key: \"cloneRange\",\n    value: function cloneRange() {\n      var _start = this._start,\n          _end = this._end,\n          _globalObject = this._globalObject;\n      return Range.createImpl(_globalObject, [], {\n        start: {\n          node: _start.node,\n          offset: _start.offset\n        },\n        end: {\n          node: _end.node,\n          offset: _end.offset\n        }\n      });\n    } // https://dom.spec.whatwg.org/#dom-range-detach\n\n  }, {\n    key: \"detach\",\n    value: function detach() {// Do nothing by spec!\n    } // https://dom.spec.whatwg.org/#dom-range-ispointinrange\n\n  }, {\n    key: \"isPointInRange\",\n    value: function isPointInRange(node, offset) {\n      if (nodeRoot(node) !== this._root) {\n        return false;\n      }\n\n      validateSetBoundaryPoint(node, offset);\n      var bp = {\n        node: node,\n        offset: offset\n      };\n\n      if (compareBoundaryPointsPosition(bp, this._start) === -1 || compareBoundaryPointsPosition(bp, this._end) === 1) {\n        return false;\n      }\n\n      return true;\n    } // https://dom.spec.whatwg.org/#dom-range-comparepoint\n\n  }, {\n    key: \"comparePoint\",\n    value: function comparePoint(node, offset) {\n      if (nodeRoot(node) !== this._root) {\n        throw DOMException.create(this._globalObject, [\"The given Node and the Range are not in the same tree.\", \"WrongDocumentError\"]);\n      }\n\n      validateSetBoundaryPoint(node, offset);\n      var bp = {\n        node: node,\n        offset: offset\n      };\n\n      if (compareBoundaryPointsPosition(bp, this._start) === -1) {\n        return -1;\n      } else if (compareBoundaryPointsPosition(bp, this._end) === 1) {\n        return 1;\n      }\n\n      return 0;\n    } // https://dom.spec.whatwg.org/#dom-range-intersectsnode\n\n  }, {\n    key: \"intersectsNode\",\n    value: function intersectsNode(node) {\n      if (nodeRoot(node) !== this._root) {\n        return false;\n      }\n\n      var parent = domSymbolTree.parent(node);\n\n      if (!parent) {\n        return true;\n      }\n\n      var offset = domSymbolTree.index(node);\n      return compareBoundaryPointsPosition({\n        node: parent,\n        offset: offset\n      }, this._end) === -1 && compareBoundaryPointsPosition({\n        node: parent,\n        offset: offset + 1\n      }, this._start) === 1;\n    } // https://dom.spec.whatwg.org/#dom-range-stringifier\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var s = \"\";\n      var _start = this._start,\n          _end = this._end;\n\n      if (_start.node === _end.node && _start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n        return _start.node.data.slice(_start.offset, _end.offset);\n      }\n\n      if (_start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n        s += _start.node.data.slice(_start.offset);\n      }\n\n      var currentNode = _start.node;\n      var endNode = nextNodeDescendant(_end.node);\n\n      while (currentNode && currentNode !== endNode) {\n        if (currentNode.nodeType === NODE_TYPE.TEXT_NODE && isContained(currentNode, this)) {\n          s += currentNode.data;\n        }\n\n        currentNode = domSymbolTree.following(currentNode);\n      }\n\n      if (_end.node.nodeType === NODE_TYPE.TEXT_NODE) {\n        s += _end.node.data.slice(0, _end.offset);\n      }\n\n      return s;\n    } // https://w3c.github.io/DOM-Parsing/#dom-range-createcontextualfragment\n\n  }, {\n    key: \"createContextualFragment\",\n    value: function createContextualFragment(fragment) {\n      var node = this._start.node;\n      var element;\n\n      switch (node.nodeType) {\n        case NODE_TYPE.DOCUMENT_NODE:\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n          element = null;\n          break;\n\n        case NODE_TYPE.ELEMENT_NODE:\n          element = node;\n          break;\n\n        case NODE_TYPE.TEXT_NODE:\n        case NODE_TYPE.COMMENT_NODE:\n          element = node.parentElement;\n          break;\n\n        default:\n          throw new Error(\"Internal error: Invalid range start node\");\n      }\n\n      if (element === null || element._ownerDocument._parsingMode === \"html\" && element._localName === \"html\" && element._namespaceURI === HTML_NS) {\n        element = createElement(node._ownerDocument, \"body\", HTML_NS);\n      }\n\n      return parseFragment(fragment, element);\n    } // https://dom.spec.whatwg.org/#concept-range-root\n\n  }, {\n    key: \"_root\",\n    get: function get() {\n      return nodeRoot(this._start.node);\n    }\n  }, {\n    key: \"_setLiveRangeStart\",\n    value: function _setLiveRangeStart(node, offset) {\n      if (this._start && this._start.node !== node) {\n        this._start.node._referencedRanges.delete(this);\n      }\n\n      if (!node._referencedRanges.has(this)) {\n        node._referencedRanges.add(this);\n      }\n\n      this._start = {\n        node: node,\n        offset: offset\n      };\n    }\n  }, {\n    key: \"_setLiveRangeEnd\",\n    value: function _setLiveRangeEnd(node, offset) {\n      if (this._end && this._end.node !== node) {\n        this._end.node._referencedRanges.delete(this);\n      }\n\n      if (!node._referencedRanges.has(this)) {\n        node._referencedRanges.add(this);\n      }\n\n      this._end = {\n        node: node,\n        offset: offset\n      };\n    }\n  }]);\n\n  return RangeImpl;\n}(AbstractRangeImpl);\n\nfunction nextNodeDescendant(node) {\n  while (node && !domSymbolTree.nextSibling(node)) {\n    node = domSymbolTree.parent(node);\n  }\n\n  if (!node) {\n    return null;\n  }\n\n  return domSymbolTree.nextSibling(node);\n} // https://dom.spec.whatwg.org/#concept-range-bp-set\n\n\nfunction validateSetBoundaryPoint(node, offset) {\n  if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n    throw DOMException.create(node._globalObject, [\"DocumentType Node can't be used as boundary point.\", \"InvalidNodeTypeError\"]);\n  }\n\n  if (offset > nodeLength(node)) {\n    throw DOMException.create(node._globalObject, [\"Offset out of bound.\", \"IndexSizeError\"]);\n  }\n}\n\nfunction setBoundaryPointStart(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n  var bp = {\n    node: node,\n    offset: offset\n  };\n\n  if (nodeRoot(node) !== range._root || compareBoundaryPointsPosition(bp, range._end) === 1) {\n    range._setLiveRangeEnd(node, offset);\n  }\n\n  range._setLiveRangeStart(node, offset);\n}\n\nfunction setBoundaryPointEnd(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n  var bp = {\n    node: node,\n    offset: offset\n  };\n\n  if (nodeRoot(node) !== range._root || compareBoundaryPointsPosition(bp, range._start) === -1) {\n    range._setLiveRangeStart(node, offset);\n  }\n\n  range._setLiveRangeEnd(node, offset);\n} // https://dom.spec.whatwg.org/#concept-range-select\n\n\nfunction selectNodeWithinRange(node, range) {\n  var parent = domSymbolTree.parent(node);\n\n  if (!parent) {\n    throw DOMException.create(node._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n  }\n\n  var index = domSymbolTree.index(node);\n\n  range._setLiveRangeStart(parent, index);\n\n  range._setLiveRangeEnd(parent, index + 1);\n} // https://dom.spec.whatwg.org/#contained\n\n\nfunction isContained(node, range) {\n  var _start = range._start,\n      _end = range._end;\n  return compareBoundaryPointsPosition({\n    node: node,\n    offset: 0\n  }, _start) === 1 && compareBoundaryPointsPosition({\n    node: node,\n    offset: nodeLength(node)\n  }, _end) === -1;\n} // https://dom.spec.whatwg.org/#partially-contained\n\n\nfunction isPartiallyContained(node, range) {\n  var _start = range._start,\n      _end = range._end;\n  return isInclusiveAncestor(node, _start.node) && !isInclusiveAncestor(node, _end.node) || !isInclusiveAncestor(node, _start.node) && isInclusiveAncestor(node, _end.node);\n} // https://dom.spec.whatwg.org/#concept-range-insert\n\n\nfunction insertNodeInRange(node, range) {\n  var _range$_start = range._start,\n      startNode = _range$_start.node,\n      startOffset = _range$_start.offset;\n\n  if (startNode.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || startNode.nodeType === NODE_TYPE.COMMENT_NODE || startNode.nodeType === NODE_TYPE.TEXT_NODE && !domSymbolTree.parent(startNode) || node === startNode) {\n    throw DOMException.create(node._globalObject, [\"Invalid start node.\", \"HierarchyRequestError\"]);\n  }\n\n  var referenceNode = startNode.nodeType === NODE_TYPE.TEXT_NODE ? startNode : domSymbolTree.childrenToArray(startNode)[startOffset] || null;\n  var parent = !referenceNode ? startNode : domSymbolTree.parent(referenceNode);\n\n  parent._preInsertValidity(node, referenceNode);\n\n  if (startNode.nodeType === NODE_TYPE.TEXT_NODE) {\n    referenceNode = startNode.splitText(startOffset);\n  }\n\n  if (node === referenceNode) {\n    referenceNode = domSymbolTree.nextSibling(referenceNode);\n  }\n\n  var nodeParent = domSymbolTree.parent(node);\n\n  if (nodeParent) {\n    nodeParent.removeChild(node);\n  }\n\n  var newOffset = !referenceNode ? nodeLength(parent) : domSymbolTree.index(referenceNode);\n  newOffset += node.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? nodeLength(node) : 1;\n  parent.insertBefore(node, referenceNode);\n\n  if (range.collapsed) {\n    range._setLiveRangeEnd(parent, newOffset);\n  }\n} // https://dom.spec.whatwg.org/#concept-range-clone\n\n\nfunction cloneRange(range) {\n  var originalStart = range._start,\n      originalEnd = range._end,\n      _globalObject = range._globalObject;\n  var fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n    fragment.appendChild(cloned);\n    return fragment;\n  }\n\n  var commonAncestor = originalStart.node;\n\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  var firstPartialContainedChild = null;\n\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    var candidate = domSymbolTree.firstChild(commonAncestor);\n\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  var lastPartiallyContainedChild = null;\n\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    var _candidate = domSymbolTree.lastChild(commonAncestor);\n\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(_candidate, range)) {\n        lastPartiallyContainedChild = _candidate;\n      }\n\n      _candidate = domSymbolTree.previousSibling(_candidate);\n    }\n  }\n\n  var containedChildren = domSymbolTree.childrenToArray(commonAncestor).filter(function (node) {\n    return isContained(node, range);\n  });\n  var hasDoctypeChildren = containedChildren.some(function (node) {\n    return node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE;\n  });\n\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  if (firstPartialContainedChild !== null && (firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var _cloned = clone(originalStart.node);\n\n    _cloned._data = _cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n    fragment.appendChild(_cloned);\n  } else if (firstPartialContainedChild !== null) {\n    var _cloned2 = clone(firstPartialContainedChild);\n\n    fragment.appendChild(_cloned2);\n    var subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: originalStart.node,\n        offset: originalStart.offset\n      },\n      end: {\n        node: firstPartialContainedChild,\n        offset: nodeLength(firstPartialContainedChild)\n      }\n    });\n    var subfragment = cloneRange(subrange);\n\n    _cloned2.appendChild(subfragment);\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(containedChildren),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var containedChild = _step2.value;\n\n      var _cloned5 = clone(containedChild, undefined, true);\n\n      fragment.appendChild(_cloned5);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var _cloned3 = clone(originalEnd.node);\n\n    _cloned3._data = _cloned3.substringData(0, originalEnd.offset);\n    fragment.appendChild(_cloned3);\n  } else if (lastPartiallyContainedChild !== null) {\n    var _cloned4 = clone(lastPartiallyContainedChild);\n\n    fragment.appendChild(_cloned4);\n\n    var _subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: lastPartiallyContainedChild,\n        offset: 0\n      },\n      end: {\n        node: originalEnd.node,\n        offset: originalEnd.offset\n      }\n    });\n\n    var _subfragment = cloneRange(_subrange);\n\n    _cloned4.appendChild(_subfragment);\n  }\n\n  return fragment;\n} // https://dom.spec.whatwg.org/#concept-range-extract\n\n\nfunction extractRange(range) {\n  var originalStart = range._start,\n      originalEnd = range._end,\n      _globalObject = range._globalObject;\n  var fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n    fragment.appendChild(cloned);\n    originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n    return fragment;\n  }\n\n  var commonAncestor = originalStart.node;\n\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  var firstPartialContainedChild = null;\n\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    var candidate = domSymbolTree.firstChild(commonAncestor);\n\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  var lastPartiallyContainedChild = null;\n\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    var _candidate2 = domSymbolTree.lastChild(commonAncestor);\n\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(_candidate2, range)) {\n        lastPartiallyContainedChild = _candidate2;\n      }\n\n      _candidate2 = domSymbolTree.previousSibling(_candidate2);\n    }\n  }\n\n  var containedChildren = domSymbolTree.childrenToArray(commonAncestor).filter(function (node) {\n    return isContained(node, range);\n  });\n  var hasDoctypeChildren = containedChildren.some(function (node) {\n    return node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE;\n  });\n\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  var newNode, newOffset;\n\n  if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    newNode = originalStart.node;\n    newOffset = originalStart.offset;\n  } else {\n    var referenceNode = originalStart.node;\n\n    while (referenceNode && !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)) {\n      referenceNode = domSymbolTree.parent(referenceNode);\n    }\n\n    newNode = domSymbolTree.parent(referenceNode);\n    newOffset = domSymbolTree.index(referenceNode) + 1;\n  }\n\n  if (firstPartialContainedChild !== null && (firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var _cloned6 = clone(originalStart.node);\n\n    _cloned6._data = _cloned6.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n    fragment.appendChild(_cloned6);\n    originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n  } else if (firstPartialContainedChild !== null) {\n    var _cloned7 = clone(firstPartialContainedChild);\n\n    fragment.appendChild(_cloned7);\n    var subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: originalStart.node,\n        offset: originalStart.offset\n      },\n      end: {\n        node: firstPartialContainedChild,\n        offset: nodeLength(firstPartialContainedChild)\n      }\n    });\n    var subfragment = extractRange(subrange);\n\n    _cloned7.appendChild(subfragment);\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(containedChildren),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var containedChild = _step3.value;\n      fragment.appendChild(containedChild);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    var _cloned8 = clone(originalEnd.node);\n\n    _cloned8._data = _cloned8.substringData(0, originalEnd.offset);\n    fragment.appendChild(_cloned8);\n    originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n  } else if (lastPartiallyContainedChild !== null) {\n    var _cloned9 = clone(lastPartiallyContainedChild);\n\n    fragment.appendChild(_cloned9);\n\n    var _subrange2 = Range.createImpl(_globalObject, [], {\n      start: {\n        node: lastPartiallyContainedChild,\n        offset: 0\n      },\n      end: {\n        node: originalEnd.node,\n        offset: originalEnd.offset\n      }\n    });\n\n    var _subfragment2 = extractRange(_subrange2);\n\n    _cloned9.appendChild(_subfragment2);\n  }\n\n  range._setLiveRangeStart(newNode, newOffset);\n\n  range._setLiveRangeEnd(newNode, newOffset);\n\n  return fragment;\n}\n\nmodule.exports = {\n  implementation: RangeImpl,\n  setBoundaryPointStart: setBoundaryPointStart,\n  setBoundaryPointEnd: setBoundaryPointEnd\n};","map":{"version":3,"sources":["/Users/samehrlich/Desktop/final-app/node_modules/jsdom/lib/jsdom/living/range/Range-impl.js"],"names":["DOMException","require","clone","NODE_TYPE","parseFragment","HTML_NS","domSymbolTree","compareBoundaryPointsPosition","nodeRoot","nodeLength","isInclusiveAncestor","createElement","AbstractRangeImpl","implementation","Range","DocumentFragment","implForWrapper","RANGE_COMPARISON_TYPE","START_TO_START","START_TO_END","END_TO_END","END_TO_START","RangeImpl","globalObject","args","privateData","defaultBoundaryPoint","node","_document","offset","start","end","_setLiveRangeStart","_setLiveRangeEnd","_start","_end","ancestorsIterator","container","setBoundaryPointStart","setBoundaryPointEnd","parent","create","_globalObject","index","toStart","selectNodeWithinRange","nodeType","DOCUMENT_TYPE_NODE","length","how","sourceRange","message","_root","thisPoint","otherPoint","collapsed","originalStart","originalEnd","TEXT_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","replaceData","nodesToRemove","currentNode","endNode","nextNodeDescendant","isContained","push","following","newNode","newOffset","referenceNode","removeChild","extractRange","cloneRange","insertNodeInRange","newParent","commonAncestorContainer","isPartiallyContained","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","fragment","firstChild","appendChild","createImpl","validateSetBoundaryPoint","bp","s","data","slice","element","ELEMENT_NODE","parentElement","Error","_ownerDocument","_parsingMode","_localName","_namespaceURI","_referencedRanges","delete","has","add","nextSibling","range","startNode","startOffset","childrenToArray","_preInsertValidity","splitText","nodeParent","insertBefore","ownerDocument","cloned","_data","substringData","commonAncestor","firstPartialContainedChild","candidate","lastPartiallyContainedChild","lastChild","previousSibling","containedChildren","filter","hasDoctypeChildren","some","subrange","subfragment","containedChild","undefined","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst { clone } = require(\"../node\");\nconst NODE_TYPE = require(\"../node-type\");\nconst { parseFragment } = require(\"../../browser/parser/index\");\n\nconst { HTML_NS } = require(\"../helpers/namespaces\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst { compareBoundaryPointsPosition } = require(\"./boundary-point\");\nconst { nodeRoot, nodeLength, isInclusiveAncestor } = require(\"../helpers/node\");\nconst { createElement } = require(\"../helpers/create-element\");\n\nconst AbstractRangeImpl = require(\"./AbstractRange-impl\").implementation;\n\nconst Range = require(\"../generated/Range\");\nconst DocumentFragment = require(\"../generated/DocumentFragment\");\nconst { implForWrapper } = require(\"../generated/utils\");\n\nconst RANGE_COMPARISON_TYPE = {\n  START_TO_START: 0,\n  START_TO_END: 1,\n  END_TO_END: 2,\n  END_TO_START: 3\n};\n\nclass RangeImpl extends AbstractRangeImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n\n    const defaultBoundaryPoint = {\n      node: implForWrapper(globalObject._document),\n      offset: 0\n    };\n\n    const {\n      start = defaultBoundaryPoint,\n      end = defaultBoundaryPoint\n    } = privateData;\n\n    this._setLiveRangeStart(start.node, start.offset);\n    this._setLiveRangeEnd(end.node, end.offset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-commonancestorcontainer\n  get commonAncestorContainer() {\n    const { _start, _end } = this;\n\n    for (const container of domSymbolTree.ancestorsIterator(_start.node)) {\n      if (isInclusiveAncestor(container, _end.node)) {\n        return container;\n      }\n    }\n\n    return null;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setstart\n  setStart(node, offset) {\n    setBoundaryPointStart(this, node, offset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setend\n  setEnd(node, offset) {\n    setBoundaryPointEnd(this, node, offset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setstartbefore\n  setStartBefore(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node));\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setstartafter\n  setStartAfter(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node) + 1);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setendbefore\n  setEndBefore(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node));\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setendafter\n  setEndAfter(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node) + 1);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-collapse\n  collapse(toStart) {\n    if (toStart) {\n      this._setLiveRangeEnd(this._start.node, this._start.offset);\n    } else {\n      this._setLiveRangeStart(this._end.node, this._end.offset);\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-selectnode\n  selectNode(node) {\n    selectNodeWithinRange(node, this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-selectnodecontents\n  selectNodeContents(node) {\n    if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n      throw DOMException.create(this._globalObject, [\n        \"DocumentType Node can't be used as boundary point.\",\n        \"InvalidNodeTypeError\"\n      ]);\n    }\n\n    const length = nodeLength(node);\n\n    this._setLiveRangeStart(node, 0);\n    this._setLiveRangeEnd(node, length);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-compareboundarypoints\n  compareBoundaryPoints(how, sourceRange) {\n    if (\n      how !== RANGE_COMPARISON_TYPE.START_TO_START &&\n      how !== RANGE_COMPARISON_TYPE.START_TO_END &&\n      how !== RANGE_COMPARISON_TYPE.END_TO_END &&\n      how !== RANGE_COMPARISON_TYPE.END_TO_START\n    ) {\n      const message = \"The comparison method provided must be one of 'START_TO_START', 'START_TO_END', 'END_TO_END', \" +\n                      \"or 'END_TO_START'.\";\n      throw DOMException.create(this._globalObject, [message, \"NotSupportedError\"]);\n    }\n\n    if (this._root !== sourceRange._root) {\n      throw DOMException.create(this._globalObject, [\"The two Ranges are not in the same tree.\", \"WrongDocumentError\"]);\n    }\n\n    let thisPoint, otherPoint;\n    if (how === RANGE_COMPARISON_TYPE.START_TO_START) {\n      thisPoint = this._start;\n      otherPoint = sourceRange._start;\n    } else if (how === RANGE_COMPARISON_TYPE.START_TO_END) {\n      thisPoint = this._end;\n      otherPoint = sourceRange._start;\n    } else if (how === RANGE_COMPARISON_TYPE.END_TO_END) {\n      thisPoint = this._end;\n      otherPoint = sourceRange._end;\n    } else {\n      thisPoint = this._start;\n      otherPoint = sourceRange._end;\n    }\n\n    return compareBoundaryPointsPosition(thisPoint, otherPoint);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-deletecontents\n  deleteContents() {\n    if (this.collapsed) {\n      return;\n    }\n\n    const { _start: originalStart, _end: originalEnd } = this;\n\n    if (\n      originalStart.node === originalEnd.node &&\n      (\n        originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\n        originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n        originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\n      )\n    ) {\n      originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n      return;\n    }\n\n    const nodesToRemove = [];\n    let currentNode = this._start.node;\n    const endNode = nextNodeDescendant(this._end.node);\n    while (currentNode && currentNode !== endNode) {\n      if (\n        isContained(currentNode, this) &&\n        !isContained(domSymbolTree.parent(currentNode), this)\n      ) {\n        nodesToRemove.push(currentNode);\n      }\n\n      currentNode = domSymbolTree.following(currentNode);\n    }\n\n    let newNode, newOffset;\n    if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n      newNode = originalStart.node;\n      newOffset = originalStart.offset;\n    } else {\n      let referenceNode = originalStart.node;\n\n      while (\n        referenceNode &&\n        !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)\n      ) {\n        referenceNode = domSymbolTree.parent(referenceNode);\n      }\n\n      newNode = domSymbolTree.parent(referenceNode);\n      newOffset = domSymbolTree.index(referenceNode) + 1;\n    }\n\n    if (\n      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\n    ) {\n      originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n    }\n\n    for (const node of nodesToRemove) {\n      const parent = domSymbolTree.parent(node);\n      parent.removeChild(node);\n    }\n\n    if (\n      originalEnd.node.nodeType === NODE_TYPE.TEXT_NODE ||\n      originalEnd.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      originalEnd.node.nodeType === NODE_TYPE.COMMENT_NODE\n    ) {\n      originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n    }\n\n    this._setLiveRangeStart(newNode, newOffset);\n    this._setLiveRangeEnd(newNode, newOffset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-extractcontents\n  extractContents() {\n    return extractRange(this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-clonecontents\n  cloneContents() {\n    return cloneRange(this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-insertnode\n  insertNode(node) {\n    insertNodeInRange(node, this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-surroundcontents\n  surroundContents(newParent) {\n    let node = this.commonAncestorContainer;\n    const endNode = nextNodeDescendant(node);\n    while (node !== endNode) {\n      if (node.nodeType !== NODE_TYPE.TEXT_NODE && isPartiallyContained(node, this)) {\n        throw DOMException.create(this._globalObject, [\n          \"The Range has partially contains a non-Text node.\",\n          \"InvalidStateError\"\n        ]);\n      }\n\n      node = domSymbolTree.following(node);\n    }\n\n    if (\n      newParent.nodeType === NODE_TYPE.DOCUMENT_NODE ||\n      newParent.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE ||\n      newParent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE\n    ) {\n      throw DOMException.create(this._globalObject, [\"Invalid element type.\", \"InvalidNodeTypeError\"]);\n    }\n\n    const fragment = extractRange(this);\n\n    while (domSymbolTree.firstChild(newParent)) {\n      newParent.removeChild(domSymbolTree.firstChild(newParent));\n    }\n\n    insertNodeInRange(newParent, this);\n\n    newParent.appendChild(fragment);\n\n    selectNodeWithinRange(newParent, this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-clonerange\n  cloneRange() {\n    const { _start, _end, _globalObject } = this;\n\n    return Range.createImpl(_globalObject, [], {\n      start: { node: _start.node, offset: _start.offset },\n      end: { node: _end.node, offset: _end.offset }\n    });\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-detach\n  detach() {\n    // Do nothing by spec!\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-ispointinrange\n  isPointInRange(node, offset) {\n    if (nodeRoot(node) !== this._root) {\n      return false;\n    }\n\n    validateSetBoundaryPoint(node, offset);\n\n    const bp = { node, offset };\n\n    if (\n      compareBoundaryPointsPosition(bp, this._start) === -1 ||\n      compareBoundaryPointsPosition(bp, this._end) === 1\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-comparepoint\n  comparePoint(node, offset) {\n    if (nodeRoot(node) !== this._root) {\n      throw DOMException.create(this._globalObject, [\n        \"The given Node and the Range are not in the same tree.\",\n        \"WrongDocumentError\"\n      ]);\n    }\n\n    validateSetBoundaryPoint(node, offset);\n\n    const bp = { node, offset };\n    if (compareBoundaryPointsPosition(bp, this._start) === -1) {\n      return -1;\n    } else if (compareBoundaryPointsPosition(bp, this._end) === 1) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-intersectsnode\n  intersectsNode(node) {\n    if (nodeRoot(node) !== this._root) {\n      return false;\n    }\n\n    const parent = domSymbolTree.parent(node);\n    if (!parent) {\n      return true;\n    }\n\n    const offset = domSymbolTree.index(node);\n\n    return (\n      compareBoundaryPointsPosition({ node: parent, offset }, this._end) === -1 &&\n      compareBoundaryPointsPosition({ node: parent, offset: offset + 1 }, this._start) === 1\n    );\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-stringifier\n  toString() {\n    let s = \"\";\n    const { _start, _end } = this;\n\n    if (_start.node === _end.node && _start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      return _start.node.data.slice(_start.offset, _end.offset);\n    }\n\n    if (_start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      s += _start.node.data.slice(_start.offset);\n    }\n\n    let currentNode = _start.node;\n    const endNode = nextNodeDescendant(_end.node);\n    while (currentNode && currentNode !== endNode) {\n      if (currentNode.nodeType === NODE_TYPE.TEXT_NODE && isContained(currentNode, this)) {\n        s += currentNode.data;\n      }\n\n      currentNode = domSymbolTree.following(currentNode);\n    }\n\n    if (_end.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      s += _end.node.data.slice(0, _end.offset);\n    }\n\n    return s;\n  }\n\n  // https://w3c.github.io/DOM-Parsing/#dom-range-createcontextualfragment\n  createContextualFragment(fragment) {\n    const { node } = this._start;\n\n    let element;\n    switch (node.nodeType) {\n      case NODE_TYPE.DOCUMENT_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        element = null;\n        break;\n\n      case NODE_TYPE.ELEMENT_NODE:\n        element = node;\n        break;\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        element = node.parentElement;\n        break;\n\n      default:\n        throw new Error(\"Internal error: Invalid range start node\");\n    }\n\n    if (\n      element === null || (\n        element._ownerDocument._parsingMode === \"html\" &&\n        element._localName === \"html\" &&\n        element._namespaceURI === HTML_NS\n      )\n    ) {\n      element = createElement(node._ownerDocument, \"body\", HTML_NS);\n    }\n\n    return parseFragment(fragment, element);\n  }\n\n  // https://dom.spec.whatwg.org/#concept-range-root\n  get _root() {\n    return nodeRoot(this._start.node);\n  }\n\n  _setLiveRangeStart(node, offset) {\n    if (this._start && this._start.node !== node) {\n      this._start.node._referencedRanges.delete(this);\n    }\n\n    if (!node._referencedRanges.has(this)) {\n      node._referencedRanges.add(this);\n    }\n\n    this._start = {\n      node,\n      offset\n    };\n  }\n\n  _setLiveRangeEnd(node, offset) {\n    if (this._end && this._end.node !== node) {\n      this._end.node._referencedRanges.delete(this);\n    }\n\n    if (!node._referencedRanges.has(this)) {\n      node._referencedRanges.add(this);\n    }\n\n    this._end = {\n      node,\n      offset\n    };\n  }\n}\n\n\nfunction nextNodeDescendant(node) {\n  while (node && !domSymbolTree.nextSibling(node)) {\n    node = domSymbolTree.parent(node);\n  }\n\n  if (!node) {\n    return null;\n  }\n\n  return domSymbolTree.nextSibling(node);\n}\n\n// https://dom.spec.whatwg.org/#concept-range-bp-set\nfunction validateSetBoundaryPoint(node, offset) {\n  if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n    throw DOMException.create(node._globalObject, [\n      \"DocumentType Node can't be used as boundary point.\",\n      \"InvalidNodeTypeError\"\n    ]);\n  }\n\n  if (offset > nodeLength(node)) {\n    throw DOMException.create(node._globalObject, [\"Offset out of bound.\", \"IndexSizeError\"]);\n  }\n}\nfunction setBoundaryPointStart(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n\n  const bp = { node, offset };\n  if (\n    nodeRoot(node) !== range._root ||\n    compareBoundaryPointsPosition(bp, range._end) === 1\n  ) {\n    range._setLiveRangeEnd(node, offset);\n  }\n\n  range._setLiveRangeStart(node, offset);\n}\nfunction setBoundaryPointEnd(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n\n  const bp = { node, offset };\n  if (\n    nodeRoot(node) !== range._root ||\n    compareBoundaryPointsPosition(bp, range._start) === -1\n  ) {\n    range._setLiveRangeStart(node, offset);\n  }\n\n  range._setLiveRangeEnd(node, offset);\n}\n\n// https://dom.spec.whatwg.org/#concept-range-select\nfunction selectNodeWithinRange(node, range) {\n  const parent = domSymbolTree.parent(node);\n\n  if (!parent) {\n    throw DOMException.create(node._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n  }\n\n  const index = domSymbolTree.index(node);\n\n  range._setLiveRangeStart(parent, index);\n  range._setLiveRangeEnd(parent, index + 1);\n}\n\n// https://dom.spec.whatwg.org/#contained\nfunction isContained(node, range) {\n  const { _start, _end } = range;\n  return (\n    compareBoundaryPointsPosition({ node, offset: 0 }, _start) === 1 &&\n    compareBoundaryPointsPosition({ node, offset: nodeLength(node) }, _end) === -1\n  );\n}\n\n// https://dom.spec.whatwg.org/#partially-contained\nfunction isPartiallyContained(node, range) {\n  const { _start, _end } = range;\n  return (\n    (isInclusiveAncestor(node, _start.node) && !isInclusiveAncestor(node, _end.node)) ||\n    (!isInclusiveAncestor(node, _start.node) && isInclusiveAncestor(node, _end.node))\n  );\n}\n\n// https://dom.spec.whatwg.org/#concept-range-insert\nfunction insertNodeInRange(node, range) {\n  const { node: startNode, offset: startOffset } = range._start;\n\n  if (\n    startNode.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n    startNode.nodeType === NODE_TYPE.COMMENT_NODE ||\n    (startNode.nodeType === NODE_TYPE.TEXT_NODE && !domSymbolTree.parent(startNode)) ||\n    node === startNode\n  ) {\n    throw DOMException.create(node._globalObject, [\"Invalid start node.\", \"HierarchyRequestError\"]);\n  }\n\n  let referenceNode = startNode.nodeType === NODE_TYPE.TEXT_NODE ?\n    startNode :\n    domSymbolTree.childrenToArray(startNode)[startOffset] || null;\n  const parent = !referenceNode ?\n    startNode :\n    domSymbolTree.parent(referenceNode);\n\n  parent._preInsertValidity(node, referenceNode);\n\n  if (startNode.nodeType === NODE_TYPE.TEXT_NODE) {\n    referenceNode = startNode.splitText(startOffset);\n  }\n\n  if (node === referenceNode) {\n    referenceNode = domSymbolTree.nextSibling(referenceNode);\n  }\n\n  const nodeParent = domSymbolTree.parent(node);\n  if (nodeParent) {\n    nodeParent.removeChild(node);\n  }\n\n  let newOffset = !referenceNode ? nodeLength(parent) : domSymbolTree.index(referenceNode);\n  newOffset += node.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? nodeLength(node) : 1;\n\n  parent.insertBefore(node, referenceNode);\n\n  if (range.collapsed) {\n    range._setLiveRangeEnd(parent, newOffset);\n  }\n}\n\n// https://dom.spec.whatwg.org/#concept-range-clone\nfunction cloneRange(range) {\n  const { _start: originalStart, _end: originalEnd, _globalObject } = range;\n\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (\n    originalStart.node === originalEnd.node &&\n    (\n      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n\n    fragment.appendChild(cloned);\n\n    return fragment;\n  }\n\n  let commonAncestor = originalStart.node;\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  let firstPartialContainedChild = null;\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    let candidate = domSymbolTree.firstChild(commonAncestor);\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  let lastPartiallyContainedChild = null;\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    let candidate = domSymbolTree.lastChild(commonAncestor);\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        lastPartiallyContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.previousSibling(candidate);\n    }\n  }\n\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor)\n    .filter(node => isContained(node, range));\n\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  if (\n    firstPartialContainedChild !== null &&\n    (\n      firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\n      firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n\n    fragment.appendChild(cloned);\n  } else if (firstPartialContainedChild !== null) {\n    const cloned = clone(firstPartialContainedChild);\n    fragment.appendChild(cloned);\n\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: { node: originalStart.node, offset: originalStart.offset },\n      end: { node: firstPartialContainedChild, offset: nodeLength(firstPartialContainedChild) }\n    });\n\n    const subfragment = cloneRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  for (const containedChild of containedChildren) {\n    const cloned = clone(containedChild, undefined, true);\n    fragment.appendChild(cloned);\n  }\n\n  if (\n    lastPartiallyContainedChild !== null &&\n    (\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalEnd.node);\n    cloned._data = cloned.substringData(0, originalEnd.offset);\n\n    fragment.appendChild(cloned);\n  } else if (lastPartiallyContainedChild !== null) {\n    const cloned = clone(lastPartiallyContainedChild);\n    fragment.appendChild(cloned);\n\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: { node: lastPartiallyContainedChild, offset: 0 },\n      end: { node: originalEnd.node, offset: originalEnd.offset }\n    });\n\n    const subfragment = cloneRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  return fragment;\n}\n\n// https://dom.spec.whatwg.org/#concept-range-extract\nfunction extractRange(range) {\n  const { _start: originalStart, _end: originalEnd, _globalObject } = range;\n\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (\n    originalStart.node === originalEnd.node &&\n    (\n      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n\n    fragment.appendChild(cloned);\n    originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n\n    return fragment;\n  }\n\n  let commonAncestor = originalStart.node;\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  let firstPartialContainedChild = null;\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    let candidate = domSymbolTree.firstChild(commonAncestor);\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  let lastPartiallyContainedChild = null;\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    let candidate = domSymbolTree.lastChild(commonAncestor);\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        lastPartiallyContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.previousSibling(candidate);\n    }\n  }\n\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor)\n    .filter(node => isContained(node, range));\n\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  let newNode, newOffset;\n  if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    newNode = originalStart.node;\n    newOffset = originalStart.offset;\n  } else {\n    let referenceNode = originalStart.node;\n\n    while (\n      referenceNode &&\n      !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)\n    ) {\n      referenceNode = domSymbolTree.parent(referenceNode);\n    }\n\n    newNode = domSymbolTree.parent(referenceNode);\n    newOffset = domSymbolTree.index(referenceNode) + 1;\n  }\n\n  if (\n    firstPartialContainedChild !== null &&\n    (\n      firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\n      firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n\n    fragment.appendChild(cloned);\n\n    originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n  } else if (firstPartialContainedChild !== null) {\n    const cloned = clone(firstPartialContainedChild);\n    fragment.appendChild(cloned);\n\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: { node: originalStart.node, offset: originalStart.offset },\n      end: { node: firstPartialContainedChild, offset: nodeLength(firstPartialContainedChild) }\n    });\n\n    const subfragment = extractRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  for (const containedChild of containedChildren) {\n    fragment.appendChild(containedChild);\n  }\n\n  if (\n    lastPartiallyContainedChild !== null &&\n    (\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalEnd.node);\n    cloned._data = cloned.substringData(0, originalEnd.offset);\n\n    fragment.appendChild(cloned);\n\n    originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n  } else if (lastPartiallyContainedChild !== null) {\n    const cloned = clone(lastPartiallyContainedChild);\n    fragment.appendChild(cloned);\n\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: { node: lastPartiallyContainedChild, offset: 0 },\n      end: { node: originalEnd.node, offset: originalEnd.offset }\n    });\n\n    const subfragment = extractRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  range._setLiveRangeStart(newNode, newOffset);\n  range._setLiveRangeEnd(newNode, newOffset);\n\n  return fragment;\n}\n\nmodule.exports = {\n  implementation: RangeImpl,\n\n  setBoundaryPointStart,\n  setBoundaryPointEnd\n};\n"]},"metadata":{},"sourceType":"script"}